diff --git a/frameworks/base/Android.mk b/frameworks/base/Android.mk
index 3fb562c..e0a5f26 100755
--- a/frameworks/base/Android.mk
+++ b/frameworks/base/Android.mk
@@ -112,6 +69,7 @@ LOCAL_SRC_FILES += \
 	core/java/android/app/IActivityPendingResult.aidl \
 	core/java/android/app/IAlarmManager.aidl \
 	core/java/android/app/IBackupAgent.aidl \
+	core/java/android/app/ICornerstoneManager.aidl \
 	core/java/android/app/IInstrumentationWatcher.aidl \
 	core/java/android/app/INotificationManager.aidl \
 	core/java/android/app/IProcessObserver.aidl \
diff --git a/frameworks/base/core/java/android/app/ActivityManagerNative.java b/frameworks/base/core/java/android/app/ActivityManagerNative.java
index e12fa19..882f2ea 100644
--- a/frameworks/base/core/java/android/app/ActivityManagerNative.java
+++ b/frameworks/base/core/java/android/app/ActivityManagerNative.java
@@ -1694,6 +1694,94 @@ public abstract class ActivityManagerNative extends Binder implements IActivityM
             return true;
         }
 
+        /**
+         * Author: Onskreen
+         * Date: 15/02/2011
+         *
+         * Cornerstone specific transaction
+         */
+        case SWAP_PANELS_TRANSACTION: {
+            data.enforceInterface(IActivityManager.descriptor);
+            int panelIndex = data.readInt();
+            swapPanels(panelIndex);
+            reply.writeNoException();
+            return true;
+        }
+
+        /**
+         * Author: Onskreen
+         * Date: 22/02/2011
+         *
+         * Cornerstone specific transaction
+         */
+        case CORNERSTONE_STATE_TRANSACTION: {
+            data.enforceInterface(IActivityManager.descriptor);
+            boolean open = data.readInt() != 0;
+            setCornerstoneState(open);
+            reply.writeNoException();
+            return true;
+        }
+
+        /**
+         * Author: Onskreen
+         * Date: 28/02/2011
+         *
+         * Cornerstone specific transaction
+         */
+        case CORNERSTONE_MANAGER_BROADCAST_TRANSACTION: {
+            data.enforceInterface(IActivityManager.descriptor);
+            String targetPkg = data.readString();
+            boolean focus = data.readInt() != 0;
+            int panelIndex = data.readInt();
+            broadcastCornerstonePanelFocusChanged(targetPkg, focus, panelIndex);
+            reply.writeNoException();
+            return true;
+        }
+
+        /**
+         * Author: Onskreen
+         * Date: 28/02/2011
+         *
+         * Cornerstone specific transaction
+         */
+        case CORNERSTONE_MANAGER_TRANSACTION: {
+            data.enforceInterface(IActivityManager.descriptor);
+            ICornerstoneManager manager = ICornerstoneManager.Stub.asInterface(
+            data.readStrongBinder());
+            setCornerstoneManager(manager);
+            reply.writeNoException();
+            return true;
+        }
+
+        /**
+         * Author: Onskreen
+         * Date: 08/03/2011
+         *
+         * Cornerstone specific transaction
+         */
+        case START_CORNERSTONE_APP_TRANSACTION: {
+            data.enforceInterface(IActivityManager.descriptor);
+            Intent intent = Intent.CREATOR.createFromParcel(data);
+            int panelIndex = data.readInt();
+            startCornerstoneApp(intent, panelIndex);
+            reply.writeNoException();
+            return true;
+        }
+
+        /**
+         * Author: Onskreen
+         * Date: 11/04/2011
+         *
+         * Cornerstone specific transaction
+         */
+        case SET_CORNERSTONE_FOCUSED_APP_TRANSACTION: {
+            data.enforceInterface(IActivityManager.descriptor);
+            int panelIndex = data.readInt();
+            setCornerstoneFocusedApp(panelIndex);
+            reply.writeNoException();
+            return true;
+        }
+
         }
 
         return super.onTransact(code, data, reply, flags);
@@ -3873,5 +3961,110 @@ class ActivityManagerProxy implements IActivityManager
         return result;
     }
 
+    /**
+     * Author: Onskreen
+     * Date: 15/02/2011
+     *
+     * Cornerstone specific method
+     */
+    public void swapPanels(int panelIndex) throws RemoteException {
+        Parcel data = Parcel.obtain();
+        Parcel reply = Parcel.obtain();
+        data.writeInterfaceToken(IActivityManager.descriptor);
+        data.writeInt(panelIndex);
+        mRemote.transact(SWAP_PANELS_TRANSACTION, data, reply, 0);
+        reply.readException();
+        data.recycle();
+        reply.recycle();
+    }
+
+    /**
+     * Author: Onskreen
+     * Date: 22/02/2011
+     *
+     * Cornerstone specific method
+     */
+    public void setCornerstoneState(boolean open) throws RemoteException {
+        Parcel data = Parcel.obtain();
+        Parcel reply = Parcel.obtain();
+        data.writeInterfaceToken(IActivityManager.descriptor);
+        data.writeInt(open? 1 : 0);
+        mRemote.transact(CORNERSTONE_STATE_TRANSACTION, data, reply, 0);
+        reply.readException();
+        data.recycle();
+        reply.recycle();
+    }
+
+    /**
+     * Author: Onskreen
+     * Date: 28/02/2011
+     *
+     * Cornerstone specific method
+     */
+    public void setCornerstoneManager(ICornerstoneManager manager) throws RemoteException {
+        Parcel data = Parcel.obtain();
+        Parcel reply = Parcel.obtain();
+        data.writeInterfaceToken(IActivityManager.descriptor);
+        data.writeStrongBinder(manager != null ? manager.asBinder() : null);
+        mRemote.transact(CORNERSTONE_MANAGER_TRANSACTION, data, reply, 0);
+        reply.readException();
+        data.recycle();
+        reply.recycle();
+    }
+
+    /**
+     * Author: Onskreen
+     * Date: 28/02/2011
+     *
+     * Cornerstone specific method
+     */
+    public void broadcastCornerstonePanelFocusChanged(String pkgName, boolean focus, int panelIndex) throws RemoteException {
+        Parcel data = Parcel.obtain();
+        Parcel reply = Parcel.obtain();
+        data.writeInterfaceToken(IActivityManager.descriptor);
+        data.writeString(pkgName);
+        data.writeInt(focus? 1 : 0);
+        data.writeInt(panelIndex);
+        mRemote.transact(CORNERSTONE_MANAGER_BROADCAST_TRANSACTION, data, reply, 0);
+        reply.readException();
+        data.recycle();
+        reply.recycle();
+    }
+
+    /**
+     * Author: Onskreen
+     * Date: 08/03/2011
+     *
+     * Cornerstone specific method
+     */
+    public void startCornerstoneApp(Intent intent, int panelIndex) throws RemoteException {
+        Parcel data = Parcel.obtain();
+        Parcel reply = Parcel.obtain();
+        data.writeInterfaceToken(IActivityManager.descriptor);
+        intent.writeToParcel(data, 0);
+        data.writeInt(panelIndex);
+        mRemote.transact(START_CORNERSTONE_APP_TRANSACTION, data, reply, 0);
+        reply.readException();
+        data.recycle();
+        reply.recycle();
+    }
+
+    /**
+     * Author: Onskreen
+     * Date: 11/04/2011
+     *
+     * Cornerstone specific method
+     */
+    public void setCornerstoneFocusedApp(int panelIndex) throws RemoteException {
+        Parcel data = Parcel.obtain();
+        Parcel reply = Parcel.obtain();
+        data.writeInterfaceToken(IActivityManager.descriptor);
+        data.writeInt(panelIndex);
+        mRemote.transact(SET_CORNERSTONE_FOCUSED_APP_TRANSACTION, data, reply, 0);
+        reply.readException();
+        data.recycle();
+        reply.recycle();
+    }
+
     private IBinder mRemote;
-}
+}
\ No newline at end of file
diff --git a/frameworks/base/core/java/android/app/IActivityManager.java b/frameworks/base/core/java/android/app/IActivityManager.java
index 031e39b..84e17dc 100644
--- a/frameworks/base/core/java/android/app/IActivityManager.java
+++ b/frameworks/base/core/java/android/app/IActivityManager.java
@@ -358,11 +358,62 @@ public interface IActivityManager extends IInterface {
     // manage your activity to make sure it is always the uid you expect.
     public int getLaunchedFromUid(IBinder activityToken) throws RemoteException;
 
+
+    /**
+     * Author: Onskreen
+     * Date: 15/02/2011
+     *
+     * Cornerstone specific Activity capabilities
+     */
+    public void swapPanels(int panelIndex) throws RemoteException;
+
+    /**
+     * Author: Onskreen
+     * Date: 22/02/2011
+     *
+     * Cornerstone specific Activity capabilities
+     */
+    public void setCornerstoneState(boolean open) throws RemoteException;
+
+    /**
+     * Author: Onskreen
+     * Date: 28/02/2011
+     *
+     * Sets the ICornerstoneManager interface, so that AMS can notify CSPanel app whenever CS app
+     * gains or loses the focus.
+     */
+    public void setCornerstoneManager(ICornerstoneManager cs) throws RemoteException;
+
+    /**
+     * Author: Onskreen
+     * Date: 28/02/2011
+     *
+     * WMS notifies to AMS to broadcst the CornerstoneManager's onCornerStonePanelFocusChanged
+     * method so that CSPanel changes the cs apps' controls appropriately.
+     */
+    public void broadcastCornerstonePanelFocusChanged(String pkgName, boolean focus, int panelIndex) throws RemoteException;
+
+    /**
+     * Author: Onskreen
+     * Date: 08/03/2011
+     *
+     * Notifies AMS to launch the Cornerstone app in appropriate index.
+     */
+     public void startCornerstoneApp(Intent intent, int panelIndex) throws RemoteException;
+
+    /**
+     * Author: Onskreen
+     * Date: 11/04/2011
+     *
+     * Notifies AMS to set the focused Cornerstone app in appropriate index.
+     */
+     public void setCornerstoneFocusedApp(int panelIndex) throws RemoteException;
+
     /*
      * Private non-Binder interfaces
      */
     /* package */ boolean testIsSystemReady();
-    
+
     /** Information you can retrieve about a particular application. */
     public static class ContentProviderHolder implements Parcelable {
         public final ProviderInfo info;
@@ -606,4 +657,48 @@ public interface IActivityManager extends IInterface {
     int GET_LAUNCHED_FROM_UID_TRANSACTION = IBinder.FIRST_CALL_TRANSACTION+149;
     int UNSTABLE_PROVIDER_DIED_TRANSACTION = IBinder.FIRST_CALL_TRANSACTION+150;
     int IS_INTENT_SENDER_AN_ACTIVITY_TRANSACTION = IBinder.FIRST_CALL_TRANSACTION+151;
-}
+
+    /**
+     * Author: Onskreen
+     * Date: 15/02/2011
+     *
+     * Cornerstone specific transactions
+     */
+    int SWAP_PANELS_TRANSACTION = IBinder.FIRST_CALL_TRANSACTION+152;
+    /**
+     * Author: Onskreen
+     * Date: 22/02/2011
+     *
+     * Cornerstone specific transactions
+     */
+    int CORNERSTONE_STATE_TRANSACTION = IBinder.FIRST_CALL_TRANSACTION+153;
+    /**
+     * Author: Onskreen
+     * Date: 28/02/2011
+     *
+     * Cornerstone specific transactions
+     */
+    int CORNERSTONE_MANAGER_TRANSACTION = IBinder.FIRST_CALL_TRANSACTION+154;
+    /**
+     * Author: Onskreen
+     * Date: 28/02/2011
+     *
+     * Cornerstone specific transactions
+     */
+    int CORNERSTONE_MANAGER_BROADCAST_TRANSACTION = IBinder.FIRST_CALL_TRANSACTION+155;
+    /**
+     * Author: Onskreen
+     * Date: 08/03/2011
+     *
+     * Cornerstone specific transactions
+     */
+    int START_CORNERSTONE_APP_TRANSACTION = IBinder.FIRST_CALL_TRANSACTION+156;
+
+    /**
+     * Author: Onskreen
+     * Date: 11/04/2011
+     *
+     * Cornerstone specific transactions
+     */
+    int SET_CORNERSTONE_FOCUSED_APP_TRANSACTION = IBinder.FIRST_CALL_TRANSACTION+157;
+}
\ No newline at end of file
diff --git a/frameworks/base/core/java/android/app/ICornerstoneManager.aidl b/frameworks/base/core/java/android/app/ICornerstoneManager.aidl
new file mode 100755
index 0000000..25049e4
--- /dev/null
+++ b/frameworks/base/core/java/android/app/ICornerstoneManager.aidl
@@ -0,0 +1,14 @@
+package android.app;
+
+/**
+ * Author: Onskreen
+ * Date: 28/02/2011
+ *
+ * Callback interface to trigger change in focused panel
+ * in Cornerstone.
+ *
+ * {@hide}
+ */
+interface ICornerstoneManager {
+    void onCornerstonePanelFocusChanged(String pkgName, boolean focus, int panelIndex);
+}
\ No newline at end of file
diff --git a/frameworks/base/core/java/android/view/IWindowSession.aidl b/frameworks/base/core/java/android/view/IWindowSession.aidl
index f6d66df..a430d5a 100644
--- a/frameworks/base/core/java/android/view/IWindowSession.aidl
+++ b/frameworks/base/core/java/android/view/IWindowSession.aidl
@@ -166,11 +165,20 @@ interface IWindowSession {
      * how big the increment is from one screen to another.
      */
     void setWallpaperPosition(IBinder windowToken, float x, float y, float xstep, float ystep);
-    
+
     void wallpaperOffsetsComplete(IBinder window);
-    
+
     Bundle sendWallpaperCommand(IBinder window, String action, int x, int y,
             int z, in Bundle extras, boolean sync);
-    
+
     void wallpaperCommandComplete(IBinder window, in Bundle result);
-}
+
+    /**
+     * Author: Onskreen
+     * Date: 17/02/2011
+     *
+     * Notifies the WindowManagerService to reshuffle its z-order to dispatch the user
+     * input event to the newly focused window.
+     */
+    void handleFocusChange(IBinder token);
+}
\ No newline at end of file
diff --git a/frameworks/base/core/java/android/view/ViewRootImpl.java b/frameworks/base/core/java/android/view/ViewRootImpl.java
index 0b86710..1c9ec9d 100755
--- a/frameworks/base/core/java/android/view/ViewRootImpl.java
+++ b/frameworks/base/core/java/android/view/ViewRootImpl.java
@@ -4322,6 +4221,28 @@ public final class ViewRootImpl implements ViewParent,
 
         @Override
         public void onInputEvent(InputEvent event) {
+			if (event instanceof MotionEvent) {
+				final MotionEvent motionEvent = (MotionEvent)event;
+				/**
+				* Author: Onskreen
+				* Date: 17/02/2011
+				*
+				* Notifies the WindowManagerService to reshuffle its z-order before
+				* dispatching events to the focused window.
+				*/
+				try{
+					//Only send Down Event. Touch will focus the window, rest will
+					//be handled by the view/window.
+					if(motionEvent.getAction()==MotionEvent.ACTION_DOWN) {
+						//If the window of this view already has the focus, no need
+						//to trigger the java side processing of managing this event
+						if(!mView.hasWindowFocus()) {
+							sWindowSession.handleFocusChange(mWindowAttributes.token);
+						}
+					}
+				} catch (RemoteException e) {
+				}
+			}
             enqueueInputEvent(event, this, 0, true);
         }
 
diff --git a/frameworks/base/core/java/android/view/WindowManagerPolicy.java b/frameworks/base/core/java/android/view/WindowManagerPolicy.java
index 09948b8..81a9192 100644
--- a/frameworks/base/core/java/android/view/WindowManagerPolicy.java
+++ b/frameworks/base/core/java/android/view/WindowManagerPolicy.java
@@ -339,6 +339,61 @@ public interface WindowManagerPolicy {
          * Check whether the process hosting this window is currently alive.
          */
         public boolean isAlive();
+
+        /**
+         * Author: Onskreen
+         * Date: 14/04/2011
+         *
+         * Newly added method to WindowManagerPolicy.WindowState.
+         * Returns true if this WindowState is currently focused.
+         */
+        public boolean isFocused();
+
+        /**
+         * Author: Onskreen
+         * Date: 15/04/2011
+         *
+         * Newly added method to WindowManagerPolicy.WindowState.
+         * Returns true if the WindowState will be obstructed by the soft keyboard
+         * due to it's position on the screen
+         */
+        public boolean isObstructedByKeyboard();
+
+        /**
+         * Author: Onskreen
+         * Date: 26/05/2011
+         *
+         * Newly added method to WindowManagerPolicy.WindowState.
+         * Returns true if the WindowState is of type dialog
+         */
+        public boolean isDialog();
+
+        /**
+         * Author: Onskreen
+         * Date: 26/05/2011
+         *
+         * Newly added method to WindowManagerPolicy.WindowState.
+         * Returns IBinder token value
+         */
+        public IBinder getToken();
+
+        /**
+         * Author: Onskreen
+         * Date: 31/05/2011
+         *
+         * Newly added method to WindowManagerPolicy.WindowState.
+         * Removes the Window from the window list.
+         */
+         public void removeWindowState();
+
+        /**
+         * Author: Onskreen
+         * Date: 16/06/2011
+         *
+         * Newly added method to WindowManagerPolicy.WindowState.
+         * Returns true if window frame is in cornerstone panel else false.
+         */
+         public boolean isInCornerstonePanelWindowPanel(IBinder token);
     }
 
     /**
diff --git a/frameworks/base/core/res/res/anim/activity_close_enter_reverse.xml b/frameworks/base/core/res/res/anim/activity_close_enter_reverse.xml
new file mode 100755
index 0000000..0354872
--- /dev/null
+++ b/frameworks/base/core/res/res/anim/activity_close_enter_reverse.xml
@@ -0,0 +1,25 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!--
+/*
+** Copyright 2009, The Android Open Source Project
+**
+** Licensed under the Apache License, Version 2.0 (the "License");
+** you may not use this file except in compliance with the License.
+** You may obtain a copy of the License at
+**
+**     http://www.apache.org/licenses/LICENSE-2.0
+**
+** Unless required by applicable law or agreed to in writing, software
+** distributed under the License is distributed on an "AS IS" BASIS,
+** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+** See the License for the specific language governing permissions and
+** limitations under the License.
+*/
+-->
+
+<set xmlns:android="http://schemas.android.com/apk/res/android"
+        android:interpolator="@anim/decelerate_interpolator"
+        android:zAdjustment="top">
+	<translate android:fromXDelta="100%" android:toXDelta="0"
+        android:duration="@android:integer/config_shortAnimTime"/>
+</set>
\ No newline at end of file
diff --git a/frameworks/base/core/res/res/anim/activity_close_exit_reverse.xml b/frameworks/base/core/res/res/anim/activity_close_exit_reverse.xml
new file mode 100755
index 0000000..5bc3722
--- /dev/null
+++ b/frameworks/base/core/res/res/anim/activity_close_exit_reverse.xml
@@ -0,0 +1,24 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!--
+/*
+** Copyright 2009, The Android Open Source Project
+**
+** Licensed under the Apache License, Version 2.0 (the "License");
+** you may not use this file except in compliance with the License.
+** You may obtain a copy of the License at
+**
+**     http://www.apache.org/licenses/LICENSE-2.0
+**
+** Unless required by applicable law or agreed to in writing, software
+** distributed under the License is distributed on an "AS IS" BASIS,
+** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+** See the License for the specific language governing permissions and
+** limitations under the License.
+*/
+-->
+
+<set xmlns:android="http://schemas.android.com/apk/res/android"
+        android:interpolator="@anim/decelerate_interpolator">
+	<translate android:fromXDelta="0%" android:toXDelta="-33%"
+        android:duration="@android:integer/config_shortAnimTime"/>
+</set>
\ No newline at end of file
diff --git a/frameworks/base/core/res/res/anim/activity_open_enter_reverse.xml b/frameworks/base/core/res/res/anim/activity_open_enter_reverse.xml
new file mode 100755
index 0000000..4ca3a83
--- /dev/null
+++ b/frameworks/base/core/res/res/anim/activity_open_enter_reverse.xml
@@ -0,0 +1,24 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!--
+/*
+** Copyright 2009, The Android Open Source Project
+**
+** Licensed under the Apache License, Version 2.0 (the "License");
+** you may not use this file except in compliance with the License.
+** You may obtain a copy of the License at
+**
+**     http://www.apache.org/licenses/LICENSE-2.0
+**
+** Unless required by applicable law or agreed to in writing, software
+** distributed under the License is distributed on an "AS IS" BASIS,
+** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+** See the License for the specific language governing permissions and
+** limitations under the License.
+*/
+-->
+
+<set xmlns:android="http://schemas.android.com/apk/res/android"
+        android:interpolator="@anim/decelerate_interpolator">
+	<translate android:fromXDelta="-33%" android:toXDelta="0"
+        android:duration="@android:integer/config_shortAnimTime"/>
+</set>
\ No newline at end of file
diff --git a/frameworks/base/core/res/res/anim/activity_open_exit_reverse.xml b/frameworks/base/core/res/res/anim/activity_open_exit_reverse.xml
new file mode 100755
index 0000000..f9e44fa
--- /dev/null
+++ b/frameworks/base/core/res/res/anim/activity_open_exit_reverse.xml
@@ -0,0 +1,25 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!--
+/*
+** Copyright 2009, The Android Open Source Project
+**
+** Licensed under the Apache License, Version 2.0 (the "License");
+** you may not use this file except in compliance with the License.
+** You may obtain a copy of the License at
+**
+**     http://www.apache.org/licenses/LICENSE-2.0
+**
+** Unless required by applicable law or agreed to in writing, software
+** distributed under the License is distributed on an "AS IS" BASIS,
+** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+** See the License for the specific language governing permissions and
+** limitations under the License.
+*/
+-->
+
+<set xmlns:android="http://schemas.android.com/apk/res/android"
+        android:interpolator="@anim/decelerate_interpolator"
+        android:zAdjustment="top">
+	<translate android:fromXDelta="0%" android:toXDelta="100%"
+        android:duration="@android:integer/config_shortAnimTime"/>
+</set>
\ No newline at end of file
diff --git a/frameworks/base/core/res/res/anim/task_close_enter_cornerstone.xml b/frameworks/base/core/res/res/anim/task_close_enter_cornerstone.xml
new file mode 100755
index 0000000..b39d551
--- /dev/null
+++ b/frameworks/base/core/res/res/anim/task_close_enter_cornerstone.xml
@@ -0,0 +1,34 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!--
+/*
+** Copyright 2009, The Android Open Source Project
+**
+** Licensed under the Apache License, Version 2.0 (the "License");
+** you may not use this file except in compliance with the License.
+** You may obtain a copy of the License at
+**
+**     http://www.apache.org/licenses/LICENSE-2.0
+**
+** Unless required by applicable law or agreed to in writing, software
+** distributed under the License is distributed on an "AS IS" BASIS,
+** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+** See the License for the specific language governing permissions and
+** limitations under the License.
+*/
+-->
+
+<set xmlns:android="http://schemas.android.com/apk/res/android"
+        android:background="#ff000000" android:shareInterpolator="false" android:zAdjustment="normal">
+    <scale android:fromXScale="0.95" android:toXScale="1.0"
+            android:fromYScale="0.95" android:toYScale="1.0"
+            android:pivotX="50%p" android:pivotY="50%p"
+            android:fillEnabled="true" android:fillBefore="true" android:fillAfter="true"
+            android:interpolator="@interpolator/decelerate_quint"
+            android:startOffset="200"
+            android:duration="300" />
+    <alpha android:fromAlpha="0" android:toAlpha="1.0"
+            android:interpolator="@interpolator/decelerate_cubic"
+            android:fillEnabled="true" android:fillBefore="true" android:fillAfter="true"
+            android:startOffset="200"
+            android:duration="300"/>
+</set>
\ No newline at end of file
diff --git a/frameworks/base/core/res/res/anim/task_close_enter_reverse.xml b/frameworks/base/core/res/res/anim/task_close_enter_reverse.xml
new file mode 100755
index 0000000..27e6d2e
--- /dev/null
+++ b/frameworks/base/core/res/res/anim/task_close_enter_reverse.xml
@@ -0,0 +1,31 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!--
+/*
+** Copyright 2009, The Android Open Source Project
+**
+** Licensed under the Apache License, Version 2.0 (the "License");
+** you may not use this file except in compliance with the License.
+** You may obtain a copy of the License at
+**
+**     http://www.apache.org/licenses/LICENSE-2.0
+**
+** Unless required by applicable law or agreed to in writing, software
+** distributed under the License is distributed on an "AS IS" BASIS,
+** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+** See the License for the specific language governing permissions and
+** limitations under the License.
+*/
+-->
+
+<set xmlns:android="http://schemas.android.com/apk/res/android"
+        android:interpolator="@anim/decelerate_interpolator"
+        android:zAdjustment="top">
+    <!-- For now stay like the normal activity transition.
+    <scale android:fromXScale="2.0" android:toXScale="1.0"
+           android:fromYScale="2.0" android:toYScale="1.0"
+           android:pivotX="100%p" android:pivotY="50%p"
+           android:duration="@android:integer/config_shortAnimTime" />
+    -->
+    <translate android:fromXDelta="100%" android:toXDelta="0"
+        android:duration="@android:integer/config_shortAnimTime"/>
+</set>
\ No newline at end of file
diff --git a/frameworks/base/core/res/res/anim/task_close_exit_cornerstone.xml b/frameworks/base/core/res/res/anim/task_close_exit_cornerstone.xml
new file mode 100755
index 0000000..ffbd38a
--- /dev/null
+++ b/frameworks/base/core/res/res/anim/task_close_exit_cornerstone.xml
@@ -0,0 +1,35 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!--
+/*
+** Copyright 2009, The Android Open Source Project
+**
+** Licensed under the Apache License, Version 2.0 (the "License");
+** you may not use this file except in compliance with the License.
+** You may obtain a copy of the License at
+**
+**     http://www.apache.org/licenses/LICENSE-2.0
+**
+** Unless required by applicable law or agreed to in writing, software
+** distributed under the License is distributed on an "AS IS" BASIS,
+** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+** See the License for the specific language governing permissions and
+** limitations under the License.
+*/
+-->
+
+<set xmlns:android="http://schemas.android.com/apk/res/android"
+        android:background="#ff000000" android:shareInterpolator="false" android:zAdjustment="top">
+        <alpha android:fromAlpha="1.0" android:toAlpha="0.0"
+                android:interpolator="@interpolator/accelerate_cubic"
+                android:fillEnabled="true" android:fillBefore="true" android:fillAfter="true"
+                android:duration="200" />
+        <scale android:fromXScale="1.0" android:toXScale="1.2"
+                android:fromYScale="1.0" android:toYScale="0.8"
+                android:pivotX="50%p" android:pivotY="50%p"
+                android:interpolator="@interpolator/accelerate_quint"
+                android:fillEnabled="true" android:fillBefore="true" android:fillAfter="true"
+                android:duration="200" />
+        <!-- This is needed to keep the animation running while task_close_enter completes -->
+        <alpha android:fromAlpha="1.0" android:toAlpha="1.0"
+                android:duration="500" />
+</set>
\ No newline at end of file
diff --git a/frameworks/base/core/res/res/anim/task_close_exit_reverse.xml b/frameworks/base/core/res/res/anim/task_close_exit_reverse.xml
new file mode 100755
index 0000000..26068b1
--- /dev/null
+++ b/frameworks/base/core/res/res/anim/task_close_exit_reverse.xml
@@ -0,0 +1,24 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!--
+/*
+** Copyright 2009, The Android Open Source Project
+**
+** Licensed under the Apache License, Version 2.0 (the "License");
+** you may not use this file except in compliance with the License.
+** You may obtain a copy of the License at
+**
+**     http://www.apache.org/licenses/LICENSE-2.0
+**
+** Unless required by applicable law or agreed to in writing, software
+** distributed under the License is distributed on an "AS IS" BASIS,
+** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+** See the License for the specific language governing permissions and
+** limitations under the License.
+*/
+-->
+
+<set xmlns:android="http://schemas.android.com/apk/res/android"
+        android:interpolator="@anim/decelerate_interpolator">
+    <translate android:fromXDelta="0%" android:toXDelta="-33%"
+        android:duration="@android:integer/config_shortAnimTime"/>
+</set>
\ No newline at end of file
diff --git a/frameworks/base/core/res/res/anim/task_open_enter_cornerstone.xml b/frameworks/base/core/res/res/anim/task_open_enter_cornerstone.xml
new file mode 100755
index 0000000..d64f856
--- /dev/null
+++ b/frameworks/base/core/res/res/anim/task_open_enter_cornerstone.xml
@@ -0,0 +1,34 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!--
+/*
+** Copyright 2009, The Android Open Source Project
+**
+** Licensed under the Apache License, Version 2.0 (the "License");
+** you may not use this file except in compliance with the License.
+** You may obtain a copy of the License at
+**
+**     http://www.apache.org/licenses/LICENSE-2.0
+**
+** Unless required by applicable law or agreed to in writing, software
+** distributed under the License is distributed on an "AS IS" BASIS,
+** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+** See the License for the specific language governing permissions and
+** limitations under the License.
+*/
+-->
+
+<set xmlns:android="http://schemas.android.com/apk/res/android"
+        android:background="#ff000000" android:shareInterpolator="false" android:zAdjustment="top">
+    <scale android:fromXScale="1.2" android:toXScale="1.0"
+            android:fromYScale=".8" android:toYScale="1.0"
+            android:pivotX="50%p" android:pivotY="50%p"
+            android:fillEnabled="true" android:fillBefore="true" android:fillAfter="true"
+            android:interpolator="@interpolator/decelerate_quint"
+            android:startOffset="300"
+            android:duration="240" />
+    <alpha android:fromAlpha="0" android:toAlpha="1.0"
+            android:fillEnabled="true" android:fillBefore="true" android:fillAfter="true"
+            android:interpolator="@interpolator/decelerate_quad"
+            android:startOffset="300"
+            android:duration="300"/>
+</set>
\ No newline at end of file
diff --git a/frameworks/base/core/res/res/anim/task_open_enter_reverse.xml b/frameworks/base/core/res/res/anim/task_open_enter_reverse.xml
new file mode 100755
index 0000000..c6a6f51
--- /dev/null
+++ b/frameworks/base/core/res/res/anim/task_open_enter_reverse.xml
@@ -0,0 +1,24 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!--
+/*
+** Copyright 2009, The Android Open Source Project
+**
+** Licensed under the Apache License, Version 2.0 (the "License");
+** you may not use this file except in compliance with the License.
+** You may obtain a copy of the License at
+**
+**     http://www.apache.org/licenses/LICENSE-2.0
+**
+** Unless required by applicable law or agreed to in writing, software
+** distributed under the License is distributed on an "AS IS" BASIS,
+** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+** See the License for the specific language governing permissions and
+** limitations under the License.
+*/
+-->
+
+<set xmlns:android="http://schemas.android.com/apk/res/android"
+        android:interpolator="@anim/decelerate_interpolator">
+    <translate android:fromXDelta="-33%" android:toXDelta="0"
+        android:duration="@android:integer/config_shortAnimTime"/>
+</set>
\ No newline at end of file
diff --git a/frameworks/base/core/res/res/anim/task_open_exit_cornerstone.xml b/frameworks/base/core/res/res/anim/task_open_exit_cornerstone.xml
new file mode 100755
index 0000000..19f92c0
--- /dev/null
+++ b/frameworks/base/core/res/res/anim/task_open_exit_cornerstone.xml
@@ -0,0 +1,35 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!--
+/*
+** Copyright 2009, The Android Open Source Project
+**
+** Licensed under the Apache License, Version 2.0 (the "License");
+** you may not use this file except in compliance with the License.
+** You may obtain a copy of the License at
+**
+**     http://www.apache.org/licenses/LICENSE-2.0
+**
+** Unless required by applicable law or agreed to in writing, software
+** distributed under the License is distributed on an "AS IS" BASIS,
+** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+** See the License for the specific language governing permissions and
+** limitations under the License.
+*/
+-->
+
+<set xmlns:android="http://schemas.android.com/apk/res/android"
+        android:background="#ff000000" android:shareInterpolator="false" android:zAdjustment="normal">
+    <alpha android:fromAlpha="1.0" android:toAlpha="0"
+            android:fillEnabled="true" android:fillBefore="true" android:fillAfter="true"
+            android:interpolator="@interpolator/decelerate_cubic"
+            android:duration="200"/>
+    <scale android:fromXScale="1.0" android:toXScale="0.95"
+            android:fromYScale="1.0" android:toYScale="0.95"
+            android:pivotX="50%p" android:pivotY="50%p"
+            android:fillEnabled="true" android:fillBefore="true" android:fillAfter="true"
+            android:interpolator="@interpolator/decelerate_quint"
+            android:duration="300" />
+    <!-- This is needed to keep the animation running while task_open_enter completes -->
+    <alpha android:fromAlpha="1.0" android:toAlpha="1.0"
+            android:duration="540" />
+</set>
\ No newline at end of file
diff --git a/frameworks/base/core/res/res/anim/task_open_exit_reverse.xml b/frameworks/base/core/res/res/anim/task_open_exit_reverse.xml
new file mode 100755
index 0000000..157abd4
--- /dev/null
+++ b/frameworks/base/core/res/res/anim/task_open_exit_reverse.xml
@@ -0,0 +1,31 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!--
+/*
+** Copyright 2009, The Android Open Source Project
+**
+** Licensed under the Apache License, Version 2.0 (the "License");
+** you may not use this file except in compliance with the License.
+** You may obtain a copy of the License at
+**
+**     http://www.apache.org/licenses/LICENSE-2.0
+**
+** Unless required by applicable law or agreed to in writing, software
+** distributed under the License is distributed on an "AS IS" BASIS,
+** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+** See the License for the specific language governing permissions and
+** limitations under the License.
+*/
+-->
+
+<set xmlns:android="http://schemas.android.com/apk/res/android"
+        android:interpolator="@anim/decelerate_interpolator"
+        android:zAdjustment="top">
+    <!-- For now stay like the normal activity transition.
+    <scale android:fromXScale="1.0" android:toXScale="2.0"
+           android:fromYScale="1.0" android:toYScale="2.0"
+           android:pivotX="100%p" android:pivotY="50%p"
+           android:duration="@android:integer/config_shortAnimTime" />
+    -->
+    <translate android:fromXDelta="0%" android:toXDelta="100%"
+        android:duration="@android:integer/config_shortAnimTime"/>
+</set>
\ No newline at end of file
diff --git a/frameworks/base/core/res/res/values/attrs.xml b/frameworks/base/core/res/res/values/attrs.xml
index 9cd04e4..ae61bca 100755
--- a/frameworks/base/core/res/res/values/attrs.xml
+++ b/frameworks/base/core/res/res/values/attrs.xml
@@ -1636,6 +1636,38 @@
         <!-- The animation used when a window is going from VISIBLE to INVISIBLE. -->
         <attr name="windowHideAnimation" format="reference" />
 
+		<!--
+			Author: Onskreen
+			Date: 16/03/2011
+			Cornerstone open/close animation
+		-->
+        <attr name="activityOpenEnterAnimation_reverse" format="reference" />
+        <attr name="activityOpenExitAnimation_reverse" format="reference" />
+        <attr name="activityCloseEnterAnimation_reverse" format="reference" />
+        <attr name="activityCloseExitAnimation_reverse" format="reference" />
+        <attr name="taskOpenEnterAnimation_reverse" format="reference" />
+        <attr name="taskOpenExitAnimation_reverse" format="reference" />
+        <attr name="taskCloseEnterAnimation_reverse" format="reference" />
+        <attr name="taskCloseExitAnimation_reverse" format="reference" />
+        <attr name="taskToFrontEnterAnimation_reverse" format="reference" />
+        <attr name="taskToFrontExitAnimation_reverse" format="reference" />
+        <attr name="taskToBackEnterAnimation_reverse" format="reference" />
+        <attr name="taskToBackExitAnimation_reverse" format="reference" />
+
+		<!--
+			Author: Onskreen
+			Date: 11/01/2013
+			Cornerstone open/close animation
+		-->
+        <attr name="taskOpenEnterAnimation_cornerstone" format="reference" />
+        <attr name="taskOpenExitAnimation_cornerstone" format="reference" />
+        <attr name="taskCloseEnterAnimation_cornerstone" format="reference" />
+        <attr name="taskCloseExitAnimation_cornerstone" format="reference" />
+        <attr name="taskToFrontEnterAnimation_cornerstone" format="reference" />
+        <attr name="taskToFrontExitAnimation_cornerstone" format="reference" />
+        <attr name="taskToBackEnterAnimation_cornerstone" format="reference" />
+        <attr name="taskToBackExitAnimation_cornerstone" format="reference" />
+
         <!--  When opening a new activity, this is the animation that is
               run on the next activity (which is entering the screen). -->
         <attr name="activityOpenEnterAnimation" format="reference" />
@@ -5716,4 +5748,4 @@
         <attr name="minHeight" />
     </declare-styleable>
 
-</resources>
+</resources>
\ No newline at end of file
diff --git a/frameworks/base/core/res/res/values/public.xml b/frameworks/base/core/res/res/values/public.xml
index c3a90e6..6c05346 100755
--- a/frameworks/base/core/res/res/values/public.xml
+++ b/frameworks/base/core/res/res/values/public.xml
@@ -1143,6 +1139,7 @@
   <java-symbol type="xml" name="password_kbd_symbols_shift" />
   <java-symbol type="xml" name="power_profile" />
   <java-symbol type="xml" name="time_zones_by_country" />
+  <java-symbol type="xml" name="cornerstone" />
 
   <java-symbol type="raw" name="accessibility_gestures" />
   <java-symbol type="raw" name="incognito_mode_start_page" />
@@ -1395,6 +1391,14 @@
   <java-symbol type="anim" name="screen_rotate_start_exit" />
   <java-symbol type="anim" name="screen_rotate_start_frame" />
   <java-symbol type="anim" name="window_move_from_decor" />
+  <java-symbol type="anim" name="activity_close_enter_reverse" />
+  <java-symbol type="anim" name="activity_close_exit_reverse" />
+  <java-symbol type="anim" name="activity_open_enter_reverse" />
+  <java-symbol type="anim" name="activity_open_exit_reverse" />
+  <java-symbol type="anim" name="task_close_enter_reverse" />
+  <java-symbol type="anim" name="task_close_exit_reverse" />
+  <java-symbol type="anim" name="task_open_enter_reverse" />
+  <java-symbol type="anim" name="task_open_exit_reverse" />
   <java-symbol type="array" name="config_autoBrightnessButtonBacklightValues" />
   <java-symbol type="array" name="config_autoBrightnessKeyboardBacklightValues" />
   <java-symbol type="array" name="config_autoBrightnessLcdBacklightValues" />
diff --git a/frameworks/base/core/res/res/values/styles.xml b/frameworks/base/core/res/res/values/styles.xml
index e4fc26b..cf459ce 100644
--- a/frameworks/base/core/res/res/values/styles.xml
+++ b/frameworks/base/core/res/res/values/styles.xml
@@ -77,6 +77,39 @@ please see styles_device_defaults.xml.
 
     <!-- Standard animations for a full-screen window or activity. -->
     <style name="Animation.Activity">
+
+		<!--
+			Author: Onskreen
+			Date: 16/03/2011
+			Cornerstone open/close animation styles
+		-->
+        <item name="activityOpenEnterAnimation_reverse">@anim/activity_open_enter_reverse</item>
+        <item name="activityOpenExitAnimation_reverse">@anim/activity_open_exit_reverse</item>
+        <item name="activityCloseEnterAnimation_reverse">@anim/activity_close_enter_reverse</item>
+        <item name="activityCloseExitAnimation_reverse">@anim/activity_close_exit_reverse</item>
+        <item name="taskOpenEnterAnimation_reverse">@anim/task_open_enter_reverse</item>
+        <item name="taskOpenExitAnimation_reverse">@anim/task_open_exit_reverse</item>
+        <item name="taskCloseEnterAnimation_reverse">@anim/task_close_enter_reverse</item>
+        <item name="taskCloseExitAnimation_reverse">@anim/task_close_exit_reverse</item>
+        <item name="taskToFrontEnterAnimation_reverse">@anim/task_open_enter_reverse</item>
+        <item name="taskToFrontExitAnimation_reverse">@anim/task_open_exit_reverse</item>
+        <item name="taskToBackEnterAnimation_reverse">@anim/task_close_enter_reverse</item>
+        <item name="taskToBackExitAnimation_reverse">@anim/task_close_exit_reverse</item>
+
+        <!--
+			Author: Onskreen
+			Date: 11/01/2013
+			Cornerstone open/close animation styles
+		-->
+        <item name="taskOpenEnterAnimation_cornerstone">@anim/task_open_enter_cornerstone</item>
+        <item name="taskOpenExitAnimation_cornerstone">@anim/task_open_exit_cornerstone</item>
+        <item name="taskCloseEnterAnimation_cornerstone">@anim/task_close_enter_cornerstone</item>
+        <item name="taskCloseExitAnimation_cornerstone">@anim/task_close_enter_cornerstone</item>
+		<item name="taskToFrontEnterAnimation_cornerstone">@anim/task_open_enter_cornerstone</item>
+        <item name="taskToFrontExitAnimation_cornerstone">@anim/task_open_exit_cornerstone</item>
+        <item name="taskToBackEnterAnimation_cornerstone">@anim/task_close_enter_cornerstone</item>
+        <item name="taskToBackExitAnimation_cornerstone">@anim/task_close_exit_cornerstone</item>
+
         <item name="activityOpenEnterAnimation">@anim/activity_open_enter</item>
         <item name="activityOpenExitAnimation">@anim/activity_open_exit</item>
         <item name="activityCloseEnterAnimation">@anim/activity_close_enter</item>
diff --git a/frameworks/base/core/res/res/xml/cornerstone.xml b/frameworks/base/core/res/res/xml/cornerstone.xml
new file mode 100755
index 0000000..bb860cb
--- /dev/null
+++ b/frameworks/base/core/res/res/xml/cornerstone.xml
@@ -0,0 +1,124 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!--
+/*
+**
+** Copyright 2011, The Android Open Source Project
+**
+** Licensed under the Apache License, Version 2.0 (the "License");
+** you may not use this file except in compliance with the License.
+** You may obtain a copy of the License at
+**
+**     http://www.apache.org/licenses/LICENSE-2.0
+**
+** Unless required by applicable law or agreed to in writing, software
+** distributed under the License is distributed on an "AS IS" BASIS,
+** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+** See the License for the specific language governing permissions and
+** limitations under the License.
+*/
+
+**
+** Author: Onskreen
+** Date: 21/07/2011
+** Cornerstone specific static values
+*/
+-->
+<cornerstone>
+	<pkg>com.onskreen.cornerstone.panel</pkg>
+	<launcher>
+		<pkg>com.onskreen.cornerstone.launcher</pkg>
+		<class>com.onskreen.cornerstone.launcher.CSLauncher</class>
+	</launcher>
+	<layout width="1024" height="600">
+		<landscape>
+			<width>450</width>
+			<height>257</height>
+			<handler>
+				<width>38</width>
+			</handler>
+			<appheader>
+				<height>30</height>
+			</appheader>
+		</landscape>
+		<portrait>
+			<width>298</width>
+			<height>330</height>
+			<handler>
+				<width>38</width>
+			</handler>
+			<appheader>
+				<height>30</height>
+			</appheader>
+			<gutter>4</gutter>
+		</portrait>
+	</layout>
+	<layout width="1366" height="768">
+		<landscape>
+			<width>450</width>
+			<height>341</height>
+			<handler>
+				<width>38</width>
+			</handler>
+			<appheader>
+				<height>30</height>
+			</appheader>
+		</landscape>
+		<portrait>
+			<width>382</width>
+			<height>330</height>
+			<handler>
+				<width>38</width>
+			</handler>
+			<appheader>
+				<height>30</height>
+			</appheader>
+			<gutter>4</gutter>
+		</portrait>
+	</layout>
+	<layout width="1280" height="768">
+		<landscape>
+			<width>450</width>
+			<height>330</height>
+			<handler>
+				<width>38</width>
+			</handler>
+			<appheader>
+				<height>30</height>
+			</appheader>
+		</landscape>
+		<portrait>
+			<width>382</width>
+			<height>330</height>
+			<handler>
+				<width>38</width>
+			</handler>
+			<appheader>
+				<height>30</height>
+			</appheader>
+			<gutter>4</gutter>
+		</portrait>
+	</layout>
+	<layout width="1280" height="800">
+		<landscape>
+			<width>450</width>
+			<height>346</height>
+			<handler>
+				<width>38</width>
+			</handler>
+			<appheader>
+				<height>30</height>
+			</appheader>
+		</landscape>
+		<portrait>
+			<width>398</width>
+			<height>330</height>
+			<handler>
+				<width>38</width>
+			</handler>
+			<appheader>
+				<height>30</height>
+			</appheader>
+			<gutter>4</gutter>
+		</portrait>
+	</layout>
+</cornerstone>
\ No newline at end of file
diff --git a/frameworks/base/policy/src/com/android/internal/policy/impl/PhoneWindowManager.java b/frameworks/base/policy/src/com/android/internal/policy/impl/PhoneWindowManager.java
index 4ec3821..379af84 100644
--- a/frameworks/base/policy/src/com/android/internal/policy/impl/PhoneWindowManager.java
+++ b/frameworks/base/policy/src/com/android/internal/policy/impl/PhoneWindowManager.java
@@ -514,10 +509,20 @@ public class PhoneWindowManager implements WindowManagerPolicy {
     private long mPowerKeyTime;
 
     ShortcutManager mShortcutManager;
-    EventProcManager mEventProcManager;
     PowerManager.WakeLock mBroadcastWakeLock;
     boolean mHavePendingMediaKeyRepeatWithWakeLock;
 
+    /**
+     * Author: Onskreen
+     * Date: 14/04/2011
+     *
+     * In the case of virtual keyboard, these Window shifting flags are used.
+     * Including the windows which are shifted currently and the amount the window
+     * was shifted. This policy tracks how much and when to shift the windows
+     */
+    ArrayList<WindowState> mWindowsShifted = new ArrayList<WindowState>();
+    int mWindowShiftAmount;
+
     // Fallback actions by key code.
     private final SparseArray<KeyCharacterMap.FallbackAction> mFallbackActions =
             new SparseArray<KeyCharacterMap.FallbackAction>();
@@ -1326,12 +1285,22 @@ public class PhoneWindowManager implements WindowManagerPolicy {
                 attrs.flags &= ~WindowManager.LayoutParams.FLAG_WATCH_OUTSIDE_TOUCH;
                 break;
         }
+
+        /**
+         * Author: Onskreen
+         * Date: 24/02/2011
+         *
+         * Removes the FULLSCREEN flag from the app to render it within CS panel.
+         */
+        if ((attrs.flags & WindowManager.LayoutParams.FLAG_FULLSCREEN) != 0) {
+            attrs.flags ^= WindowManager.LayoutParams.FLAG_FULLSCREEN;
+        }
     }
-    
+
     void readLidState() {
         mLidState = mWindowManagerFuncs.getLidState();
     }
-    
+
     private boolean isHidden(int accessibilityMode) {
         switch (accessibilityMode) {
             case 1:
@@ -1899,6 +1859,16 @@ public class PhoneWindowManager implements WindowManagerPolicy {
                     }
                 }
                 if (repeatCount == 0) {
+                    /**
+                     * Author: Onskreen
+                     * Date: 31/05/2011
+                     *
+                     * If the dialog is present, first kill/dismiss the dialog
+                     * and then launch the HOME app or recent app dialog.
+                     */
+					if(win.isDialog()){
+						win.removeWindowState();
+					}
                     mHomePressed = true;
                 } else if ((event.getFlags() & KeyEvent.FLAG_LONG_PRESS) != 0) {
                     if (!keyguardOn) {
@@ -2736,8 +2706,20 @@ public class PhoneWindowManager implements WindowManagerPolicy {
                         vf.top = mCurTop;
                         vf.right = mCurRight;
                         vf.bottom = mCurBottom;
+
+                        /**
+                         * Author: Onskreen
+                         * Date: 18/01/2011
+                         *
+                         * Adjusts the size of pf, df, cf, vf rects.
+                         */
+						if (attrs.type != TYPE_STATUS_BAR_PANEL
+								|| attrs.type != TYPE_STATUS_BAR_SUB_PANEL) {
+							setWindowInFrame(win, attrs, pf, df, cf, vf);
+						}
                     } else {
                         vf.set(cf);
+                        setWindowInFrame(win, attrs, pf, df, cf, vf);
                     }
                 }
             } else if ((fl & FLAG_LAYOUT_IN_SCREEN) != 0 || (sysUiFl
@@ -2821,6 +2803,23 @@ public class PhoneWindowManager implements WindowManagerPolicy {
                 } else {
                     vf.set(cf);
                 }
+
+                /**
+                 * Author: Onskreen
+                 * Date: 25/05/2011
+                 *
+                 * Check added to render well the QuickContactActivity and other similar apps
+                 * in main panel or either of cs panels.
+                 */
+                /**
+                 * Author: Onskreen
+                 * Date: 20/12/2011
+                 *
+                 * TYPE_CHANGED is no longer a defined Window type
+                 */
+				/**if (attrs.type != TYPE_CHANGED) {
+						setWindowInFrame(win, attrs, pf, df, cf, vf);
+				} **/
             } else if (attached != null) {
                 if (DEBUG_LAYOUT)
                     Log.v(TAG, "layoutWindowLw(" + attrs.getTitle() + "): attached to " + attached);
@@ -2866,10 +2865,55 @@ public class PhoneWindowManager implements WindowManagerPolicy {
                     } else {
                         vf.set(cf);
                     }
+
+                    /**
+                     * Author: Onskreen
+                     * Date: 20/12/2011
+                     *
+                     * TYPE_CHANGED, FORMAT_CHANGED, TYPE_BASE_APPLICATION, FLAG_ALT_FOCUSABLE_IM, FLAG_DIM_BEHIND are no longer a defined Window Type.
+                     * Have to determine how that will affect laying out windows.
+                     *
+                     * Commented out entire if block for now.
+                     */
+                    /**
+                     * Author: Onskreen
+                     * Date: 21/04/2011
+                     *
+                     * When browser app is launched, it loads the address bar and type of the browser window is
+                     * TYPE_CHANGED. This only happens when address bar loads initially. The address bar is not
+                     * an attached window and this change doesn't affect the laying out of system dialogs
+                     * (menu, virtual keyboard, dialogs etc.).
+                     */
+//                 if (attrs.type == TYPE_CHANGED) {
+//                 if (DEBUG_LAYOUT) Log.v(TAG, "\tWin Type: TYPE_CHANGED found ");
+                    /**
+                     * Author: Onskreen
+                     * Date: 26/04/2011
+                     *
+                     * To distinguish the browser address bar and other like apps, we've to check the additional
+                     * condition of what type of the WindowManager.Layoutparams.flags is. The flag combination
+                     * helps us to not resize the window frame layout rect for the apps which is also of type
+                     * TYPE_CHANGED for ex, Facebook, Minispace war apps.
+                     *
+                     * Without including the below condition, it was causing windows that should be laid out across
+                     * the entire screen to be rendered only within the window frame and also at the same z order
+                     * as the main window, causing them to be hidden. To reproduce:
+                     *   - Open MiniSpaceWars in the CS Panel. The loading window is centered on the WF and not
+                     *   visible.
+                     *   - Open Facebook (very first time on device) in main panel, the Accept terms dialog is
+                     *   centered on the WF instead of full window and is hidden behind the other panels.
+                     */
+//                   if(((fl & FORMAT_CHANGED) != 0) || (fl == 0)){
+//                      if (DEBUG_LAYOUT) Log.v(TAG, "\tWin Flag: FORMAT_CHANGED found ");
+//                         setWindowInFrame(win, attrs, pf, df, cf, vf);
+//                      }
+//                  } else if ((attrs.type == TYPE_BASE_APPLICATION) && (fl != (FLAG_ALT_FOCUSABLE_IM | FLAG_DIM_BEHIND))){
+                        //setWindowInFrame(win, attrs, pf, df, cf, vf);
+//                  }
                 }
             }
         }
-        
+
         if ((fl & FLAG_LAYOUT_NO_LIMITS) != 0) {
             df.left = df.top = cf.left = cf.top = vf.left = vf.top = -10000;
             df.right = df.bottom = cf.right = cf.bottom = vf.right = vf.bottom = 10000;
@@ -2881,9 +2925,16 @@ public class PhoneWindowManager implements WindowManagerPolicy {
                 + String.format(" flags=0x%08x", fl)
                 + " pf=" + pf.toShortString() + " df=" + df.toShortString()
                 + " cf=" + cf.toShortString() + " vf=" + vf.toShortString());
-        
+
         win.computeFrameLw(pf, df, cf, vf);
-        
+        /**
+         * Author: Onskreen
+         * Date: 14/04/2011
+         *
+         * This logic ensures that the appropriate rects (mContent* and mCurr*)
+         * are modified accordingly when the input method window is visible. These
+         * rects are used when the Window has SOFT_INPUT_ADJUST_RESIZE set
+         */
         // Dock windows carve out the bottom of the screen, so normal windows
         // can't appear underneath them.
         if (attrs.type == TYPE_INPUT_METHOD && !win.getGivenInsetsPendingLw()) {
@@ -2908,6 +2959,243 @@ public class PhoneWindowManager implements WindowManagerPolicy {
                 + mContentBottom + " mCurBottom=" + mCurBottom);
     }
 
+    /**
+     * Author: Onskreen
+     * Date: 18/01/2011
+     *
+     * Sets the parent, display, content and visible Rects to the size of WindoState.mFrame rect.
+     */
+    private void setWindowInFrame(WindowState win, WindowManager.LayoutParams attrs, Rect pf, Rect df, Rect cf, Rect vf){
+		if(attrs != null){
+            if(attrs.packageName != null) {
+				Rect desiredRect = win.getFrameLw();
+				//Default is to layout directly in the desired rectangle
+				pf.left = df.left = vf.left = cf.left = desiredRect.left;
+				pf.right = df.right = vf.right = cf.right = desiredRect.right;
+				pf.top = df.top = vf.top = cf.top= desiredRect.top;
+				pf.bottom = df.bottom = desiredRect.bottom;
+
+               /**
+                * Author: Onskreen
+                * Date: 05/04/2011
+                *
+                * If not an obstructed cs window, then behave as it used to.
+                * If SOFT_INPUT_ADJUST_RESIZE flag found, then reset the content and visible frame's bottom
+                * rect. It lays out the window's bottom position so that IME window doesn't hide the
+                * activity window underneath it.
+                */
+
+				//Only manipulate focused windows
+				if(win.isFocused()) {
+                    /**
+                     * Author: Onskreen
+                     * Date: 16/06/2011
+                     *
+                     * Moved the obstructed cs window logic to setObstructedWindowInFrame
+                     * method.
+                     */
+                     setObstructedWindowInFrame(win, attrs, pf, df, cf, vf, desiredRect);
+                } else {
+                    //In case window was shifted somehow and then lost focus, make sure it reshifts
+                    //where it belongs.
+                    /**
+                     * Author: Onskreen
+                     * Date: 16/06/2011
+                     *
+                     * Shift the unfocused window which is in the same window frame as
+                     * already shifted up the obstructed window when IME window is visible.
+                     */
+                    if(mWindowsShifted.size() == 0){
+                        if(mWindowsShifted.contains(win)) {
+                           if (DEBUG_LAYOUT) Log.v(TAG, "\tAction: Shift down " + mWindowShiftAmount + " pixels");
+                           //mWindowsShifted.remove(win);
+                           mWindowsShifted.clear();
+
+                           int modifiedTop = pf.top + mWindowShiftAmount;
+                           pf.top = df.top = cf.top = vf.top = modifiedTop;
+                           vf.bottom = cf.bottom = desiredRect.bottom + modifiedTop;
+                        } else {
+                           //set the bottom normally
+                           vf.bottom = cf.bottom = desiredRect.bottom;
+                        }
+                    /**
+                     * Author: Onskreen
+                     * Date: 06/01/2011
+                     *
+                     * If shifted window loses focus, then it should move to its
+                     * default layout postion and removes the window from mWindowsShifted
+                     * list.
+                     */
+                    } else if (mWindowsShifted.contains(win)) {
+                        if (DEBUG_LAYOUT) Log.v(TAG, "\tAction: Shift down " + mWindowShiftAmount + " pixels");
+                        mWindowsShifted.remove(win);
+                        int modifiedTop = pf.top + mWindowShiftAmount;
+                        pf.top = df.top = cf.top = vf.top = modifiedTop;
+                        vf.bottom = cf.bottom = pf.bottom = df.bottom = desiredRect.bottom + modifiedTop;
+                    } else {
+                        WindowState w = (WindowState) mWindowsShifted.get(0);
+                        if(w != null) {
+                            IBinder token = win.getToken();
+                            boolean isWF = w.isInCornerstonePanelWindowPanel(token);
+                            if(isWF) {
+                               setObstructedWindowInFrame(win, attrs, pf, df, cf, vf, desiredRect);
+                            } else {
+                                //set the bottom normally
+                                vf.bottom = cf.bottom = desiredRect.bottom;
+                            }
+                        } else {
+                           //set the bottom normally
+                           vf.bottom = cf.bottom = desiredRect.bottom;
+                        }
+                    }
+                }
+
+               if (DEBUG_LAYOUT) {
+                  Log.v(TAG, "Final Rects for Window: " + win);
+                  Log.v(TAG, "pf: " + pf);
+                  Log.v(TAG, "df: " + df);
+                  Log.v(TAG, "cf: " + cf);
+                  Log.v(TAG, "vf: " + vf);
+               }
+            }
+		}
+    }
+
+    /**
+     * Author: Onskreen
+     * Date: 05/04/2011
+     *
+     * This is a shortcut to tell if the IME is visible on the screen without referencing the mFrame of the WindowState
+     * as that value may get shifted while being layed out. Previously we were using the interesection of the mFrame with
+     * the mContentBottom.
+     */
+    private boolean isKeyboardVisible() {
+		if(mContentBottom != mRestrictedScreenHeight) {
+			return true;
+		} else {
+			return false;
+		}
+    }
+
+    /**
+     * Author: Onskreen
+     * Date: 16/06/2011
+     *
+     * Utility method for setting the layout rects for obstructed cs window.
+     */
+    private void setObstructedWindowInFrame(WindowState win, WindowManager.LayoutParams attrs, Rect pf, Rect df, Rect cf, Rect vf, Rect desiredRect){
+        /**
+         * Author: Onskreen
+         * Date: 05/04/2011
+         *
+         * Having the SOFT_INPUT_ADJUST_RESIZE flag set indicates that the windowstate should be
+         * manipulated in the presence of the keyboard. For Cornerstone, those panels that are
+         * unduly obstructed by the presence of the keyboard are also manipulated regardless
+         * of the flag.
+         */
+       if(((attrs.softInputMode & SOFT_INPUT_MASK_ADJUST) == SOFT_INPUT_ADJUST_RESIZE) ||
+               win.isObstructedByKeyboard()) {
+           //Indicates the V Keyboard is on the screen, if mContentBottom has been reset
+           //and our desired rect will overlap it
+//           if(desiredRect.bottom > mContentBottom) {
+			if(isKeyboardVisible()) {
+               //If the entire rect is off the screen, it indicates it is not actually visible. This can
+               //be the case for a cornerstone panel when the cornerstone is RUNNING_CLOSED.
+               if(desiredRect.top > mUnrestrictedScreenHeight ||                   //Orientation: Portrait, CS State: Closed
+                       desiredRect.left > mUnrestrictedScreenWidth)   {           //Orientation: Landscape, CS State: Closed
+                   if (DEBUG_LAYOUT) Log.v(TAG, "\tAction: Ignore, win is not visible anyway");
+                   cf.bottom = desiredRect.bottom;
+                   vf.bottom = desiredRect.bottom;
+               } else if(win.isObstructedByKeyboard()) {
+                   //Try to shift the window up on the screen to be fully visible
+
+                   //Window already shifted
+                   if(mWindowsShifted.contains(win)) {
+                       if (DEBUG_LAYOUT) Log.v(TAG, "\tAction: Win already shifted");
+                       /**
+                        * This is a sanity check. We have seen cases where the Window is determined to be resized (or is new) triggering
+                        * a relayout of it from the WMS. In that case it is positioned in the unaltered frame and the Policy needs
+                        * to make sure it is positioned appropriately based on obstruction.
+                        */
+                       if(pf.bottom!=mContentBottom) {
+                           int modifiedTop = desiredRect.top - mWindowShiftAmount;
+                           /**
+                            * Author: Onskreen
+                            * Date: 23/01/2013
+                            *
+                            * The modifiedTop position shouldn't be negative or shouldn't be
+                            * less than the desired layout rect's top position. If we don't
+                            * check for these conditions then Window size goes out of screen
+                            * area in landscape mode and Window size of app goes out of layout
+                            * rect in portrait mode.
+                            */
+                           if(modifiedTop < 0) { // In landscape mode
+								modifiedTop = desiredRect.top;
+                           } else if(modifiedTop < desiredRect.top) { // In portrait mode
+								modifiedTop = desiredRect.top;
+                           }
+
+                           pf.top = df.top = cf.top = vf.top = modifiedTop;
+                           pf.bottom = df.bottom = mContentBottom;
+                           cf.bottom = mContentBottom;
+                           vf.bottom = mCurBottom;
+                       }
+                   } else {
+                       mWindowShiftAmount = desiredRect.bottom - mContentBottom;
+                       if (DEBUG_LAYOUT) Log.v(TAG, "\tAction: Shift up " + mWindowShiftAmount + " pixels");
+                       /*
+                        * Author: Onskreen
+                        * Date: 12/12/2012
+                        *
+                        * Sometimes Framework wrongly calculates the virtual keyboard
+                        * rect in WindowState.computeFrameLw() and mContentBottom,
+                        * mCurBottom variables initialized with wrong values in
+                        * offsetInputMethodWindowLw method. The height of virtual keyboard
+                        * in landscape orientation is apprx. 342 pixels and in portrait mode it is
+                        * apprx. 288 pixels. If mWindowShiftAmount variable has any value lesser
+                        * than 280 pixels considered as incorrect rect of virtual keyboard window
+                        * and CS Panel app shouldn't be shifted to incorrect position on
+                        * screen in either orientations.
+                        */
+                       if(mWindowShiftAmount < 280) {
+							pf.top = df.top = cf.top = vf.top = desiredRect.top;
+							vf.bottom = cf.bottom = desiredRect.bottom;
+							pf.bottom = df.bottom = desiredRect.bottom;
+                       } else {
+                           mWindowsShifted.add(win);
+                           int modifiedTop = desiredRect.top - mWindowShiftAmount;
+                           pf.top = df.top = cf.top = vf.top = modifiedTop;
+                           pf.bottom = df.bottom = mContentBottom;
+                           cf.bottom = mContentBottom;
+                           vf.bottom = mCurBottom;
+                       }
+                   }
+               } else {
+                   //Squeeze the window in the visible area above the keyboard
+                   if (DEBUG_LAYOUT) Log.v(TAG, "\tAction: Squeeze into visible rect above keyboard");
+                   cf.bottom = mContentBottom;
+                   vf.bottom = mCurBottom;
+               }
+           } else {
+               //Layout as regular
+               if (DEBUG_LAYOUT) Log.v(TAG, "IME: Not Visible\tTask: Unshift Win: " + win);
+               if(mWindowsShifted.contains(win)) {
+                  if (DEBUG_LAYOUT) Log.v(TAG, "\tAction: Shift down " + mWindowShiftAmount + " pixels");
+                  mWindowsShifted.clear();
+
+                  pf.top = df.top = cf.top = vf.top = desiredRect.top + mWindowShiftAmount;
+                  vf.bottom = cf.bottom = desiredRect.bottom+ mWindowShiftAmount;
+                  pf.bottom = df.bottom = desiredRect.bottom+ mWindowShiftAmount;
+
+               } else {
+                   if (DEBUG_LAYOUT) Log.v(TAG, "\tAction: Ignore, not currently shifted");
+                   vf.bottom = cf.bottom = desiredRect.bottom;
+                   pf.bottom = df.bottom = desiredRect.bottom;
+               }
+           }
+       }
+    }
+
     /** {@inheritDoc} */
     @Override
     public void finishLayoutLw() {
@@ -2980,6 +3268,15 @@ public class PhoneWindowManager implements WindowManagerPolicy {
                 }
                 topIsFullscreen = (lp.flags & WindowManager.LayoutParams.FLAG_FULLSCREEN) != 0
                         || (mLastSystemUiFlags & View.SYSTEM_UI_FLAG_FULLSCREEN) != 0;
+                /**
+                 * Author: Onskreen
+                 * Date: 24/02/2011
+                 *
+                 * Never hide the status bar to ensure that app always renders within
+                 * the CS panel.
+                 */
+                topIsFullscreen = false;
+
                 // The subtle difference between the window for mTopFullscreenOpaqueWindowState
                 // and mTopIsFullscreen is that that mTopIsFullscreen is set only if the window
                 // has the FLAG_FULLSCREEN set.  Not sure if there is another way that to be the
diff --git a/frameworks/base/services/input/InputDispatcher.cpp b/frameworks/base/services/input/InputDispatcher.cpp
index e63da05..5f80c74 100755
--- a/frameworks/base/services/input/InputDispatcher.cpp
+++ b/frameworks/base/services/input/InputDispatcher.cpp
@@ -43,6 +43,9 @@
 // Log debug messages about hover events.
 #define DEBUG_HOVER 0
 
+// Log debug messages about the user input processing.
+#define DEBUG_USER_INPUT 0
+
 #include "InputDispatcher.h"
 
 #include <utils/Trace.h>
@@ -401,9 +404,9 @@ bool InputDispatcher::enqueueInboundEventLocked(EventEntry* entry) {
                 mAppSwitchSawKeyDown = true;
             } else if (keyEntry->action == AKEY_EVENT_ACTION_UP) {
                 if (mAppSwitchSawKeyDown) {
-#if DEBUG_APP_SWITCH
-                    ALOGD("App switch is pending!");
-#endif
+					#if DEBUG_APP_SWITCH
+                       ALOGD("App switch is pending!");
+					#endif
                     mAppSwitchDueTime = keyEntry->eventTime + APP_SWITCH_TIMEOUT;
                     mAppSwitchSawKeyDown = false;
                     needWake = true;
@@ -1080,6 +1083,38 @@ Unresponsive:
     return injectionResult;
 }
 
+/**
+ * Author: Onskreen
+ * Date: 25/05/2011
+ *
+ * Determines if the passed window is a dialog
+ */
+bool InputDispatcher::isDialog(const InputWindowInfo* window){
+	int32_t type = window->layoutParamsType;
+	int32_t flags = window->layoutParamsFlags;
+    /**
+     * Author: Onskreen
+     * Date: 20/12/2011
+     *
+     * TYPE_CHANGED is no longer a defined Window type
+     */
+	if((type == InputWindowInfo::TYPE_APPLICATION_ATTACHED_DIALOG) ||
+		(type == InputWindowInfo::TYPE_KEYGUARD_DIALOG) ||
+		(type == InputWindowInfo::TYPE_TOAST) ||
+		(type == InputWindowInfo::TYPE_SYSTEM_ERROR) ||
+		(type == InputWindowInfo::TYPE_SYSTEM_ALERT) ||
+		/*(type == InputWindowInfo::TYPE_SEARCH_BAR) ||
+		(type == InputWindowInfo::TYPE_STATUS_BAR) || */
+		(type == InputWindowInfo::TYPE_SYSTEM_DIALOG) ||
+		/*(type == InputWindowInfo::TYPE_CHANGED) || */
+		(((flags == (InputWindowInfo::FLAG_ALT_FOCUSABLE_IM
+                            | InputWindowInfo::FLAG_DIM_BEHIND)))
+		&& (type == InputWindowInfo::TYPE_BASE_APPLICATION))){
+		return true;
+	}
+	return false;
+}
+
 int32_t InputDispatcher::findTouchedWindowTargetsLocked(nsecs_t currentTime,
         const MotionEntry* entry, Vector<InputTarget>& inputTargets, nsecs_t* nextWakeupTime,
         bool* outConflictingPointerActions) {
@@ -1168,6 +1203,8 @@ int32_t InputDispatcher::findTouchedWindowTargetsLocked(nsecs_t currentTime,
         sp<InputWindowHandle> newTouchedWindowHandle;
         sp<InputWindowHandle> topErrorWindowHandle;
         bool isTouchModal = false;
+	String8 subStr;
+	bool isNonApp = false;
 
         // Traverse windows from front to back to find touched window and outside targets.
         size_t numWindows = mWindowHandles.size();
@@ -1176,6 +1213,9 @@ int32_t InputDispatcher::findTouchedWindowTargetsLocked(nsecs_t currentTime,
             const InputWindowInfo* windowInfo = windowHandle->getInfo();
             int32_t flags = windowInfo->layoutParamsFlags;
 
+		#if DEBUG_USER_INPUT
+			ALOGD("window is: %s", windowInfo->name.string());
+		#endif
             if (flags & InputWindowInfo::FLAG_SYSTEM_ERROR) {
                 if (topErrorWindowHandle == NULL) {
                     topErrorWindowHandle = windowHandle;
@@ -1186,7 +1226,38 @@ int32_t InputDispatcher::findTouchedWindowTargetsLocked(nsecs_t currentTime,
                 if (! (flags & InputWindowInfo::FLAG_NOT_TOUCHABLE)) {
                     isTouchModal = (flags & (InputWindowInfo::FLAG_NOT_FOCUSABLE
                             | InputWindowInfo::FLAG_NOT_TOUCH_MODAL)) == 0;
-                    if (isTouchModal || windowInfo->touchableRegionContainsPoint(x, y)) {
+			#if DEBUG_USER_INPUT
+			ALOGD("Window->x : %d", x);
+			ALOGD("Window->y : %d", y);
+			ALOGD("Window.frameLeft-> %d", windowInfo->frameLeft);
+			ALOGD("Window.frameTop-> %d", windowInfo->frameTop);
+			ALOGD("Window.frameRight-> %d", windowInfo->frameRight);
+			ALOGD("Window.frameBottom-> %d", windowInfo->frameBottom);
+			ALOGD("Window->isTouchModal %d", isTouchModal);
+			ALOGD("window->touchableAreaContainsPoint(x, y) %d", windowInfo->touchableRegionContainsPoint(x, y));
+			#endif
+
+			subStr = getNonAppSubStr(windowInfo->name.string());
+			#if DEBUG_USER_INPUT
+			ALOGD("Non app sub string is: %s", subStr.string());
+			#endif
+
+			if(subStr == "StatusBar" || subStr == "StatusBarExpanded" || subStr == "InputMethod" /*|| subStr == "SystemBar"*/){
+				isNonApp = true;
+			}
+            /**
+             * Author: Onskreen
+             * Date: 29/02/2012
+             *
+             * Determines the interesting target window where user has initiated
+             * the pointer event. The target window may or may not be the modal
+             * type or non app window, but if user has initiated the user input
+             * and that is in its touchable region, then input should be passed
+             * to it.
+             */
+             bool isTouched = windowInfo->touchableRegionContainsPoint(x, y);
+             if ((isTouchModal && isTouched) || (!isNonApp && isTouched) || (isNonApp && isTouched)) {
+                    //if (isTouchModal || windowInfo->touchableRegionContainsPoint(x, y)) {
                         if (! screenWasOff
                                 || (flags & InputWindowInfo::FLAG_TOUCHABLE_WHEN_WAKING)) {
                             newTouchedWindowHandle = windowHandle;
@@ -2860,6 +2931,66 @@ void InputDispatcher::setFocusedApplication(
     mLooper->wake();
 }
 
+/**
+ * Author: Onskreen
+ * Date: 17/02/2011
+ *
+ * Finds the focused application/activity and sets the found Application
+ * to the top element of mApplications array ensuring mApplications array
+ * is always up to date.
+ */
+/*const InputApplication* InputDispatcher::findFocusedApp(const char* src) {
+    const InputApplication* app = NULL;
+    const char* str = NULL;
+    size_t len = mApplications.size();
+    for(size_t j = 0; j < len; j++){
+		app = & mApplications.editItemAt(j);
+		str = app->name.string();
+		str = strstr(str, src);
+		if(str != NULL){
+			//found, assign the new focused application
+			mApplications.add(*app);
+			size_t index = mApplications.removeAt(j);
+			app = & mApplications.editItemAt(len - 1);
+			break;
+		} else {
+			app = NULL;
+		}
+    }
+    return app;
+}*/
+
+/**
+ * Author: Onskreen
+ * Date: 17/02/2011
+ *
+ * Utility function returning the sub string from InputWindow.name string.
+ */
+String8 InputDispatcher::getSubStr(const char* src) {
+    String8 subStr;
+    char* str1;
+    str1 = strchr(src, ' ');
+    str1 = strtok(str1, "/");
+    subStr.append(str1);
+    return subStr;
+}
+
+/**
+ * Author: Onskreen
+ * Date: 18/02/2011
+ *
+ * Utility function returning the sub string from non-app (dialogs, virtual keyboard, statusbar etc.)
+ * InputWindow.name string.
+ */
+String8 InputDispatcher::getNonAppSubStr(const char* src) {
+    String8 subStr;
+    char* str1;
+    str1 = strchr(src, ' ');
+    str1 = strtok(str1, " ");
+    subStr.append(str1);
+    return subStr;
+}
+
 void InputDispatcher::setInputDispatchMode(bool enabled, bool frozen) {
 #if DEBUG_FOCUS
     ALOGD("setInputDispatchMode: enabled=%d, frozen=%d", enabled, frozen);
@@ -4353,4 +4484,4 @@ bool InputDispatcherThread::threadLoop() {
     return true;
 }
 
-} // namespace android
+} // namespace android
\ No newline at end of file
diff --git a/frameworks/base/services/input/InputDispatcher.h b/frameworks/base/services/input/InputDispatcher.h
index d0824fc..2356a76 100644
--- a/frameworks/base/services/input/InputDispatcher.h
+++ b/frameworks/base/services/input/InputDispatcher.h
@@ -395,6 +395,14 @@ public:
     virtual status_t unregisterInputChannel(const sp<InputChannel>& inputChannel);
 
 private:
+    /**
+     * Author: Onskreen
+     * Date: 25/05/2011
+     *
+     * Cornerstone Utility Methods
+     */
+    String8 getSubStr(const char* src);
+    String8 getNonAppSubStr(const char* src);
     template <typename T>
     struct Link {
         T* next;
@@ -994,6 +1002,14 @@ private:
     nsecs_t getTimeSpentWaitingForApplicationLocked(nsecs_t currentTime);
     void resetANRTimeoutsLocked();
 
+    /**
+     * Author: Onskreen
+     * Date: 25/05/2011
+     *
+     * To determine if the window is of type dialog.
+     */
+    bool isDialog(const InputWindowInfo* window);
+
     int32_t findFocusedWindowTargetsLocked(nsecs_t currentTime, const EventEntry* entry,
             Vector<InputTarget>& inputTargets, nsecs_t* nextWakeupTime);
     int32_t findTouchedWindowTargetsLocked(nsecs_t currentTime, const MotionEntry* entry,
@@ -1103,4 +1119,4 @@ private:
 
 } // namespace android
 
-#endif // _UI_INPUT_DISPATCHER_H
+#endif // _UI_INPUT_DISPATCHER_H
\ No newline at end of file
diff --git a/frameworks/base/services/java/com/android/server/am/ActivityManagerService.java b/frameworks/base/services/java/com/android/server/am/ActivityManagerService.java
index 95d3c41..53d93de 100755
--- a/frameworks/base/services/java/com/android/server/am/ActivityManagerService.java
+++ b/frameworks/base/services/java/com/android/server/am/ActivityManagerService.java
@@ -42,6 +42,7 @@ import android.app.ApplicationErrorReport;
 import android.app.Dialog;
 import android.app.IActivityController;
 import android.app.IApplicationThread;
+import android.app.ICornerstoneManager;
 import android.app.IInstrumentationWatcher;
 import android.app.INotificationManager;
 import android.app.IProcessObserver;
@@ -84,6 +85,8 @@ import android.content.pm.ServiceInfo;
 import android.content.pm.UserInfo;
 import android.content.res.CompatibilityInfo;
 import android.content.res.Configuration;
+import android.content.res.Resources;
+import android.content.res.XmlResourceParser;
 import android.graphics.Bitmap;
 import android.net.Proxy;
 import android.net.ProxyProperties;
@@ -157,6 +160,9 @@ import java.util.Set;
 import java.util.concurrent.atomic.AtomicBoolean;
 import java.util.concurrent.atomic.AtomicLong;
 
+import org.xmlpull.v1.XmlPullParser;
+import org.xmlpull.v1.XmlPullParserException;
+
 public final class ActivityManagerService extends ActivityManagerNative
         implements Watchdog.Monitor, BatteryStatsImpl.BatteryCallback {
     private static final String USER_DATA_DIR = "/data/user/";
@@ -164,6 +170,7 @@ public final class ActivityManagerService extends ActivityManagerNative
     static final String TAG_MU = "ActivityManagerServiceMU";
     static final boolean DEBUG = false;
     static final boolean localLOGV = DEBUG;
+    static final boolean DEBUG_CORNERSTONE = localLOGV || false;
     static final boolean DEBUG_SWITCH = localLOGV || false;
     static final boolean DEBUG_TASKS = localLOGV || false;
     static final boolean DEBUG_PAUSE = localLOGV || false;
@@ -286,6 +293,66 @@ public final class ActivityManagerService extends ActivityManagerNative
     private boolean mShowDialogs = true;
 
     /**
+     * Author: Onskreen
+     * Date: 12/01/2011
+     *
+     * Stack containing the cornerstone app itself
+     */
+    public ActivityStack mCornerstoneStack;
+    //TODO Hardcoding package name to recognized cornerstone app. should be upgraded so can be recognized with any package.
+    String mCornerstoneAppPackageName;
+    String mCornerstoneLauncherAppPackageName;
+    String mCornerstoneLauncherClassName;
+
+    /**
+     * Author: Onskreen
+     * Date: 10/02/2011
+     *
+     * Stacks containing the cornerstone panels
+     */
+    public ArrayList<ActivityStack> mCornerstonePanelStacks = new ArrayList<ActivityStack>();
+    /**
+     * Author: Onskreen
+     * Date: 10/02/2011
+     *
+     * Maximum number of allowed panels in the cornerstone. It's not clear whether this should
+     * be hardcoded here or variable and come from the cornerstone app?
+     */
+    int mMaxNumCornerstonePanels = 2;
+
+    /**
+     * Author: Onskreen
+     * Date: 10/02/2011
+     *
+     * Simplistic method of knowing which cs panel stack to put new apps. Will have to be retrieved
+     * from WMS based on api.
+     */
+    int mCornerstonePanelsCreated = 0;
+
+    /**
+     * Author: Onskreen
+     * Date: 10/02/2011
+     *
+     * Constants used in searching for tasks in various stacks. Positive numbers
+     * will indicate the index of the panel the task resides in.
+     *
+     */
+    static final int NO_STACK = -1;
+    static final int MAIN_STACK = -2;
+    static final int CORNERSTONE_STACK = -3;
+
+    public enum Cornerstone_Transitions{
+        OPENING,				//Running and opening
+        CLOSING,				//Running and closing
+        SWAPPING_0,				//Swapping CS Panel App 0 with Main Panel
+        SWAPPING_1,				//Swapping CS Panel App 1 with Main Panel
+        LAUNCHING,				//Launching CS
+        TERMINATING,			//Exiting CS
+        NONE					//Nothing
+    }
+    public Cornerstone_Transitions mCornerstoneTransition = Cornerstone_Transitions.NONE;
+
+    /**
      * Description of a request to start a new activity, which has been held
      * due to app switches being disabled.
      */
@@ -765,6 +832,22 @@ public final class ActivityManagerService extends ActivityManagerNative
     boolean mAutoStopProfiler = false;
     String mOpenGlTraceApp = null;
 
+   /**
+    * Author: Onskreen
+    * Date: 28/02/2011
+    *
+    * ICornerstoneManager object
+    */
+    ICornerstoneManager mCornerstoneManager = null;
+
+   /**
+    * Author: Onskreen
+    * Date: 16/07/2011
+    *
+    * Activity stack kill setting Flag
+    */
+    boolean mActivityStackExiting;
+
     static class ProcessChangeItem {
         static final int CHANGE_ACTIVITIES = 1<<0;
         static final int CHANGE_IMPORTANCE= 1<<1;
@@ -875,6 +958,15 @@ public final class ActivityManagerService extends ActivityManagerNative
     static final int DISPATCH_PROCESSES_CHANGED = 31;
     static final int DISPATCH_PROCESS_DIED = 32;
     static final int REPORT_MEM_USAGE = 33;
+    /**
+     * Author: Onskreen
+     * Date: 10/06/2011
+     *
+     * Constant to show the alert dialog when user tries to launch
+     * the multiple instances of same app (for ex, Gallery) to avoid
+     * any unwanted crashes.
+     */
+    static final int SHOW_APP_ERROR_MSG = 34;
 
     static final int FIRST_ACTIVITY_STACK_MSG = 100;
     static final int FIRST_BROADCAST_QUEUE_MSG = 200;
@@ -1302,6 +1394,25 @@ public final class ActivityManagerService extends ActivityManagerNative
                 thread.start();
                 break;
             }
+            /**
+             * Author: Onskreen
+             * Date: 10/06/2011
+             *
+             * Show the alert dialog when user tries to launch the multiple
+             * instances of similar app.
+             */
+            case SHOW_APP_ERROR_MSG: {
+                AlertDialog d = new BaseErrorDialog(mContext);
+                d.getWindow().setType(WindowManager.LayoutParams.TYPE_SYSTEM_ERROR);
+                d.setCancelable(false);
+                d.setTitle(msg.getData().getCharSequence("title"));
+                d.setMessage(msg.getData().getCharSequence("body"));
+                d.setButton(DialogInterface.BUTTON_POSITIVE, "OK",
+                    mHandler.obtainMessage(IM_FEELING_LUCKY_MSG));
+                mUidAlert = d;
+                d.show();
+				break;
+            }
             }
         }
     };
@@ -1368,25 +1479,97 @@ public final class ActivityManagerService extends ActivityManagerNative
         context.setTheme(android.R.style.Theme_Holo);
         m.mContext = context;
         m.mFactoryTest = factoryTest;
-        m.mMainStack = new ActivityStack(m, context, true);
-        
+        /**
+         * Author: Onskreen
+         * Date: 19/02/2011
+         *
+         * Instantiate the stacks with cornerstone flags
+         */
+        //m.mMainStack = new ActivityStack(m, context, true);
+        m.mMainStack = new ActivityStack(m, context, true, false, -1);
+
+        /**
+         * Author: Onskreen
+         * Date: 12/01/2011
+         *
+         * Instantiate the stacks for cornerstone
+         */
+        m.mCornerstoneStack = new ActivityStack(m, context, false, false, -1);
+        for(int i=0; i<m.mMaxNumCornerstonePanels; i++) {
+			ActivityStack panelStack = new ActivityStack(m, context, false, true, i);
+			m.mCornerstonePanelStacks.add(panelStack);
+        }
+
+        /**
+         * Author: Onskreen
+         * Date: 20/07/2011
+         *
+         * populate the mCornerstoneAppPackageName, mCornerstoneLauncherAppPackageName and
+         * mCornerstoneLauncherClassName from the cornerstone.xml
+         */
+        XmlResourceParser xpp = null;
+        try {
+            Resources res = context.getResources();
+            xpp = res.getXml(com.android.internal.R.xml.cornerstone);
+            xpp.next();
+            int eventType = xpp.getEventType();
+            String tag;
+            while (eventType != XmlPullParser.END_DOCUMENT) {
+                if(eventType == XmlPullParser.START_DOCUMENT) {
+
+                } else if(eventType == XmlPullParser.START_TAG) {
+                     tag = xpp.getName();
+                     if(tag.equals("pkg")){
+                          xpp.next();
+                          m.mCornerstoneAppPackageName = xpp.getText();
+                     } else if(tag.equals("launcher")) {
+                         xpp.next();
+                         tag = xpp.getName();
+                         if(tag.equals("pkg")){
+                            xpp.next();
+                            m.mCornerstoneLauncherAppPackageName = xpp.getText();
+                            xpp.next();
+                         }
+                         xpp.next();
+                         tag = xpp.getName();
+                         if(tag.equals("class")){
+                            xpp.next();
+                            m.mCornerstoneLauncherClassName = xpp.getText();
+                            xpp.next();
+                         }
+                         break;
+                     }
+                }
+                eventType = xpp.next();
+            }
+            xpp.close();
+         } catch (XmlPullParserException e) {
+              // TODO Auto-generated catch block
+              e.printStackTrace();
+              xpp.close();
+         } catch (IOException e) {
+             // TODO Auto-generated catch block
+             e.printStackTrace();
+             xpp.close();
+         }
+
         m.mBatteryStatsService.publish(context);
         m.mUsageStatsService.publish(context);
-        
+
         synchronized (thr) {
             thr.mReady = true;
             thr.notifyAll();
         }
 
         m.startRunning(null, null, null, null);
-        
+
         return context;
     }
 
     public static ActivityManagerService self() {
         return mSelf;
     }
-    
+
     static class AThread extends Thread {
         ActivityManagerService mService;
         boolean mReady = false;
@@ -2340,12 +2523,294 @@ public final class ActivityManagerService extends ActivityManagerNative
         }
         for (int i=0; i<N; i++) {
             PendingActivityLaunch pal = mPendingActivityLaunches.get(i);
-            mMainStack.startActivityUncheckedLocked(pal.r, pal.sourceRecord,
+            /**
+             * Author: Onskreen
+             * Date: 27/01/2011
+             *
+             * Push message to appropriate stack.
+             */
+            int stack = getActivityStack(pal.r);
+            ActivityStack targetStack = null;
+            //Cornerstone Panel
+            if(stack >= 0) {
+				if(stack < mCornerstonePanelStacks.size()) {
+					targetStack = mCornerstonePanelStacks.get(stack);
+				} else {
+					Log.e(TAG, "Found in Non-Existent Stack");
+					return;
+				}
+            } else if(stack == CORNERSTONE_STACK) {
+				//Cornerstone
+				targetStack = mCornerstoneStack;
+            } else if(stack == MAIN_STACK || stack == NO_STACK) {
+				//Main stack or Unknown
+                targetStack = mMainStack;
+            }
+            targetStack.startActivityUncheckedLocked(pal.r, pal.sourceRecord,
                     pal.startFlags, doResume && i == (N-1), null);
         }
         mPendingActivityLaunches.clear();
     }
 
+    /**
+     * Author : Onskreen
+     * Date: 23/02/2012
+     *
+     * Determines if the requested Activity is HOME app and returns
+     * boolean value. HOME app shouldn't be allowed to run in
+     * Cornerstone Panels. They are allowed only in main panel.
+     */
+    private boolean checkActivityIsHomeApp(ActivityInfo appInfo) {
+		boolean isHomeActivity = false;
+		PackageManager pm = mContext.getPackageManager();
+		if(DEBUG_CORNERSTONE||DEBUG_PROCESSES) Slog.v(TAG, "appInfo.packageName: " + appInfo.packageName);
+
+		final Intent intent = new Intent(Intent.ACTION_MAIN);
+		intent.addCategory(Intent.CATEGORY_HOME);
+		List<ResolveInfo> list = pm.queryIntentActivities(intent, PackageManager.MATCH_DEFAULT_ONLY);
+		for(int i = 0; i < list.size(); i++) {
+			ResolveInfo info = (ResolveInfo)list.get(i);
+			String pkg = info.activityInfo.packageName;
+			if(DEBUG_CORNERSTONE||DEBUG_PROCESSES) Slog.v(TAG, "i: " + i + " Home App->" + pkg);
+			if(appInfo.packageName.equals(pkg)) {
+				isHomeActivity = true;
+				return isHomeActivity;
+			}
+		}
+		return isHomeActivity;
+    }
+
+    /**
+     * Author: Onskreen
+     * Date: 07/01/2012
+     *
+     * Determine if the activity is permitted to start. An activity is permitted to launch if:
+     * - No other instance of it is currently in the resumed state in a different panel
+     * other than the one it wants to launch in
+     * - No instance of it will be active causing a conflict - If opening in the Main Panel, another instance cannot
+     * be in the closed Cornerstone about to become Resumed once the user opens it
+     * - If opening in the Cornerstone, the app must declare that it supports any orientation
+     *
+     *
+     */
+    public boolean isActivityPermittedToStart(ActivityInfo appInfo, ActivityStack stack) {
+		//TODO These strings do not belong hardcoded here
+		String titleMsg = "Sorry!";
+		String activityConflictMsg = "In this version of Cornerstone, only one instance of this application can be active at any time. This capability will be refined to allow multiple instances of Applications that don't share resources, and launch those that do into separate processes.";
+		String orientationsNotSupportedMsg = "This application does not support all the possible configurations, so cannot be opened in the Cornerstone";
+		String homeActivityMsg = "This application is a Launcher application, so cannot be opened in the Cornerstone";
+
+		if(DEBUG_CORNERSTONE||DEBUG_PROCESSES) Slog.v(TAG, "Cornerstone permitting to start: " + appInfo + " in: " + stack.mStackName);
+		//No check for Cornerstone Stack
+		if(stack == mCornerstoneStack) {
+			if(DEBUG_CORNERSTONE||DEBUG_PROCESSES) Slog.v(TAG, "\tResult: Permitted\tReason: No check for cornerstone.");
+			return true;
+		}
+
+		//Apps launched in Cornerstone Panels must support portrait or landscape
+		// orientations since the device may be rotated due to the user or main
+		// main panel app.
+		if(mCornerstonePanelStacks.contains(stack)) {
+			if(!checkActivitySupportsRequiredOrientations(appInfo)) {
+				if(DEBUG_CORNERSTONE||DEBUG_PROCESSES) Slog.v(TAG, "\tResult: Banned\tReason: In Cornerstone and doesn't support all orientations");
+				Message msg = Message.obtain();
+                msg.what = SHOW_APP_ERROR_MSG;
+                msg.getData().putCharSequence("title", titleMsg);
+                msg.getData().putCharSequence("body", orientationsNotSupportedMsg);
+                mHandler.sendMessage(msg);
+                return false;
+            /**
+             * Author: Onskreen
+             * Date: 23/02/2012
+             *
+             * Check if activity is allowed to run in Cornerstone
+             * panels. HOME apps are not allowed to run in Cornerstone.
+             */
+			} else if(checkActivityIsHomeApp(appInfo)) {
+				if(DEBUG_CORNERSTONE||DEBUG_PROCESSES) Slog.v(TAG, "\tResult: Banned\tReason: Launcher app can't be opened in Cornerstone");
+				Message msg = Message.obtain();
+				msg.what = SHOW_APP_ERROR_MSG;
+				msg.getData().putCharSequence("title", titleMsg);
+				msg.getData().putCharSequence("body", homeActivityMsg);
+				mHandler.sendMessage(msg);
+				return false;
+			}
+
+		}
+
+        /**
+         * Is the package running in a process anywhere. If not, safe to start.
+         */
+		ProcessRecord proc = getProcessRecordLocked(appInfo.processName, appInfo.applicationInfo.uid);
+		if(proc == null) {
+			if(DEBUG_CORNERSTONE||DEBUG_PROCESSES) Slog.v(TAG, "\tResult: Permitted\tReason: Not found elsewhere");
+			return true;
+		}
+
+		List<ActivityRecord> records = new ArrayList<ActivityRecord>();
+
+        /**
+         * Find Activities of the same process in stacks other than the one we are trying to launch in. If found, do a
+         * check on them to see if they will cause a conflict.
+         *
+         * records - the list of Activities that we found that do cause a conflict. If we want to act upon them all
+         * in the future (move them, reconfig them, kill them, etc...) we can do it with this list.
+         */
+		boolean retValue = true;
+		//Main Stack
+		// Don't search in the stack we are currently in to avoid cases where the Activity is in our stack somewhere, but also
+		// on top of another stack.
+		if(stack != mMainStack) {
+			for(ActivityRecord ar: mMainStack.mHistory) {
+				if(ar.app == proc) {
+					if(!checkActivityCausesConflict(ar, mMainStack)) {
+						retValue = false;
+						break;
+					} else {
+						records.add(ar);
+					}
+				}
+			}
+		}
+		//CornerstonePanelStacks
+		if(retValue) {
+			for(ActivityStack as: mCornerstonePanelStacks) {
+				if(stack != as && retValue) {
+					for(ActivityRecord ar: as.mHistory) {
+						if(ar.app == proc) {
+							if(!checkActivityCausesConflict(ar, as)) {
+								retValue = false;
+								break;
+							} else {
+								records.add(ar);
+							}
+						}
+					}
+				}
+			}
+		}
+
+		//Display error if not permitted to proceed
+		if(!retValue) {
+			Message msg = Message.obtain();
+            msg.what = SHOW_APP_ERROR_MSG;
+            msg.getData().putCharSequence("title", titleMsg);
+            msg.getData().putCharSequence("body", activityConflictMsg);
+            mHandler.sendMessage(msg);
+		} else {
+			for(ActivityRecord r: records) {
+				//TODO Ideally we would remove the activity that is in the other stack but not resumed so that the user
+				// can't navigate back to it. As is, the user can and that can create a conflict where the same
+				// process has actvities in multiple panels concurrently. This happens when an activity starts an activity
+				// from a different process, then opens an activity of the original process in another panel. Then in the
+				// original panel presses back.
+				//mMainStack.destroyActivityLocked(r, true, false, "Cornerstone-Open Different Panel");
+				//this.killApplicationProcess(r.app.processName, proc.info.uid);
+			}
+		}
+		return retValue;
+    }
+
+    /**
+     * Author: Onskreen
+     * Date: 07/01/2012
+     *
+     * Test if the specified Activity (ar) in the specified stack (as) will cause a launch conflict.
+     * true - Ok to launch Activity
+     * false - This Activity should restrict another of the same package from being opened
+     *
+     */
+    private boolean checkActivityCausesConflict(ActivityRecord ar, ActivityStack as) {
+		if(ar.state != ActivityState.RESUMED) {			//Not running
+			if(as == mMainStack) {			//Main Stack
+                /**
+                 * Author: Onskreen
+                 * Date: 24/01/2013
+                 *
+                 * If requested ActivityRecord's state is not running but
+                 * top ActivityRecord of requested ActivityStack belongs to
+                 * same task as requested ActivityRecord, then we shouldn't
+                 * allow multiple instances of same app opening in main stack
+                 * or panel.
+                 */
+				ActivityRecord arTop = as.topRunningActivityLocked(null);
+				if(arTop.task == ar.task) {
+					if(DEBUG_CORNERSTONE||DEBUG_PROCESSES) Slog.v(TAG, "\tResult: Banned\tReason: CS Opened, In main panel stack, at top");
+					return false;
+				} else {
+					if(DEBUG_CORNERSTONE||DEBUG_PROCESSES) Slog.v(TAG, "\tResult: Permitted\tReason: In main stack, but not running");
+					return true;
+				}
+			} else if(mCornerstonePanelStacks.contains(as)) {		//CS Panel Stack
+				//If the CS Panel is minimized, the Activity can be in the paused state but
+				// will immediately be resumed when the user opens the CS. So don't allow the
+				// user to open this app.
+				if(mWindowManager.mCornerstoneState == WindowManagerService.Cornerstone_State.RUNNING_CLOSED) {				//RUNNING_CLOSED
+					ActivityRecord arTop = as.topRunningActivityLocked(null);
+					if(arTop !=  ar) {
+						if(DEBUG_CORNERSTONE||DEBUG_PROCESSES) Slog.v(TAG, "\tResult: Permitted\tReason: CS Closed, In cs panel stack, but not at top");
+						return true;
+					} else {
+						if(DEBUG_CORNERSTONE||DEBUG_PROCESSES) Slog.v(TAG, "\tResult: Banned\tReason: CS Closed, In cs panel stack, at top");
+						return false;
+					}
+                /**
+                 * Author: Onskreen
+                 * Date: 24/01/2013
+                 *
+                 * If requested ActivityRecord's state is not running but
+                 * top ActivityRecord of requested ActivityStack belongs to
+                 * same task as requested ActivityRecord, then we shouldn't
+                 * allow multiple instances of same app opening in Cornerstone
+                 * stacks or panels.
+                 */
+				} else if(mWindowManager.mCornerstoneState == WindowManagerService.Cornerstone_State.RUNNING_OPEN) {
+					ActivityRecord arTop = as.topRunningActivityLocked(null);
+					if(arTop.task == ar.task) {
+						if(DEBUG_CORNERSTONE||DEBUG_PROCESSES) Slog.v(TAG, "\tResult: Banned\tReason: CS Opened, In cs panel stack, at top");
+						return false;
+					} else {
+						if(DEBUG_CORNERSTONE||DEBUG_PROCESSES) Slog.v(TAG, "\tResult: Permitted\tReason: CS Opened, In cs panel stack, but not at top");
+						return true;
+					}
+				} else {																									//Any Other CS State
+					if(DEBUG_CORNERSTONE||DEBUG_PROCESSES) Slog.v(TAG, "\tResult: Permitted\tReason: In cs panel stack, but not running");
+					return true;
+				}
+			} else {
+				if(DEBUG_CORNERSTONE||DEBUG_PROCESSES) Slog.v(TAG, "\tResult: Permitted\tReason: Should never get here, didn't find the stack to evaluate");
+				return true;
+			}
+		} else {										//Running. Fail
+			if(DEBUG_CORNERSTONE||DEBUG_PROCESSES) Slog.v(TAG, "\tResult: Banned\tReason: Running elsewhere and in RESUMED state");
+			return false;
+		}
+    }
+
+    /**
+     * Author: Onskreen
+     * Date: 07/01/2012
+     *
+     * Determines if an Activity will support both landscape and portrait
+     *
+     * true - Activity does not specifiy only portrait or landscape orientations
+     * false - Activity specifies runs in either landscape or portrait only.
+     *
+     */
+    private boolean checkActivitySupportsRequiredOrientations(ActivityInfo appInfo) {
+		int screenOrientation = appInfo.screenOrientation;
+		if(screenOrientation == ActivityInfo.SCREEN_ORIENTATION_LANDSCAPE ||
+				screenOrientation == ActivityInfo.SCREEN_ORIENTATION_PORTRAIT ||
+				screenOrientation == ActivityInfo.SCREEN_ORIENTATION_REVERSE_LANDSCAPE ||
+				screenOrientation == ActivityInfo.SCREEN_ORIENTATION_REVERSE_PORTRAIT ||
+				screenOrientation == ActivityInfo.SCREEN_ORIENTATION_SENSOR_LANDSCAPE ||
+				screenOrientation == ActivityInfo.SCREEN_ORIENTATION_SENSOR_PORTRAIT){
+			return false;
+		} else {
+			return true;
+		}
+    }
+
     public final int startActivity(IApplicationThread caller,
             Intent intent, String resolvedType, IBinder resultTo,
             String resultWho, int requestCode, int startFlags,
@@ -2365,7 +2830,113 @@ public final class ActivityManagerService extends ActivityManagerNative
                 userId = Binder.getOrigCallingUser();
             }
         }
-        return mMainStack.startActivityMayWait(caller, -1, intent, resolvedType,
+        /**
+         * Author: Onskreen
+         * Date: 12/01/2011
+         *
+         * Send to appropriate stack
+         */
+        int stack = getActivityStack(intent, resultTo);
+        ActivityStack targetStack = null;
+        //Cornerstone Panel
+        if(stack >= 0) {
+			if(stack < mCornerstonePanelStacks.size()) {
+				targetStack = mCornerstonePanelStacks.get(stack);
+
+                /**
+                 * Author: Onskreen
+                 * Date: 08/03/2011
+                 *
+                 * Notifies CSPanel app to change the cs app header controls appropriately
+                 */
+				ComponentName cp = intent.getComponent();
+				if(cp != null){
+					String pkg = cp.getPackageName();
+					if(pkg != null){
+						broadcastCornerstonePanelFocusChanged(pkg, true, stack);
+					}
+				}
+			} else {
+				Log.e(TAG, "Found in Non-Existent Stack");
+				return -1;
+			}
+        } else if(stack == CORNERSTONE_STACK) {
+			//System.out.println("Found in Cornerstone Stack");
+			//Cornerstone
+			targetStack = mCornerstoneStack;
+			mActivityStackExiting = false;
+			mWindowManager.setCornerstoneState(WindowManagerService.Cornerstone_State.RUNNING_OPEN);
+            /**
+             * Author: Onskreen
+             * Date: 07/01/2012
+             *
+             * Cornerstone running will require a config change of Main Panel
+             */
+            final long origId = Binder.clearCallingIdentity();
+            if(DEBUG_CONFIGURATION) {
+				Slog.i(TAG, "State: Cornerstone Launched\tAction: Config Main Panel");
+            }
+            /**
+             * Author: Onskreen
+             * Date: 07/01/2012
+             *
+             * we might not want to call for a reconfig until after the activity is started?
+             */
+            forceConfigurationLocked(mMainStack, WindowManagerService.Cornerstone_State.RUNNING_OPEN);
+            Binder.restoreCallingIdentity(origId);
+        } else if(stack == MAIN_STACK || stack == NO_STACK) {
+			//System.out.println("Found in Main Stack");
+			//Main stack or Unknown
+            targetStack = mMainStack;
+        }
+
+        /**
+         * Author: Onskreen
+         * Date: 16/03/2011
+         *
+         * Bring the top most main panel activity to front on long press HOME key
+         */
+        if(targetStack == mMainStack && resultTo == null){
+            ActivityRecord r = mMainStack.topRunningActivityLocked(null);
+            if(r !=null) {
+                ComponentName cp = intent.getComponent();
+                if(cp != null){
+                    String pkg = cp.getPackageName();
+                    if(pkg != null){
+                        if(pkg.equals(r.packageName)){
+                            mWindowManager.handleFocusChange(r.appToken.asBinder());
+                            return ActivityManager.START_TASK_TO_FRONT;
+                        } else {
+                            mWindowManager.handleFocusChange(r.appToken.asBinder());
+                        }
+                    }
+                }
+            }
+        }
+
+        /**
+         * Author: Onskreen
+         * Date: 09/08/2011
+         *
+         * Check for the multiple instances of CSPanel app in cornerstone stack.
+         * If found the second instance, then don't start the new instance just
+         * return it.
+         */
+        if(targetStack == mCornerstoneStack && resultTo != null){
+            ActivityRecord r = mCornerstoneStack.topRunningActivityLocked(null);
+            if(r !=null) {
+                ComponentName cp = intent.getComponent();
+                if(cp != null){
+                    String pkg = cp.getPackageName();
+                    if(pkg != null){
+                        if(pkg.equals(r.packageName)){
+                            return ActivityManager.START_TASK_TO_FRONT;
+                        }
+                    }
+                }
+            }
+        }
+        return targetStack.startActivityMayWait(caller, -1, intent, resolvedType,
                 resultTo, resultWho, requestCode, startFlags, profileFile, profileFd,
                 null, null, options, userId);
     }
@@ -2419,12 +2990,24 @@ public final class ActivityManagerService extends ActivityManagerNative
                             Binder.getCallingUid()) {
                 mAppSwitchesAllowedTime = 0;
             }
+            /**
+             * Author: Onskreen
+             * Date: 27/01/2011
+             *
+             * Mirroring the app switching logic in cornerstone. Not clear if this should
+             * be mirrored or applied to only the appropriate stack?
+             */
+            if (mCornerstoneStack.mResumedActivity != null
+                    && mCornerstoneStack.mResumedActivity.info.applicationInfo.uid ==
+                            Binder.getCallingUid()) {
+                mAppSwitchesAllowedTime = 0;
+            }
         }
         int ret = pir.sendInner(0, fillInIntent, resolvedType, null, null,
                 resultTo, resultWho, requestCode, flagsMask, flagsValues, options);
         return ret;
     }
-    
+
     public boolean startNextMatchingActivity(IBinder callingActivity,
             Intent intent, Bundle options) {
         // Refuse possible leaked file descriptors
@@ -2433,7 +3016,31 @@ public final class ActivityManagerService extends ActivityManagerNative
         }
 
         synchronized (this) {
-            ActivityRecord r = mMainStack.isInStackLocked(callingActivity);
+            /**
+             * Author: Onskreen
+             * Date: 27/01/2011
+             *
+             * Choosing between stacks for all following logic. Has to be
+             * ensured that callingActivity can indicate this.
+             */
+            int stack = getActivityStack(callingActivity);
+            ActivityStack targetStack = null;
+            //Cornerstone Panel
+            if(stack >= 0) {
+				if(stack < mCornerstonePanelStacks.size()) {
+					targetStack = mCornerstonePanelStacks.get(stack);
+				} else {
+					Log.e(TAG, "Found in Non-Existent Stack");
+					return false;
+				}
+            } else if(stack == CORNERSTONE_STACK) {
+				//Cornerstone
+				targetStack = mCornerstoneStack;
+            } else if(stack == MAIN_STACK || stack == NO_STACK) {
+				//Main stack or Unknown
+                targetStack = mMainStack;
+            }
+            ActivityRecord r = targetStack.isInStackLocked(callingActivity);
             if (r == null) {
                 ActivityOptions.abort(options);
                 return false;
@@ -2507,7 +3114,7 @@ public final class ActivityManagerService extends ActivityManagerNative
             }
 
             final long origId = Binder.clearCallingIdentity();
-            int res = mMainStack.startActivityLocked(r.app.thread, intent,
+            int res = targetStack.startActivityLocked(r.app.thread, intent,
                     r.resolvedType, aInfo, resultTo != null ? resultTo.appToken : null,
                     resultWho, requestCode, -1, r.launchedFromUid, 0,
                     options, false, null);
@@ -2534,7 +3141,31 @@ public final class ActivityManagerService extends ActivityManagerNative
                     "startActivityInPackage only available to the system");
         }
 
-        int ret = mMainStack.startActivityMayWait(null, uid, intent, resolvedType,
+            /**
+             * Author: Onskreen
+             * Date: 12/01/2011
+             *
+             * TODO - All of this in a synchronized block is a horrible idea. Must clean.
+             */
+            int stack = getActivityStack(intent, resultTo);
+            ActivityStack targetStack = null;
+            //Cornerstone Panel
+            if(stack >= 0) {
+				if(stack < mCornerstonePanelStacks.size()) {
+					targetStack = mCornerstonePanelStacks.get(stack);
+				} else {
+					Log.e(TAG, "Found in Non-Existent Stack");
+					return -1;
+				}
+            } else if(stack == CORNERSTONE_STACK) {
+				//Cornerstone
+				targetStack = mCornerstoneStack;
+            } else if(stack == MAIN_STACK || stack == NO_STACK) {
+				//Main stack or Unknown
+                targetStack = mMainStack;
+            }
+
+        int ret = targetStack.startActivityMayWait(null, uid, intent, resolvedType,
                 resultTo, resultWho, requestCode, startFlags,
                 null, null, null, null, options, userId);
         return ret;
@@ -2543,7 +3174,29 @@ public final class ActivityManagerService extends ActivityManagerNative
     public final int startActivities(IApplicationThread caller,
             Intent[] intents, String[] resolvedTypes, IBinder resultTo, Bundle options) {
         enforceNotIsolatedCaller("startActivities");
-        int ret = mMainStack.startActivities(caller, -1, intents, resolvedTypes, resultTo,
+          /**
+           * Author: Onskreen
+           * Date: 12/01/2011
+           *
+           */
+            int stack = getActivityStack(intents[0], resultTo);
+            ActivityStack targetStack = null;
+            //Cornerstone Panel
+            if(stack >= 0) {
+				if(stack < mCornerstonePanelStacks.size()) {
+					targetStack = mCornerstonePanelStacks.get(stack);
+				} else {
+					Log.e(TAG, "Found in Non-Existent Stack");
+					return -1;
+				}
+            } else if(stack == CORNERSTONE_STACK) {
+				//Cornerstone
+				targetStack = mCornerstoneStack;
+            } else if(stack == MAIN_STACK || stack == NO_STACK) {
+				//Main stack or Unknown
+                targetStack = mMainStack;
+            }
+        int ret = targetStack.startActivities(caller, -1, intents, resolvedTypes, resultTo,
                 options, Binder.getOrigCallingUser());
         return ret;
     }
@@ -2559,7 +3212,29 @@ public final class ActivityManagerService extends ActivityManagerNative
             throw new SecurityException(
                     "startActivityInPackage only available to the system");
         }
-        int ret = mMainStack.startActivities(null, uid, intents, resolvedTypes, resultTo,
+        /**
+         * Author: Onskreen
+         * Date: 12/01/2011
+         *
+         */
+        int stack = getActivityStack(intents[0], resultTo);
+        ActivityStack targetStack = null;
+        //Cornerstone Panel
+        if(stack >= 0) {
+			if(stack < mCornerstonePanelStacks.size()) {
+				targetStack = mCornerstonePanelStacks.get(stack);
+			} else {
+				Log.e(TAG, "Found in Non-Existent Stack");
+				return -1;
+			}
+        } else if(stack == CORNERSTONE_STACK) {
+			//Cornerstone
+			targetStack = mCornerstoneStack;
+        } else if(stack == MAIN_STACK || stack == NO_STACK) {
+			//Main stack or Unknown
+            targetStack = mMainStack;
+        }
+        int ret = targetStack.startActivities(null, uid, intents, resolvedTypes, resultTo,
                 options, UserId.getUserId(uid));
         return ret;
     }
@@ -2595,7 +3270,29 @@ public final class ActivityManagerService extends ActivityManagerNative
     public void setRequestedOrientation(IBinder token,
             int requestedOrientation) {
         synchronized (this) {
-            ActivityRecord r = mMainStack.isInStackLocked(token);
+            /**
+             * Author: Onskreen
+             * Date: 12/01/2011
+             *
+             */
+            int stack = getActivityStack(token);
+            ActivityStack targetStack = null;
+            //Cornerstone Panel
+			if(stack >= 0) {
+				if(stack < mCornerstonePanelStacks.size()) {
+					targetStack = mCornerstonePanelStacks.get(stack);
+				} else {
+					Log.e(TAG, "Found in Non-Existent Stack");
+					return;
+				}
+            } else if(stack == CORNERSTONE_STACK) {
+				//Cornerstone
+				targetStack = mCornerstoneStack;
+            } else if(stack == MAIN_STACK || stack == NO_STACK) {
+				//Main stack or Unknown
+                targetStack = mMainStack;
+            }
+            ActivityRecord r = targetStack.isInStackLocked(token);
             if (r == null) {
                 return;
             }
@@ -2607,7 +3304,7 @@ public final class ActivityManagerService extends ActivityManagerNative
             if (config != null) {
                 r.frozenBeforeDestroy = true;
                 if (!updateConfigurationLocked(config, r, false, false)) {
-                    mMainStack.resumeTopActivityLocked(null);
+                    targetStack.resumeTopActivityLocked(null);
                 }
             }
             Binder.restoreCallingIdentity(origId);
@@ -2616,7 +3313,29 @@ public final class ActivityManagerService extends ActivityManagerNative
 
     public int getRequestedOrientation(IBinder token) {
         synchronized (this) {
-            ActivityRecord r = mMainStack.isInStackLocked(token);
+            /**
+             * Author: Onskreen
+             * Date: 12/01/2011
+             *
+             */
+            int stack = getActivityStack(token);
+            ActivityStack targetStack = null;
+            //Cornerstone Panel
+            if(stack >= 0) {
+				if(stack < mCornerstonePanelStacks.size()) {
+					targetStack = mCornerstonePanelStacks.get(stack);
+				} else {
+					Log.e(TAG, "Found in Non-Existent Stack");
+					return -1;
+				}
+            } else if(stack == CORNERSTONE_STACK) {
+				//Cornerstone
+				targetStack = mCornerstoneStack;
+            } else if(stack == MAIN_STACK || stack == NO_STACK) {
+				//Main stack or Unknown
+                targetStack = mMainStack;
+            }
+            ActivityRecord r = targetStack.isInStackLocked(token);
             if (r == null) {
                 return ActivityInfo.SCREEN_ORIENTATION_UNSPECIFIED;
             }
@@ -2638,11 +3357,32 @@ public final class ActivityManagerService extends ActivityManagerNative
         if (resultData != null && resultData.hasFileDescriptors() == true) {
             throw new IllegalArgumentException("File descriptors passed in Intent");
         }
-
         synchronized(this) {
+            /**
+             * Author: Onskreen
+             * Date: 12/01/2011
+             *
+             */
+            int stack = getActivityStack(token);
+            ActivityStack targetStack = null;
+            //Cornerstone Panel
+            if(stack >= 0) {
+                if(stack < mCornerstonePanelStacks.size()) {
+                    targetStack = mCornerstonePanelStacks.get(stack);
+				} else {
+					Log.e(TAG, "Found in Non-Existent Stack");
+					return false;
+				}
+            } else if(stack == CORNERSTONE_STACK) {
+				//Cornerstone
+				targetStack = mCornerstoneStack;
+            } else if(stack == MAIN_STACK || stack == NO_STACK) {
+				//Main stack or Unknown
+                targetStack = mMainStack;
+            }
             if (mController != null) {
                 // Find the first activity that is not finishing.
-                ActivityRecord next = mMainStack.topRunningActivityLocked(token, 0);
+                ActivityRecord next = targetStack.topRunningActivityLocked(token, 0);
                 if (next != null) {
                     // ask watcher if this is allowed
                     boolean resumeOK = true;
@@ -2651,15 +3391,50 @@ public final class ActivityManagerService extends ActivityManagerNative
                     } catch (RemoteException e) {
                         mController = null;
                     }
-    
+
                     if (!resumeOK) {
                         return false;
                     }
                 }
             }
             final long origId = Binder.clearCallingIdentity();
-            boolean res = mMainStack.requestFinishActivityLocked(token, resultCode,
-                    resultData, "app-request");
+            /**
+             * Author: Onskreen
+             * Date: 16/07/2011
+             *
+             * If cornerstone stack found, then kill the CSPanel and cornerstone panel
+             * activities and inform the WindowManagerService to set the layout as per
+             * layout config.
+             */
+            boolean res;
+            if(targetStack == mCornerstoneStack) {
+                mActivityStackExiting = true;
+                for(int i = 0; i < mCornerstonePanelStacks.size(); i++){
+                    targetStack = mCornerstonePanelStacks.get(i);
+                    for (int j = targetStack.mHistory.size()-1; j >= 0; j--) {
+                        ActivityRecord r = (ActivityRecord)targetStack.mHistory.get(j);
+                        targetStack.requestFinishActivityLocked(r.appToken.asBinder(), 0, null, "app-request");
+                    }
+                }
+                res = mCornerstoneStack.requestFinishActivityLocked(token, resultCode,
+                            resultData, "app-request");
+                mWindowManager.setCornerstoneState(WindowManagerService.Cornerstone_State.TERMINATED);
+
+                /**
+                 * Author: Onskreen
+                 * Date: 26/12/2011
+                 *
+                 * Trigger the Main Stack to config itself.
+                 */
+                if(DEBUG_CONFIGURATION) {
+                    Slog.i(TAG, "State: Cornerstone Exit\tAction: Config Main Panel");
+                }
+                forceConfigurationLocked(mMainStack, WindowManagerService.Cornerstone_State.TERMINATED);
+            } else {
+                res = targetStack.requestFinishActivityLocked(token, resultCode,
+                            resultData, "app-request");
+            }
+
             Binder.restoreCallingIdentity(origId);
             return res;
         }
@@ -2675,30 +3450,52 @@ public final class ActivityManagerService extends ActivityManagerNative
             Slog.w(TAG, msg);
             throw new SecurityException(msg);
         }
-        
+
         synchronized(this) {
             if (mHeavyWeightProcess == null) {
                 return;
             }
-            
+
             ArrayList<ActivityRecord> activities = new ArrayList<ActivityRecord>(
                     mHeavyWeightProcess.activities);
             for (int i=0; i<activities.size(); i++) {
                 ActivityRecord r = activities.get(i);
                 if (!r.finishing) {
-                    int index = mMainStack.indexOfTokenLocked(r.appToken);
+                    /**
+                     * Author: Onskreen
+                     * Date: 27/01/2011
+                     *
+                     */
+                    int stack = getActivityStack(r);
+                    ActivityStack targetStack = null;
+                    //Cornerstone Panel
+                    if(stack >= 0) {
+						if(stack < mCornerstonePanelStacks.size()) {
+							targetStack = mCornerstonePanelStacks.get(stack);
+						} else {
+							Log.e(TAG, "Found in Non-Existent Stack");
+							return;
+						}
+                    } else if(stack == CORNERSTONE_STACK) {
+						//Cornerstone
+						targetStack = mCornerstoneStack;
+                    } else if(stack == MAIN_STACK || stack == NO_STACK) {
+						//Main stack or Unknown
+                        targetStack = mMainStack;
+                    }
+                    int index = targetStack.indexOfTokenLocked(r.appToken);
                     if (index >= 0) {
-                        mMainStack.finishActivityLocked(r, index, Activity.RESULT_CANCELED,
+                        targetStack.finishActivityLocked(r, index, Activity.RESULT_CANCELED,
                                 null, "finish-heavy");
                     }
                 }
             }
-            
+
             mHeavyWeightProcess = null;
             mHandler.sendEmptyMessage(CANCEL_HEAVY_NOTIFICATION_MSG);
         }
     }
-    
+
     public void crashApplication(int uid, int initialPid, String packageName,
             String message) {
         if (checkCallingPermission(android.Manifest.permission.FORCE_STOP_PACKAGES)
@@ -2710,10 +3507,10 @@ public final class ActivityManagerService extends ActivityManagerNative
             Slog.w(TAG, msg);
             throw new SecurityException(msg);
         }
-        
+
         synchronized(this) {
             ProcessRecord proc = null;
-            
+
             // Figure out which process to kill.  We don't trust that initialPid
             // still has any relation to current pids, so must scan through the
             // list.
@@ -2756,12 +3553,34 @@ public final class ActivityManagerService extends ActivityManagerNative
             }
         }
     }
-    
+
     public final void finishSubActivity(IBinder token, String resultWho,
             int requestCode) {
         synchronized(this) {
             final long origId = Binder.clearCallingIdentity();
-            mMainStack.finishSubActivityLocked(token, resultWho, requestCode);
+            /**
+             * Author: Onskreen
+             * Date: 27/01/2011
+             *
+             */
+			int stack = getActivityStack(token);
+			ActivityStack targetStack = null;
+			//Cornerstone Panel
+			if(stack >= 0) {
+				if(stack < mCornerstonePanelStacks.size()) {
+					targetStack = mCornerstonePanelStacks.get(stack);
+				} else {
+					Log.e(TAG, "Found in Non-Existent Stack");
+					return;
+				}
+			} else if(stack == CORNERSTONE_STACK) {
+				//Cornerstone
+				targetStack = mCornerstoneStack;
+			} else if(stack == MAIN_STACK || stack == NO_STACK) {
+				//Main stack or Unknown
+				targetStack = mMainStack;
+			}
+            targetStack.finishSubActivityLocked(token, resultWho, requestCode);
             Binder.restoreCallingIdentity(origId);
         }
     }
@@ -2769,17 +3588,61 @@ public final class ActivityManagerService extends ActivityManagerNative
     public boolean finishActivityAffinity(IBinder token) {
         synchronized(this) {
             final long origId = Binder.clearCallingIdentity();
-            boolean res = mMainStack.finishActivityAffinityLocked(token);
+            /**
+             * Author: Onskreen
+             * Date: 27/01/2011
+             *
+             */
+			int stack = getActivityStack(token);
+			ActivityStack targetStack = null;
+			//Cornerstone Panel
+			if(stack >= 0) {
+				if(stack < mCornerstonePanelStacks.size()) {
+					targetStack = mCornerstonePanelStacks.get(stack);
+				} else {
+					Log.e(TAG, "Found in Non-Existent Stack");
+					return false;
+				}
+			} else if(stack == CORNERSTONE_STACK) {
+				//Cornerstone
+				targetStack = mCornerstoneStack;
+			} else if(stack == MAIN_STACK || stack == NO_STACK) {
+				//Main stack or Unknown
+				targetStack = mMainStack;
+			}
+            boolean res = targetStack.finishActivityAffinityLocked(token);
             Binder.restoreCallingIdentity(origId);
             return res;
         }
     }
 
     public boolean willActivityBeVisible(IBinder token) {
+        /**
+         * Author: Onskreen
+         * Date: 27/01/2011
+         *
+         */
+        int stack = getActivityStack(token);
+        ActivityStack targetStack = null;
+        //Cornerstone Panel
+        if(stack >= 0) {
+			if(stack < mCornerstonePanelStacks.size()) {
+				targetStack = mCornerstonePanelStacks.get(stack);
+			} else {
+				Log.e(TAG, "Found in Non-Existent Stack");
+				return false;
+			}
+        } else if(stack == CORNERSTONE_STACK) {
+			//Cornerstone
+			targetStack = mCornerstoneStack;
+        } else if(stack == MAIN_STACK || stack == NO_STACK) {
+			//Main stack or Unknown
+            targetStack = mMainStack;
+        }
         synchronized(this) {
             int i;
-            for (i=mMainStack.mHistory.size()-1; i>=0; i--) {
-                ActivityRecord r = (ActivityRecord)mMainStack.mHistory.get(i);
+            for (i=targetStack.mHistory.size()-1; i>=0; i--) {
+                ActivityRecord r = (ActivityRecord)targetStack.mHistory.get(i);
                 if (r.appToken == token) {
                     return true;
                 }
@@ -2790,27 +3653,48 @@ public final class ActivityManagerService extends ActivityManagerNative
             return true;
         }
     }
-    
+
     public void overridePendingTransition(IBinder token, String packageName,
             int enterAnim, int exitAnim) {
         synchronized(this) {
-            ActivityRecord self = mMainStack.isInStackLocked(token);
+            /**
+             * Author: Onskreen
+             * Date: 27/01/2011
+             *
+             */
+			int stack = getActivityStack(token);
+			ActivityStack targetStack = null;
+			//Cornerstone Panel
+			if(stack >= 0) {
+				if(stack < mCornerstonePanelStacks.size()) {
+					targetStack = mCornerstonePanelStacks.get(stack);
+				} else {
+					Log.e(TAG, "Found in Non-Existent Stack");
+					return;
+				}
+			} else if(stack == CORNERSTONE_STACK) {
+				//Cornerstone
+				targetStack = mCornerstoneStack;
+			} else if(stack == MAIN_STACK || stack == NO_STACK) {
+				//Main stack or Unknown
+				targetStack = mMainStack;
+			}
+            ActivityRecord self = targetStack.isInStackLocked(token);
             if (self == null) {
                 return;
             }
 
             final long origId = Binder.clearCallingIdentity();
-            
             if (self.state == ActivityState.RESUMED
                     || self.state == ActivityState.PAUSING) {
                 mWindowManager.overridePendingAppTransition(packageName,
                         enterAnim, exitAnim, null);
             }
-            
+
             Binder.restoreCallingIdentity(origId);
         }
     }
-    
+
     /**
      * Main function for removing an existing process from the activity manager
      * as a result of that process going away.  Clears out all connections
@@ -2818,6 +3702,41 @@ public final class ActivityManagerService extends ActivityManagerNative
      */
     private final void handleAppDiedLocked(ProcessRecord app,
             boolean restarting, boolean allowRestart) {
+
+        /**
+         * Author: Onskreen
+         * Date: 27/01/2011
+         *
+         * Method logic moved to overloaded version.
+         */
+		handleAppDiedLocked(app, restarting, mMainStack, allowRestart);
+		handleAppDiedLocked(app, restarting, mCornerstoneStack, allowRestart);
+
+		/**
+         * Author: Onskreen
+         * Date: 17/06/2011
+         *
+         * Should be called for cornerstone panel stacks too when user forcefully
+         * kills the activities in cornerstone panel in the event of ANR or any other
+         * similar scenario.
+         */
+		for(int i = 0; i < mCornerstonePanelStacks.size(); i++){
+            ActivityStack targetStack = mCornerstonePanelStacks.get(i);
+            handleAppDiedLocked(app, restarting, targetStack, allowRestart);
+        }
+    }
+
+    /**
+     * Author: Onskreen
+     * Date: 27/01/2011
+     *
+     * Replica of handleAppDiedLocked which acts on a specific ActivityStack.
+     * @param app
+     * @param restarting
+     * @param currStack
+     */
+    private final void handleAppDiedLocked(ProcessRecord app, boolean restarting, ActivityStack currStack,
+	boolean allowRestart) {
         cleanUpApplicationRecordLocked(app, restarting, allowRestart, -1);
         if (!restarting) {
             mLruProcesses.remove(app);
@@ -2828,27 +3747,27 @@ public final class ActivityManagerService extends ActivityManagerNative
         }
 
         // Just in case...
-        if (mMainStack.mPausingActivity != null && mMainStack.mPausingActivity.app == app) {
-            if (DEBUG_PAUSE) Slog.v(TAG, "App died while pausing: " +mMainStack.mPausingActivity);
-            mMainStack.mPausingActivity = null;
+        if (currStack.mPausingActivity != null && currStack.mPausingActivity.app == app) {
+            if (DEBUG_PAUSE) Slog.v(TAG, "App died while pausing: " +currStack.mPausingActivity);
+            currStack.mPausingActivity = null;
         }
-        if (mMainStack.mLastPausedActivity != null && mMainStack.mLastPausedActivity.app == app) {
-            mMainStack.mLastPausedActivity = null;
+        if (currStack.mLastPausedActivity != null && currStack.mLastPausedActivity.app == app) {
+            currStack.mLastPausedActivity = null;
         }
 
         // Remove this application's activities from active lists.
-        mMainStack.removeHistoryRecordsForAppLocked(app);
+        currStack.removeHistoryRecordsForAppLocked(app);
 
         boolean atTop = true;
         boolean hasVisibleActivities = false;
 
         // Clean out the history list.
-        int i = mMainStack.mHistory.size();
+        int i = currStack.mHistory.size();
         if (localLOGV) Slog.v(
             TAG, "Removing app " + app + " from history with " + i + " entries");
         while (i > 0) {
             i--;
-            ActivityRecord r = (ActivityRecord)mMainStack.mHistory.get(i);
+            ActivityRecord r = (ActivityRecord)currStack.mHistory.get(i);
             if (localLOGV) Slog.v(
                 TAG, "Record #" + i + " " + r + ": app=" + r.app);
             if (r.app == app) {
@@ -2869,7 +3788,7 @@ public final class ActivityManagerService extends ActivityManagerNative
                                 r.task.taskId, r.shortComponentName,
                                 "proc died without state saved");
                     }
-                    mMainStack.removeActivityFromHistoryLocked(r);
+                    currStack.removeActivityFromHistoryLocked(r);
 
                 } else {
                     // We have the current state for this activity, so
@@ -2894,7 +3813,7 @@ public final class ActivityManagerService extends ActivityManagerNative
         }
 
         app.activities.clear();
-        
+
         if (app.instrumentationClass != null) {
             Slog.w(TAG, "Crash of app " + app.processName
                   + " running instrumentation " + app.instrumentationClass);
@@ -2904,14 +3823,14 @@ public final class ActivityManagerService extends ActivityManagerNative
         }
 
         if (!restarting) {
-            if (!mMainStack.resumeTopActivityLocked(null)) {
+            if (!currStack.resumeTopActivityLocked(null)) {
                 // If there was nothing to resume, and we are not already
                 // restarting this process, but there is a visible activity that
                 // is hosted by the process...  then make sure all visible
                 // activities are running, taking care of restarting this
                 // process.
                 if (hasVisibleActivities) {
-                    mMainStack.ensureActivitiesVisibleLocked(null, 0);
+                    currStack.ensureActivitiesVisibleLocked(null, 0);
                 }
             }
         }
@@ -3582,7 +4501,20 @@ public final class ActivityManagerService extends ActivityManagerNative
                         Activity.RESULT_CANCELED, null, "close-sys");
             }
         }
-        
+
+            /**
+             * Author: Onskreen
+             * Date: 27/01/2011
+             *
+             * Replicating logic for cornerstone stack
+             */
+            for (int i=mCornerstoneStack.mHistory.size()-1; i>=0; i--) {
+                ActivityRecord r = (ActivityRecord)mCornerstoneStack.mHistory.get(i);
+                if ((r.info.flags&ActivityInfo.FLAG_FINISH_ON_CLOSE_SYSTEM_DIALOGS) != 0) {
+                    r.stack.finishActivityLocked(r, i,
+                            Activity.RESULT_CANCELED, null, "close-sys");
+                }
+            }
         broadcastIntentLocked(null, null, intent, null,
                 null, 0, null, null, null, false, false, -1,
                 callingUid, 0 /* TODO: Verify */);
@@ -3753,6 +4685,27 @@ public final class ActivityManagerService extends ActivityManagerNative
             }
         }
 
+        /**
+         * Author: Onskreen
+         * Date: 27/01/2011
+         *
+         * Mirroing logic in cornerstone.
+         */
+        for (i=mCornerstoneStack.mHistory.size()-1; i>=0; i--) {
+            ActivityRecord r = (ActivityRecord)mCornerstoneStack.mHistory.get(i);
+            if (r.packageName.equals(name)) {
+                if (!doit) {
+                    return true;
+                }
+                didSomething = true;
+                Slog.i(TAG, "  Force finishing activity " + r);
+                if (r.app != null) {
+                    r.app.removed = true;
+                }
+                r.app = null;
+                r.stack.finishActivityLocked(r, i, Activity.RESULT_CANCELED, null, "uninstall");
+            }
+        }
         ArrayList<ServiceRecord> services = new ArrayList<ServiceRecord>();
         for (ServiceRecord service : mServiceMap.getAllServices(userId)) {
             if (service.packageName.equals(name)
@@ -3803,9 +4756,17 @@ public final class ActivityManagerService extends ActivityManagerNative
             if (mBooted) {
                 mMainStack.resumeTopActivityLocked(null);
                 mMainStack.scheduleIdleLocked();
+                /**
+                 * Author: Onskreen
+                 * Date: 27/01/2011
+                 *
+                 * Mirroing logic in cornerstone.
+                 */
+                mCornerstoneStack.resumeTopActivityLocked(null);
+                mCornerstoneStack.scheduleIdleLocked();
             }
         }
-        
+
         return didSomething;
     }
 
@@ -4018,15 +4979,76 @@ public final class ActivityManagerService extends ActivityManagerNative
                         || (mBackupTarget.backupMode == BackupRecord.RESTORE_FULL)
                         || (mBackupTarget.backupMode == BackupRecord.BACKUP_FULL);
             }
-            
+
             ensurePackageDexOpt(app.instrumentationInfo != null
                     ? app.instrumentationInfo.packageName
                     : app.info.packageName);
             if (app.instrumentationClass != null) {
                 ensurePackageDexOpt(app.instrumentationClass.getPackageName());
             }
+            /**
+             * Author: Onskreen
+             * Date: 26/12/2011
+             *
+             * The ActivityRecord is in the mHistory at this point, but has not been attached to a ProcessRecord
+             * as of yet.
+             *
+             * TODO There has to be a better way to find the candidate.
+             *
+             */
+            //Check Main Stack
+            Configuration wpConfig = null;
+            for(ActivityRecord ar: mMainStack.mHistory) {
+				if(ar.app == null) {
+					wpConfig = mWindowManager.computeWindowPanelConfiguration(WindowManagerService.WP_Panel.MAIN_PANEL);
+					break;
+				}
+            }
+            if(wpConfig == null) {
+				//Check CS Stacks
+				for(ActivityStack as: mCornerstonePanelStacks) {
+					for(ActivityRecord ar: as.mHistory) {
+						if(ar.app == null) {
+							if(as.mCornerstonePanelIndex == 0) {
+								wpConfig = mWindowManager.computeWindowPanelConfiguration(WindowManagerService.WP_Panel.CS_APP_0);
+							} else {
+								wpConfig = mWindowManager.computeWindowPanelConfiguration(WindowManagerService.WP_Panel.CS_APP_1);
+							}
+							break;
+						}
+					}
+					if(wpConfig != null) {
+						break;
+					}
+				}
+            }
+
+            /**
+             * Author: Onskreen
+             * TEST - Why isn't CSPanel in the activitystack before getting here?
+             */
+           /** if(wpConfig == null) {
+                for(ActivityRecord ar: mCornerstoneStack.mHistory) {
+					if(ar.app == null) {
+						wpConfig = mWindowManager.computeWindowPanelConfiguration(WindowManagerService.WP_Panel.CORNERSTONE);
+						break;
+					}
+                }
+            }**/
+
+            Configuration configToUse;
+            if(wpConfig != null) {
+               configToUse = wpConfig;
+            } else {
+                /**
+                 * Author: Onskreen
+                 * Date: 05/01/2012
+                 *
+                 */
+				configToUse = mConfiguration;
+            }
             if (DEBUG_CONFIGURATION) Slog.v(TAG, "Binding proc "
-                    + processName + " with config " + mConfiguration);
+                    + processName + " with config " + configToUse/*mConfiguration*/);
             ApplicationInfo appInfo = app.instrumentationInfo != null
                     ? app.instrumentationInfo : app.info;
             app.compat = compatibilityInfoForPackageLocked(appInfo);
@@ -4037,7 +5059,7 @@ public final class ActivityManagerService extends ActivityManagerNative
                     app.instrumentationClass, profileFile, profileFd, profileAutoStop,
                     app.instrumentationArguments, app.instrumentationWatcher, testMode,
                     enableOpenGlTrace, isRestrictedBackupMode || !normalMode, app.persistent,
-                    new Configuration(mConfiguration), app.compat, getCommonServicesLocked(),
+                    new Configuration(configToUse /*mConfiguration*/), app.compat, getCommonServicesLocked(),
                     mCoreSettingsObserver.getCoreSettingsLocked());
             updateLruProcessLocked(app, false, true);
             app.lastRequestedGc = app.lastLowMemory = SystemClock.uptimeMillis();
@@ -4083,6 +5105,56 @@ public final class ActivityManagerService extends ActivityManagerNative
             }
         }
 
+        /**
+         * Author: Onskreen
+         * Date: 27/01/2011
+         *
+         * Mirroring logic in cornerstone.
+         */
+        ActivityRecord hr_c = mCornerstoneStack.topRunningActivityLocked(null);
+        if (hr_c != null && normalMode) {
+            if (hr_c.app == null && app.info.uid == hr_c.info.applicationInfo.uid
+                    && processName.equals(hr_c.processName)) {
+                try {
+                    if (mCornerstoneStack.realStartActivityLocked(hr_c, app, true, true)) {
+                        didSomething = true;
+                    }
+                } catch (Exception e) {
+                    Slog.w(TAG, "Exception in new application when starting activity "
+                          + hr_c.intent.getComponent().flattenToShortString(), e);
+                    badApp = true;
+                }
+            } else {
+                mCornerstoneStack.ensureActivitiesVisibleLocked(hr_c, null, processName, 0);
+            }
+        }
+
+        /**
+         * Author: Onskreen
+         * Date: 27/01/2011
+         *
+         * Mirroring logic in cornerstone panels.
+         */
+        for(int k=0; k<mCornerstonePanelStacks.size(); k++) {
+			ActivityStack currStack = mCornerstonePanelStacks.get(k);
+			ActivityRecord hr_p = currStack.topRunningActivityLocked(null);
+			if (hr_p != null && normalMode) {
+				if (hr_p.app == null && app.info.uid == hr_p.info.applicationInfo.uid
+						&& processName.equals(hr_p.processName)) {
+					try {
+						if (currStack.realStartActivityLocked(hr_p, app, true, true)) {
+							didSomething = true;
+						}
+					} catch (Exception e) {
+						Slog.w(TAG, "Exception in new application when starting activity "
+								+ hr_p.intent.getComponent().flattenToShortString(), e);
+						badApp = true;
+					}
+				} else {
+					currStack.ensureActivitiesVisibleLocked(hr_p, null, processName, 0);
+				}
+			}
+        }
         // Find any services that should be running in this process...
         if (!badApp && mPendingServices.size() > 0) {
             ServiceRecord sr = null;
@@ -4155,7 +5227,30 @@ public final class ActivityManagerService extends ActivityManagerNative
 
     public final void activityIdle(IBinder token, Configuration config, boolean stopProfiling) {
         final long origId = Binder.clearCallingIdentity();
-        ActivityRecord r = mMainStack.activityIdleInternal(token, false, config);
+        /**
+         * Author: Onskreen
+         * Date: 27/01/2011
+         *
+         * Push message to appropriate stack.
+         */
+        int stack = getActivityStack(token);
+        ActivityStack targetStack = null;
+        //Cornerstone Panel
+        if(stack >= 0) {
+			if(stack < mCornerstonePanelStacks.size()) {
+				targetStack = mCornerstonePanelStacks.get(stack);
+			} else {
+				Log.e(TAG, "Found in Non-Existent Stack");
+				return;
+			}
+        } else if(stack == CORNERSTONE_STACK) {
+			//Cornerstone
+			targetStack = mCornerstoneStack;
+        } else if(stack == MAIN_STACK || stack == NO_STACK) {
+			//Main stack or Unknown
+            targetStack = mMainStack;
+        }
+        ActivityRecord r = targetStack.activityIdleInternal(token, false, config);
         if (stopProfiling) {
             synchronized (this) {
                 if (mProfileProc == r.app) {
@@ -4282,10 +5377,33 @@ public final class ActivityManagerService extends ActivityManagerNative
             enableScreenAfterBoot();
         }
     }
-    
+
     public final void activityPaused(IBinder token) {
         final long origId = Binder.clearCallingIdentity();
-        mMainStack.activityPaused(token, false);
+        /**
+         * Author: Onskreen
+         * Date: 27/01/2011
+         *
+         * Choosing between stacks
+         */
+        int stack = getActivityStack(token);
+        ActivityStack targetStack = null;
+        //Cornerstone Panel
+        if(stack >= 0) {
+			if(stack < mCornerstonePanelStacks.size()) {
+				targetStack = mCornerstonePanelStacks.get(stack);
+			} else {
+				Log.e(TAG, "Found in Non-Existent Stack");
+				return;
+			}
+        } else if(stack == CORNERSTONE_STACK) {
+			//Cornerstone
+			targetStack = mCornerstoneStack;
+        } else if(stack == MAIN_STACK || stack == NO_STACK) {
+			//Main stack or Unknown
+            targetStack = mMainStack;
+        }
+        targetStack.activityPaused(token, false);
         Binder.restoreCallingIdentity(origId);
     }
 
@@ -4302,9 +5420,31 @@ public final class ActivityManagerService extends ActivityManagerNative
         ActivityRecord r = null;
 
         final long origId = Binder.clearCallingIdentity();
-
+        /**
+         * Author: Onskreen
+         * Date: 27/01/2011
+         *
+         * Choosing between stacks
+         */
+        int stack = getActivityStack(token);
+        ActivityStack targetStack = null;
+        //Cornerstone Panel
+        if(stack >= 0) {
+			if(stack < mCornerstonePanelStacks.size()) {
+				targetStack = mCornerstonePanelStacks.get(stack);
+			} else {
+				Log.e(TAG, "Found in Non-Existent Stack");
+				return;
+			}
+        } else if(stack == CORNERSTONE_STACK) {
+			//Cornerstone
+			targetStack = mCornerstoneStack;
+        } else if(stack == MAIN_STACK || stack == NO_STACK) {
+			//Main stack or Unknown
+            targetStack = mMainStack;
+        }
         synchronized (this) {
-            r = mMainStack.isInStackLocked(token);
+            r = targetStack.isInStackLocked(token);
             if (r != null) {
                 r.stack.activityStoppedLocked(r, icicle, thumbnail, description);
             }
@@ -4321,9 +5461,32 @@ public final class ActivityManagerService extends ActivityManagerNative
 
     public final void activityDestroyed(IBinder token) {
         if (DEBUG_SWITCH) Slog.v(TAG, "ACTIVITY DESTROYED: " + token);
-        mMainStack.activityDestroyed(token);
+        /**
+         * Author: Onskreen
+         * Date: 27/01/2011
+         *
+         * Choosing between stacks
+         */
+        int stack = getActivityStack(token);
+        ActivityStack targetStack = null;
+        //Cornerstone Panel
+        if(stack >= 0) {
+			if(stack < mCornerstonePanelStacks.size()) {
+				targetStack = mCornerstonePanelStacks.get(stack);
+			} else {
+				Log.e(TAG, "Found in Non-Existent Stack");
+				return;
+			}
+        } else if(stack == CORNERSTONE_STACK) {
+			//Cornerstone
+			targetStack = mCornerstoneStack;
+        } else if(stack == MAIN_STACK || stack == NO_STACK) {
+			//Main stack or Unknown
+            targetStack = mMainStack;
+        }
+        targetStack.activityDestroyed(token);
     }
-    
+
     public String getCallingPackage(IBinder token) {
         synchronized (this) {
             ActivityRecord r = getCallingRecordLocked(token);
@@ -4339,7 +5502,30 @@ public final class ActivityManagerService extends ActivityManagerNative
     }
 
     private ActivityRecord getCallingRecordLocked(IBinder token) {
-        ActivityRecord r = mMainStack.isInStackLocked(token);
+        /**
+         * Author: Onskreen
+         * Date: 27/01/2011
+         *
+         * Choosing between stacks
+         */
+        int stack = getActivityStack(token);
+        ActivityStack targetStack = null;
+        //Cornerstone Panel
+        if(stack >= 0) {
+			if(stack < mCornerstonePanelStacks.size()) {
+				targetStack = mCornerstonePanelStacks.get(stack);
+			} else {
+				Log.e(TAG, "Found in Non-Existent Stack");
+				return null;
+			}
+        } else if(stack == CORNERSTONE_STACK) {
+			//Cornerstone
+			targetStack = mCornerstoneStack;
+        } else if(stack == MAIN_STACK || stack == NO_STACK) {
+			//Main stack or Unknown
+            targetStack = mMainStack;
+        }
+        ActivityRecord r = targetStack.isInStackLocked(token);
         if (r == null) {
             return null;
         }
@@ -4348,7 +5534,30 @@ public final class ActivityManagerService extends ActivityManagerNative
 
     public ComponentName getActivityClassForToken(IBinder token) {
         synchronized(this) {
-            ActivityRecord r = mMainStack.isInStackLocked(token);
+            /**
+             * Author: Onskreen
+             * Date: 27/01/2011
+             *
+             * Choosing between stacks
+             */
+			int stack = getActivityStack(token);
+			ActivityStack targetStack = null;
+			//Cornerstone Panel
+			if(stack >= 0) {
+				if(stack < mCornerstonePanelStacks.size()) {
+					targetStack = mCornerstonePanelStacks.get(stack);
+				} else {
+					Log.e(TAG, "Found in Non-Existent Stack");
+					return null;
+				}
+			} else if(stack == CORNERSTONE_STACK) {
+				//Cornerstone
+				targetStack = mCornerstoneStack;
+			} else if(stack == MAIN_STACK || stack == NO_STACK) {
+				//Main stack or Unknown
+				targetStack = mMainStack;
+			}
+            ActivityRecord r = targetStack.isInStackLocked(token);
             if (r == null) {
                 return null;
             }
@@ -4357,8 +5566,31 @@ public final class ActivityManagerService extends ActivityManagerNative
     }
 
     public String getPackageForToken(IBinder token) {
+        /**
+         * Author: Onskreen
+         * Date: 27/01/2011
+         *
+         * Choosing between stacks
+         */
+        int stack = getActivityStack(token);
+        ActivityStack targetStack = null;
+        //Cornerstone Panel
+        if(stack >= 0) {
+			if(stack < mCornerstonePanelStacks.size()) {
+				targetStack = mCornerstonePanelStacks.get(stack);
+			} else {
+				Log.e(TAG, "Found in Non-Existent Stack");
+				return null;
+			}
+        } else if(stack == CORNERSTONE_STACK) {
+			//Cornerstone
+			targetStack = mCornerstoneStack;
+        } else if(stack == MAIN_STACK || stack == NO_STACK) {
+			//Main stack or Unknown
+            targetStack = mMainStack;
+        }
         synchronized(this) {
-            ActivityRecord r = mMainStack.isInStackLocked(token);
+            ActivityRecord r = targetStack.isInStackLocked(token);
             if (r == null) {
                 return null;
             }
@@ -4438,7 +5670,30 @@ public final class ActivityManagerService extends ActivityManagerNative
             Slog.v(TAG_MU, "getIntentSenderLocked(): uid=" + callingUid);
         ActivityRecord activity = null;
         if (type == ActivityManager.INTENT_SENDER_ACTIVITY_RESULT) {
-            activity = mMainStack.isInStackLocked(token);
+             /**
+              * Author: Onskreen
+              * Date: 27/01/2011
+              *
+              * Choosing between stacks
+              */
+			int stack = getActivityStack(token);
+			ActivityStack targetStack = null;
+			//Cornerstone Panel
+			if(stack >= 0) {
+				if(stack < mCornerstonePanelStacks.size()) {
+					targetStack = mCornerstonePanelStacks.get(stack);
+				} else {
+					Log.e(TAG, "Found in Non-Existent Stack");
+					return null;
+				}
+			} else if(stack == CORNERSTONE_STACK) {
+				//Cornerstone
+				targetStack = mCornerstoneStack;
+			} else if(stack == MAIN_STACK || stack == NO_STACK) {
+				//Main stack or Unknown
+				targetStack = mMainStack;
+			}
+            activity = targetStack.isInStackLocked(token);
             if (activity == null) {
                 return null;
             }
@@ -5416,11 +6671,17 @@ public final class ActivityManagerService extends ActivityManagerNative
         outInfo.foregroundAppThreshold = mProcessList.getMemLevel(
                 ProcessList.FOREGROUND_APP_ADJ);
     }
-    
+
     // =========================================================
     // TASK MANAGEMENT
     // =========================================================
 
+    /**
+     * Author: Onskreen
+     * Date: 27/01/2011
+     *
+     * Does not include cornerstone tasks. This shouldn't create a functional issue?
+     */
     public List getTasks(int maxNum, int flags,
                          IThumbnailReceiver receiver) {
         ArrayList list = new ArrayList();
@@ -5834,30 +7095,84 @@ public final class ActivityManagerService extends ActivityManagerNative
             final long origId = Binder.clearCallingIdentity();
             try {
                 TaskRecord tr = taskForIdLocked(task);
+                /**
+                 * Author: Onskreen
+                 * Date: 27/01/2011
+                 *
+                 * Choosing between stacks
+                 */
+                int stack = getActivityStack(task);
+                ActivityStack targetStack = null;
+                //Cornerstone Panel
+                if(stack >= 0) {
+					if(stack < mCornerstonePanelStacks.size()) {
+						targetStack = mCornerstonePanelStacks.get(stack);
+					} else {
+						Log.e(TAG, "Found in Non-Existent Stack");
+						return;
+					}
+                } else if(stack == CORNERSTONE_STACK) {
+					//Cornerstone
+					targetStack = mCornerstoneStack;
+                } else if(stack == MAIN_STACK || stack == NO_STACK) {
+					//Main stack or Unknown
+                    targetStack = mMainStack;
+                }
                 if (tr != null) {
+                    /**
+                     * Author: Onskreen
+                     * Date: 07/01/2012
+                     *
+                     * When the user switches via Recent Tasks Dialog, need to make sure
+                     * its safe to do so.
+                     */
+                    for (int i=targetStack.mHistory.size()-1; i>=0; i--) {
+                        ActivityRecord ar = (ActivityRecord)targetStack.mHistory.get(i);
+                        if (ar.task == tr) {
+							boolean okToProceed = isActivityPermittedToStart(ar.info, targetStack);
+							if(!okToProceed) {
+								//This is not safe, stop
+								return;
+							} else {
+								break;
+							}
+                        }
+                    }
                     if ((flags&ActivityManager.MOVE_TASK_NO_USER_ACTION) == 0) {
-                        mMainStack.mUserLeaving = true;
+                        targetStack.mUserLeaving = true;
                     }
                     if ((flags&ActivityManager.MOVE_TASK_WITH_HOME) != 0) {
                         // Caller wants the home activity moved with it.  To accomplish this,
                         // we'll just move the home task to the top first.
-                        mMainStack.moveHomeToFrontLocked();
+                        targetStack.moveHomeToFrontLocked();
                     }
-                    mMainStack.moveTaskToFrontLocked(tr, null, options);
+                    targetStack.moveTaskToFrontLocked(tr, null, options);
                     return;
                 }
-                for (int i=mMainStack.mHistory.size()-1; i>=0; i--) {
+                for (int i=targetStack.mHistory.size()-1; i>=0; i--) {
                     ActivityRecord hr = (ActivityRecord)mMainStack.mHistory.get(i);
                     if (hr.task.taskId == task) {
+                        /**
+                         * Author: Onskreen
+                         * Date: 07/01/2012
+                         *
+                         * When the user switches via Recent Tasks Dialog, need to make sure
+                         * its safe to do so.
+                         */
+						boolean okToProceed = isActivityPermittedToStart(hr.info, targetStack);
+						if(!okToProceed) {
+							//This is not safe, stop
+							return;
+						}
                         if ((flags&ActivityManager.MOVE_TASK_NO_USER_ACTION) == 0) {
-                            mMainStack.mUserLeaving = true;
+                            targetStack.mUserLeaving = true;
                         }
                         if ((flags&ActivityManager.MOVE_TASK_WITH_HOME) != 0) {
                             // Caller wants the home activity moved with it.  To accomplish this,
                             // we'll just move the home task to the top first.
-                            mMainStack.moveHomeToFrontLocked();
+                            targetStack.moveHomeToFrontLocked();
                         }
-                        mMainStack.moveTaskToFrontLocked(hr.task, null, options);
+                        targetStack.moveTaskToFrontLocked(hr.task, null, options);
                         return;
                     }
                 }
@@ -5871,17 +7186,39 @@ public final class ActivityManagerService extends ActivityManagerNative
     public void moveTaskToBack(int task) {
         enforceCallingPermission(android.Manifest.permission.REORDER_TASKS,
                 "moveTaskToBack()");
-
+        /**
+         * Author: Onskreen
+         * Date: 27/01/2011
+         *
+         * Choosing between stacks
+         */
+        int stack = getActivityStack(task);
+        ActivityStack targetStack = null;
+        //Cornerstone Panel
+        if(stack >= 0) {
+			if(stack < mCornerstonePanelStacks.size()) {
+				targetStack = mCornerstonePanelStacks.get(stack);
+			} else {
+				Log.e(TAG, "Found in Non-Existent Stack");
+				return;
+			}
+        } else if(stack == CORNERSTONE_STACK) {
+			//Cornerstone
+			targetStack = mCornerstoneStack;
+        } else if(stack == MAIN_STACK || stack == NO_STACK) {
+			//Main stack or Unknown
+            targetStack = mMainStack;
+        }
         synchronized(this) {
-            if (mMainStack.mResumedActivity != null
-                    && mMainStack.mResumedActivity.task.taskId == task) {
+            if (targetStack.mResumedActivity != null
+                    && targetStack.mResumedActivity.task.taskId == task) {
                 if (!checkAppSwitchAllowedLocked(Binder.getCallingPid(),
                         Binder.getCallingUid(), "Task to back")) {
                     return;
                 }
             }
             final long origId = Binder.clearCallingIdentity();
-            mMainStack.moveTaskToBackLocked(task, null);
+            targetStack.moveTaskToBackLocked(task, null);
             Binder.restoreCallingIdentity(origId);
         }
     }
@@ -5897,11 +7234,34 @@ public final class ActivityManagerService extends ActivityManagerNative
      */
     public boolean moveActivityTaskToBack(IBinder token, boolean nonRoot) {
         enforceNotIsolatedCaller("moveActivityTaskToBack");
+        /**
+         * Author: Onskreen
+         * Date: 27/01/2011
+         *
+         * Choosing between stacks
+         */
+        int stack = getActivityStack(token);
+        ActivityStack targetStack = null;
+        //Cornerstone Panel
+        if(stack >= 0) {
+			if(stack < mCornerstonePanelStacks.size()) {
+				targetStack = mCornerstonePanelStacks.get(stack);
+			} else {
+				Log.e(TAG, "Found in Non-Existent Stack");
+				return false;
+			}
+        } else if(stack == CORNERSTONE_STACK) {
+			//Cornerstone
+			targetStack = mCornerstoneStack;
+        } else if(stack == MAIN_STACK || stack == NO_STACK) {
+			//Main stack or Unknown
+            targetStack = mMainStack;
+        }
         synchronized(this) {
             final long origId = Binder.clearCallingIdentity();
             int taskId = getTaskForActivityLocked(token, !nonRoot);
             if (taskId >= 0) {
-                return mMainStack.moveTaskToBackLocked(taskId, null);
+                return targetStack.moveTaskToBackLocked(taskId, null);
             }
             Binder.restoreCallingIdentity(origId);
         }
@@ -5934,10 +7294,33 @@ public final class ActivityManagerService extends ActivityManagerNative
     }
 
     int getTaskForActivityLocked(IBinder token, boolean onlyRoot) {
-        final int N = mMainStack.mHistory.size();
+        /**
+         * Author: Onskreen
+         * Date: 27/01/2011
+         *
+         * Choosing between stacks
+         */
+        int stack = getActivityStack(token);
+        ActivityStack targetStack = null;
+        //Cornerstone Panel
+        if(stack >= 0) {
+			if(stack < mCornerstonePanelStacks.size()) {
+				targetStack = mCornerstonePanelStacks.get(stack);
+			} else {
+				Log.e(TAG, "Found in Non-Existent Stack");
+				return -1;
+			}
+        } else if(stack == CORNERSTONE_STACK) {
+			//Cornerstone
+			targetStack = mCornerstoneStack;
+        } else if(stack == MAIN_STACK || stack == NO_STACK) {
+			//Main stack or Unknown
+            targetStack = mMainStack;
+        }
+        final int N = targetStack.mHistory.size();
         TaskRecord lastTask = null;
         for (int i=0; i<N; i++) {
-            ActivityRecord r = (ActivityRecord)mMainStack.mHistory.get(i);
+            ActivityRecord r = (ActivityRecord)targetStack.mHistory.get(i);
             if (r.appToken == token) {
                 if (!onlyRoot || lastTask != r.task) {
                     return r.task.taskId;
@@ -5969,9 +7352,51 @@ public final class ActivityManagerService extends ActivityManagerNative
 
         //System.out.println("Send pending thumbnail: " + r);
 
+        /**
+         * Author: Onskreen
+         * Date: 27/01/2011
+         *
+         * Choosing between stacks. Use ActivityRecord if avaialble, otherwise token
+         */
+        ActivityStack targetStack = null;
+        if(r != null) {
+            int stack = getActivityStack(r);
+            //Cornerstone Panel
+            if(stack >= 0) {
+				if(stack < mCornerstonePanelStacks.size()) {
+					targetStack = mCornerstonePanelStacks.get(stack);
+				} else {
+					Log.e(TAG, "Found in Non-Existent Stack");
+					return;
+				}
+            } else if(stack == CORNERSTONE_STACK) {
+				//Cornerstone
+				targetStack = mCornerstoneStack;
+            } else if(stack == MAIN_STACK || stack == NO_STACK) {
+				//Main stack or Unknown
+                targetStack = mMainStack;
+            }
+        } else {
+            int stack = getActivityStack(token);
+            //Cornerstone Panel
+            if(stack >= 0) {
+				if(stack < mCornerstonePanelStacks.size()) {
+					targetStack = mCornerstonePanelStacks.get(stack);
+				} else {
+					Log.e(TAG, "Found in Non-Existent Stack");
+					return;
+				}
+            } else if(stack == CORNERSTONE_STACK) {
+				//Cornerstone
+				targetStack = mCornerstoneStack;
+            } else if(stack == MAIN_STACK || stack == NO_STACK) {
+				//Main stack or Unknown
+                targetStack = mMainStack;
+            }
+        }
         synchronized(this) {
             if (r == null) {
-                r = mMainStack.isInStackLocked(token);
+                r = targetStack.isInStackLocked(token);
                 if (r == null) {
                     return;
                 }
@@ -6821,6 +8246,13 @@ public final class ActivityManagerService extends ActivityManagerNative
         return app;
     }
 
+    /**
+     * Author: Onskreen
+     * Date: 27/01/2011
+     *
+     * Leaving as only applied to main stack. Not clear how this would
+     * apply to cornerstone.
+     */
     public void unhandledBack() {
         enforceCallingPermission(android.Manifest.permission.FORCE_BACK,
                 "unhandledBack()");
@@ -6890,7 +8322,15 @@ public final class ActivityManagerService extends ActivityManagerNative
             if (!mSleeping) {
                 mSleeping = true;
                 mMainStack.stopIfSleepingLocked();
-
+                /**
+                 * Author: Onskreen
+                 * Date: 27/01/2011
+                 *
+                 * Mirroring in cornerstone. This might be an issue
+                 * as there can be more than one resumed activity in
+                 * cornerstone.
+                 */
+				mCornerstoneStack.stopIfSleepingLocked();
                 // Initialize the wake times of all processes.
                 checkExcessivePowerUsageLocked(false);
                 mHandler.removeMessages(CHECK_EXCESSIVE_WAKE_LOCKS_MSG);
@@ -6930,14 +8370,38 @@ public final class ActivityManagerService extends ActivityManagerNative
                     }
                 }
             }
+
+            /**
+             * Author: Onskreen
+             * Date: 27/01/2011
+             *
+             * Mirroring logic in cornerstone.
+             */
+            if (mCornerstoneStack.mResumedActivity != null) {
+                mCornerstoneStack.stopIfSleepingLocked();
+                final long endTime = System.currentTimeMillis() + timeout;
+                while (mCornerstoneStack.mResumedActivity != null
+                        || mCornerstoneStack.mPausingActivity != null) {
+                    long delay = endTime - System.currentTimeMillis();
+                    if (delay <= 0) {
+                        Slog.w(TAG, "Activity manager shutdown timed out");
+                        timedout = true;
+                        break;
+                    }
+                    try {
+                        this.wait();
+                    } catch (InterruptedException e) {
+                    }
+                }
+            }
         }
-        
+
         mUsageStatsService.shutdown();
         mBatteryStatsService.shutdown();
-        
+
         return timedout;
     }
-    
+
     public final void activitySlept(IBinder token) {
         if (localLOGV) Slog.v(
             TAG, "Activity slept: token=" + token);
@@ -6951,6 +8415,16 @@ public final class ActivityManagerService extends ActivityManagerNative
             if (r != null) {
                 mMainStack.activitySleptLocked(r);
             }
+            /**
+             * Author: Onskreen
+             * Date: 28/11/2011
+             *
+             * Mirroring logic in cornerstone.
+             */
+            r = mCornerstoneStack.isInStackLocked(token);
+            if (r != null) {
+                mCornerstoneStack.activitySleptLocked(r);
+            }
         }
 
         Binder.restoreCallingIdentity(origId);
@@ -6962,6 +8436,14 @@ public final class ActivityManagerService extends ActivityManagerNative
                 mSleeping = false;
                 mMainStack.awakeFromSleepingLocked();
                 mMainStack.resumeTopActivityLocked(null);
+                /**
+                 * Author: Onskreen
+                 * Date: 27/01/2011
+                 *
+                 * Mirroring logic in cornerstone.
+                 */
+				mCornerstoneStack.awakeFromSleepingLocked();
+				mCornerstoneStack.resumeTopActivityLocked(null);
             }
         }
     }
@@ -7167,6 +8649,17 @@ public final class ActivityManagerService extends ActivityManagerNative
                 throw new IllegalArgumentException();
             }
             r.immersive = immersive;
+            /**
+             * Author: Onskreen
+             * Date: 27/01/2011
+             *
+             * Mirroring logic in cornerstone.
+             */
+			r = mCornerstoneStack.isInStackLocked(token);
+            if (r == null) {
+                throw new IllegalArgumentException();
+            }
+            r.immersive = immersive;
         }
     }
 
@@ -7176,6 +8669,16 @@ public final class ActivityManagerService extends ActivityManagerNative
             if (r == null) {
                 throw new IllegalArgumentException();
             }
+            /**
+             * Author: Onskreen
+             * Date: 27/01/2011
+             *
+             * Mirroring logic in cornerstone.
+             */
+            r = mCornerstoneStack.isInStackLocked(token);
+            if (r == null) {
+                throw new IllegalArgumentException();
+            }
             return r.immersive;
         }
     }
@@ -7184,6 +8687,13 @@ public final class ActivityManagerService extends ActivityManagerNative
         enforceNotIsolatedCaller("startActivity");
         synchronized (this) {
             ActivityRecord r = mMainStack.topRunningActivityLocked(null);
+            /**
+             * Author: Onskreen
+             * Date: 27/01/2011
+             *
+             * Mirroring logic in cornerstone.
+             */
+			r = mCornerstoneStack.topRunningActivityLocked(null);
             return (r != null) ? r.immersive : false;
         }
     }
@@ -7651,6 +9161,16 @@ public final class ActivityManagerService extends ActivityManagerNative
             }
 
             mMainStack.resumeTopActivityLocked(null);
+
+            /**
+             * Author: Onskreen
+             * Date: 27/01/2011
+             *
+             * This would only be mirrored in cornerstone if Cornerstone Panel
+             * were launched at system start and kept alive like the HS
+             *
+             * mCornerstoneStack.resumeTopActivityLocked(null);
+             */
         }
     }
 
@@ -7752,6 +9272,20 @@ public final class ActivityManagerService extends ActivityManagerNative
                     r.stack.finishActivityLocked(r, i, Activity.RESULT_CANCELED, null, "crashed");
                 }
             }
+            /**
+             * Author: Onskreen
+             * Date: 27/01/2011
+             *
+             * Mirroring logic in cornerstone
+             */
+            for (int i=mCornerstoneStack.mHistory.size()-1; i>=0; i--) {
+                ActivityRecord r = (ActivityRecord)mCornerstoneStack.mHistory.get(i);
+                if (r.app == app) {
+                    Slog.w(TAG, "  Force finishing activity "
+                        + r.intent.getComponent().flattenToShortString());
+                    r.stack.finishActivityLocked(r, i, Activity.RESULT_CANCELED, null, "crashed");
+                }
+            }
             if (!app.persistent) {
                 // We don't want to start this process again until the user
                 // explicitly does so...  but for persistent process, we really
@@ -7772,9 +9306,23 @@ public final class ActivityManagerService extends ActivityManagerNative
                 // processes run critical code.
                 removeProcessLocked(app, false, false, "crash");
                 mMainStack.resumeTopActivityLocked(null);
+                /**
+                 * Author: Onskreen
+                 * Date: 28/11/2011
+                 *
+                 * Mirroring logic in cornerstone
+                 */
+                mCornerstoneStack.resumeTopActivityLocked(null);
                 return false;
             }
             mMainStack.resumeTopActivityLocked(null);
+            /**
+             * Author: Onskreen
+             * Date: 28/11/2011
+             *
+             * Mirroring logic in cornerstone
+             */
+            mCornerstoneStack.resumeTopActivityLocked(null);
         } else {
             ActivityRecord r = mMainStack.topRunningActivityLocked(null);
             if (r != null && r.app == app) {
@@ -7803,6 +9351,40 @@ public final class ActivityManagerService extends ActivityManagerNative
                     }
                 }
             }
+
+            /**
+             * Author: Onskreen
+             * Date: 27/01/2011
+             *
+             * Mirroring logic in cornerstone
+             */
+            ActivityRecord r_c = mCornerstoneStack.topRunningActivityLocked(null);
+            if (r_c!=null && r_c.app == app) {
+                // If the top running activity is from this crashing
+                // process, then terminate it to avoid getting in a loop.
+                Slog.w(TAG, "  Force finishing activity "
+                        + r_c.intent.getComponent().flattenToShortString());
+                int index = mCornerstoneStack.indexOfTokenLocked(r.appToken.asBinder());
+                r_c.stack.finishActivityLocked(r, index,
+                        Activity.RESULT_CANCELED, null, "crashed");
+                // Also terminate any activities below it that aren't yet
+                // stopped, to avoid a situation where one will get
+                // re-start our crashing activity once it gets resumed again.
+                index--;
+                if (index >= 0) {
+                    r = (ActivityRecord)mCornerstoneStack.mHistory.get(index);
+                    if (r_c.state == ActivityState.RESUMED
+                            || r_c.state == ActivityState.PAUSING
+                            || r_c.state == ActivityState.PAUSED) {
+                        if (!r_c.isHomeActivity || mHomeProcess != r.app) {
+                            Slog.w(TAG, "  Force finishing activity "
+                                    + r_c.intent.getComponent().flattenToShortString());
+                            r_c.stack.finishActivityLocked(r, index,
+                                    Activity.RESULT_CANCELED, null, "crashed");
+                        }
+                    }
+                }
+            }
         }
 
         // Bump up the crash count of any services currently running in the proc.
@@ -12023,7 +13605,30 @@ public final class ActivityManagerService extends ActivityManagerNative
 
             ActivityRecord activity = null;
             if (token != null) {
-                activity = mMainStack.isInStackLocked(token);
+                /**
+                 * Author: Onskreen
+                 * Date: 27/01/2011
+                 *
+                 * Choosing between stacks
+                 */
+                int stack = getActivityStack(token);
+                ActivityStack targetStack = null;
+                //Cornerstone Panel
+                if(stack >= 0) {
+                    if(stack < mCornerstonePanelStacks.size()) {
+                        targetStack = mCornerstonePanelStacks.get(stack);
+                    } else {
+                        Log.e(TAG, "Found in Non-Existent Stack");
+                        return -1;
+                    }
+                } else if(stack == CORNERSTONE_STACK) {
+                    //Cornerstone
+                    targetStack = mCornerstoneStack;
+                } else if(stack == MAIN_STACK || stack == NO_STACK) {
+                    //Main stack or Unknown
+                    targetStack = mMainStack;
+                }
+                activity = targetStack.isInStackLocked(token);
                 if (activity == null) {
                     Slog.w(TAG, "Binding with unknown activity: " + token);
                     return 0;
@@ -13486,6 +15090,258 @@ public final class ActivityManagerService extends ActivityManagerNative
     }
 
     /**
+     * Author: Onskreen
+     * Date: 09/06/2011
+     *
+     * Force the specified ActivityStack to reconfig itself. The purpose of this method as opposed to
+     * using updateConfigurationLocked is we avoid sending every process a new config here since
+     * this is used in cases that are system wide.
+     */
+    public void forceConfigurationLocked(ActivityStack stack, WindowManagerService.Cornerstone_State csState) {
+            Configuration newConfig = new Configuration(mConfiguration);
+            if (DEBUG_SWITCH || DEBUG_CONFIGURATION) {
+                Slog.i(TAG, "Forcing configuration on: " + stack);
+            }
+
+            mConfigurationSeq++;
+            if (mConfigurationSeq <= 0) {
+                mConfigurationSeq = 1;
+            }
+            newConfig.seq = mConfigurationSeq;
+            mConfiguration = newConfig;
+            Slog.i(TAG, "Config forced to change: " + newConfig);
+
+            final Configuration configCopy = new Configuration(mConfiguration);
+
+            AttributeCache ac = AttributeCache.instance();
+            if (ac != null) {
+                ac.updateConfiguration(configCopy);
+            }
+
+            /**
+             * Do this only for the processes in the specified stack
+             */
+            for(ActivityRecord ar: stack.mHistory) {
+                ProcessRecord app = ar.app;
+                try {
+                    if (app.thread != null) {
+                        /**
+                         * Author: Onskreen
+                         * Date: 26/12/2011
+                         *
+                         * Have to send WP specific configs in cases where the process has activities in a WP. In case
+                         * where the process holds system level apps, the standard config is set.
+                         *
+                         * CONFIG-TODO - same problem, how do we appropriately update here?
+                         */
+                         ActivityRecord matchingActivity = matchActivityWithProcess(app);
+                         if(matchingActivity!=null) {
+                            Configuration wpConfigWithChanges = mWindowManager.computeWindowPanelConfiguration(configCopy, matchingActivity.appToken, csState);
+                            if (DEBUG_CONFIGURATION) Slog.v(TAG, "Sending to proc "
+                                    + app.processName + " new config " + wpConfigWithChanges);
+                            app.thread.scheduleConfigurationChanged(wpConfigWithChanges);
+                         } else {
+                            if (DEBUG_CONFIGURATION) Slog.v(TAG, "Sending to proc "
+                                    + app.processName + " new config " + configCopy);
+                            app.thread.scheduleConfigurationChanged(configCopy);
+                        }
+                    }
+                } catch (Exception e) {
+                }
+            }
+
+            Intent intent = new Intent(Intent.ACTION_CONFIGURATION_CHANGED);
+            intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY
+                    | Intent.FLAG_RECEIVER_REPLACE_PENDING);
+            broadcastIntentLocked(null, null, intent, null, null, 0, null, null,
+                    null, false, false, MY_PID, Process.SYSTEM_UID, 0 /* TODO: Verify */);
+
+            /**
+             * Author: Onskreen
+             * Date: 26/12/2011
+             *
+             * ActivityStack.ensureActivityConfigurationLocked calculates changes on its own now
+             */
+            ActivityRecord starting = stack.topRunningActivityLocked(null);
+            if (starting != null) {
+				//Configuration wpConfigWithChanges = mWindowManager.computeWindowPanelConfiguration(config, starting.appToken, csState);
+				//Configuration wpConfigWithoutChanges = new Configuration(mWindowManager.computeWindowPanelConfiguration(WindowManagerService.WP_Panel.CORNERSTONE));
+				//int wpChanges = wpConfigWithoutChanges.updateFrom(wpConfigWithChanges);
+
+//              boolean kept = stack.ensureActivityConfigurationLocked(starting, wpChanges);
+                boolean kept = stack.ensureActivityConfigurationLocked(starting, 0);
+                if (kept) {
+                    // If this didn't result in the starting activity being
+                    // destroyed, then we need to make sure at this point that all
+                    // other activities are made visible.
+                  if (DEBUG_SWITCH) Slog.i(TAG, "Config didn't destroy " + starting
+                    + ", ensuring others are correct.");
+                      //stack.ensureActivitiesVisibleLocked(starting, wpChanges);
+                      stack.ensureActivitiesVisibleLocked(starting, 0);
+                  }
+            }
+
+            if (mWindowManager != null) {
+                mWindowManager.setNewConfiguration(mConfiguration);
+            }
+
+    }
+
+    /**
+     * Author: Onskreen
+     * Date: 05/01/2012
+     *
+     * Overload to act on a specific process to force the config for the given WindowPanel on the
+     * given ProcessRecord. Assumes using the current mCornerstone state
+     */
+    public void forceConfigurationLocked(ActivityStack stack, ProcessRecord app) {
+        if (false) {
+            for (SparseArray<ProcessRecord> procs : mProcessNames.getMap().values()) {
+                final int NA = procs.size();
+                for (int ia=0; ia<NA; ia++) {
+                    ProcessRecord r = procs.valueAt(ia);
+                    Slog.v(TAG, "PackageName: " + r.info.packageName);
+                    Slog.v(TAG, "Process Name: " + r.processName);
+                    Slog.v(TAG, "Activities: ");
+                    for(ActivityRecord ar: r.activities) {
+                        Slog.v(TAG, "\t" + ar);
+                    }
+                    Slog.v(TAG, "PID: " + r.pid);
+                    Slog.v(TAG, "Package List: ");
+                    for(String str: r.pkgList) {
+                        Slog.v(TAG, "\t" + str);
+                    }
+                    Slog.v(TAG, "SystemNoUI: " + r.systemNoUi);
+                    Slog.v(TAG, "ApplicationInfo.Uid: " + r.info.uid);
+
+                }
+            }
+        }
+
+        Configuration newConfig = new Configuration(mConfiguration);
+        if (DEBUG_SWITCH || DEBUG_CONFIGURATION) {
+            Slog.i(TAG, "Forcing configuration on: " + stack + " and Process: " + app);
+        }
+
+        mConfigurationSeq++;
+        if (mConfigurationSeq <= 0) {
+            mConfigurationSeq = 1;
+        }
+        newConfig.seq = mConfigurationSeq;
+        mConfiguration = newConfig;
+        Slog.i(TAG, "Config forced to change: " + newConfig);
+
+        final Configuration configCopy = new Configuration(mConfiguration);
+
+        AttributeCache ac = AttributeCache.instance();
+        if (ac != null) {
+            ac.updateConfiguration(configCopy);
+        }
+
+        try {
+            if (app.thread != null) {
+				//Default to main panel
+				WindowManagerService.WP_Panel panel = WindowManagerService.WP_Panel.MAIN_PANEL;
+				if(stack.mMainStack) {
+					panel = WindowManagerService.WP_Panel.MAIN_PANEL;
+				} else if(stack.mCornerstoneStack) {
+					panel = WindowManagerService.WP_Panel.CORNERSTONE;
+				} else if(stack.mCornerstonePanelStack) {
+					if(stack.mCornerstonePanelIndex == 0) {
+						panel = WindowManagerService.WP_Panel.CS_APP_0;
+					} else if(stack.mCornerstonePanelIndex == 1) {
+						panel = WindowManagerService.WP_Panel.CS_APP_1;
+					}
+				}
+				Configuration wpConfig = mWindowManager.computeWindowPanelConfiguration(panel);
+				mWindowManager.updateNonWindowPanelConfigurationFrom(wpConfig, mConfiguration);
+				if (DEBUG_CONFIGURATION) Slog.v(TAG, "Sending to proc "
+						+ app.processName + " new config " + wpConfig);
+				app.thread.scheduleConfigurationChanged(wpConfig);
+            }
+        } catch (Exception e) {
+        }
+
+        Intent intent = new Intent(Intent.ACTION_CONFIGURATION_CHANGED);
+        intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY
+                | Intent.FLAG_RECEIVER_REPLACE_PENDING);
+        broadcastIntentLocked(null, null, intent, null, null, 0, null, null,
+                null, false, false, MY_PID, Process.SYSTEM_UID, 0 /* TODO: Verify */);
+
+        ActivityRecord starting = stack.topRunningActivityLocked(null);
+        if (starting != null) {
+			boolean kept = stack.ensureActivityConfigurationLocked(starting, 0);
+            if (kept) {
+                // If this didn't result in the starting activity being
+                // destroyed, then we need to make sure at this point that all
+                // other activities are made visible.
+              if (DEBUG_SWITCH) Slog.i(TAG, "Config didn't destroy " + starting
+                + ", ensuring others are correct.");
+				//stack.ensureActivitiesVisibleLocked(starting, wpChanges);
+                  stack.ensureActivitiesVisibleLocked(starting, 0);
+              }
+        }
+
+        if (mWindowManager != null) {
+            mWindowManager.setNewConfiguration(mConfiguration);
+        }
+
+    }
+
+    /**
+     * Author: Onskreen
+     * Date: 05/01/2012
+     *
+     * Match a ProcessRecord with an Activity either running in it or best match of what will be running in it.
+     * Returns null if no matches exist.
+     */
+    private ActivityRecord matchActivityWithProcess(ProcessRecord app) {
+		//Activity running in the app is obvious.
+        if(!app.activities.isEmpty()) {
+			for(ActivityRecord ar: app.activities) {
+				if(ar.state == ActivityState.RESUMED) {
+					return ar;
+				}
+			}
+			//None were in the RESUMED state, just return the first
+			return app.activities.get(0);
+        }
+
+        //Match for activities that have not yet been attached to the process
+		int appUid = app.info.uid;
+		String appPackageName = app.info.packageName;
+
+		//Activity has not been attached to the process
+		//Main Stack
+		for(ActivityRecord ar: mMainStack.mHistory) {
+			if(ar.info.applicationInfo.uid == appUid &&
+					ar.info.packageName == appPackageName) {
+				return ar;
+			}
+		}
+		//CS Panel Stacks
+        for(ActivityStack as: mCornerstonePanelStacks) {
+			for(ActivityRecord ar: as.mHistory) {
+				if(ar.info.applicationInfo.uid == appUid &&
+						ar.info.packageName == appPackageName) {
+					return ar;
+				}
+			}
+        }
+
+        //Cornerstone Stack
+		for(ActivityRecord ar: mCornerstoneStack.mHistory) {
+			if(ar.info.applicationInfo.uid == appUid &&
+					ar.info.packageName == appPackageName) {
+				return ar;
+			}
+		}
+
+		//No matches, return null
+		return null;
+    }
+
+    /**
      * Do either or both things: (1) change the current configuration, and (2)
      * make sure the given activity is running with the (now) current
      * configuration.  Returns true if the activity has been left running, or
@@ -13551,14 +15407,33 @@ public final class ActivityManagerService extends ActivityManagerNative
                     msg.obj = new Configuration(configCopy);
                     mHandler.sendMessage(msg);
                 }
-        
+
                 for (int i=mLruProcesses.size()-1; i>=0; i--) {
                     ProcessRecord app = mLruProcesses.get(i);
                     try {
                         if (app.thread != null) {
-                            if (DEBUG_CONFIGURATION) Slog.v(TAG, "Sending to proc "
+                            /**
+                             * Author: Onskreen
+                             * Date: 26/12/2011
+                             *
+                             * Have to send WP specific configs in cases where the process has activities in a WP. In case
+                             * where the process holds system level apps, the standard config is set.
+                             *
+                             */
+							ActivityRecord matchingActivity = matchActivityWithProcess(app);
+							if(matchingActivity!=null) {
+								Configuration wpConfigWithChanges = mWindowManager.computeWindowPanelConfiguration(configCopy, matchingActivity.appToken, mWindowManager.mCornerstoneState);
+                                if (DEBUG_CONFIGURATION) Slog.v(TAG, "Sending to proc "
+                                        + app.processName + " new config " + wpConfigWithChanges);
+                                app.thread.scheduleConfigurationChanged(wpConfigWithChanges);
+                            }  else {
+                                if (DEBUG_CONFIGURATION) Slog.v(TAG, "Sending to proc "
+                                        + app.processName + " new config " + mConfiguration);
+                                app.thread.scheduleConfigurationChanged(configCopy);
+                            }
+                            /*if (DEBUG_CONFIGURATION) Slog.v(TAG, "Sending to proc "
                                     + app.processName + " new config " + mConfiguration);
-                            app.thread.scheduleConfigurationChanged(configCopy);
+                            app.thread.scheduleConfigurationChanged(configCopy);*/
                         }
                     } catch (Exception e) {
                     }
@@ -13576,25 +15451,100 @@ public final class ActivityManagerService extends ActivityManagerNative
                 }
             }
         }
-        
-        if (changes != 0 && starting == null) {
+
+        if (changes != 0 /*&& starting == null*/) {
             // If the configuration changed, and the caller is not already
             // in the process of starting an activity, then find the top
             // activity to check if its configuration needs to change.
-            starting = mMainStack.topRunningActivityLocked(null);
-        }
-        
-        if (starting != null) {
+            //starting = mMainStack.topRunningActivityLocked(null);
+            /**
+             * Author: Onskreen
+             * Date: 26/12/2011
+             *
+             * At this pont mConfiguration contains the changes. Changes below ensures that wpconfig has the wp specific settings
+             *  and the mconfiguraiton values also. Then we can diff them to get the changes.
+             */
+            // Cornerstone Stack
+            ActivityRecord csStarting = mCornerstoneStack.topRunningActivityLocked(null);
+            if (csStarting != null) {
+				Configuration wpConfigWithChanges = mWindowManager.computeWindowPanelConfiguration(mConfiguration, csStarting.appToken, mWindowManager.mCornerstoneState);
+				Configuration wpConfigWithoutChanges = new Configuration(mWindowManager.computeWindowPanelConfiguration(WindowManagerService.WP_Panel.CORNERSTONE));
+				int wpChanges = wpConfigWithoutChanges.updateFrom(wpConfigWithChanges);
+
+                //kept = mCornerstoneStack.ensureActivityConfigurationLocked(starting, changes);
+				kept = mCornerstoneStack.ensureActivityConfigurationLocked(csStarting, wpChanges);
+                if (kept) {
+                  if (DEBUG_SWITCH) Slog.i(TAG, "Config distartingdn't destroy " + csStarting
+                    + ", ensuring otstartingFoundInWPStackhers are correct.");
+                        //mCornerstoneStack.ensureActivitiesVisibleLocked(starting, changes);
+                        mCornerstoneStack.ensureActivitiesVisibleLocked(csStarting, wpChanges);
+                  }
+            }
+
+            // Cornerstone Panel Stack
+            for(int i = 0; i < mCornerstonePanelStacks.size(); i ++) {
+                ActivityStack targetStack = mCornerstonePanelStacks.get(i);
+                ActivityRecord csPanelStarting = targetStack.topRunningActivityLocked(null);
+                if (csPanelStarting != null) {
+					Configuration wpConfigWithChanges = mWindowManager.computeWindowPanelConfiguration(mConfiguration, csPanelStarting.appToken, mWindowManager.mCornerstoneState);
+					Configuration wpConfigWithoutChanges = null;
+					if(i==0) {
+						wpConfigWithoutChanges= new Configuration(mWindowManager.computeWindowPanelConfiguration(WindowManagerService.WP_Panel.CS_APP_0));
+					} else {
+						wpConfigWithoutChanges= new Configuration(mWindowManager.computeWindowPanelConfiguration(WindowManagerService.WP_Panel.CS_APP_1));
+					}
+					int wpChanges = wpConfigWithoutChanges.updateFrom(wpConfigWithChanges);
+
+					//kept = targetStack.ensureActivityConfigurationLocked(starting, changes);
+					kept = targetStack.ensureActivityConfigurationLocked(csPanelStarting, wpChanges);
+                    if (kept) {
+                      if (DEBUG_SWITCH) Slog.i(TAG, "Config didn't destroy " + csPanelStarting
+                        + ", ensuring others are correct.");
+                        //targetStack.ensureActivitiesVisibleLocked(starting, changes);
+                      targetStack.ensureActivitiesVisibleLocked(csPanelStarting, wpChanges);
+                     }
+                 }
+            }
+            // Main Panel Stack
+            ActivityRecord mainStarting = mMainStack.topRunningActivityLocked(null);
+            if (mainStarting != null) {
+				Configuration wpConfigWithChanges = mWindowManager.computeWindowPanelConfiguration(mConfiguration, mainStarting.appToken, mWindowManager.mCornerstoneState);
+				Configuration wpConfigWithoutChanges = new Configuration(mWindowManager.computeWindowPanelConfiguration(WindowManagerService.WP_Panel.MAIN_PANEL));
+				int wpChanges = wpConfigWithoutChanges.updateFrom(wpConfigWithChanges);
+
+				kept = mMainStack.ensureActivityConfigurationLocked(mainStarting, wpChanges);
+				//kept = mMainStack.ensureActivityConfigurationLocked(starting, changes);
+                if (kept) {
+                    // If this didn't result in the starting activity being
+                    // destroyed, then we need to make sure at this point that all
+                    // other activities are made visible.
+                  if (DEBUG_SWITCH) Slog.i(TAG, "Config didn't destroy " + mainStarting
+                    + ", ensuring others are correct.");
+                    //mMainStack.ensureActivitiesVisibleLocked(starting, changes);
+                      mMainStack.ensureActivitiesVisibleLocked(mainStarting, wpChanges);
+                }
+            }
+
+            //Non-WindowPanel
+            /**if (!startingFoundInWPStack && starting != null) {
+                kept = mMainStack.ensureActivityConfigurationLocked(starting, changes);
+                // And we need to make sure at this point that all other activities
+                // are made visible with the correct configuration.
+                mMainStack.ensureActivitiesVisibleLocked(starting, changes);
+            }**/
+        }
+
+        /*if (starting != null) {
             kept = mMainStack.ensureActivityConfigurationLocked(starting, changes);
             // And we need to make sure at this point that all other activities
             // are made visible with the correct configuration.
             mMainStack.ensureActivitiesVisibleLocked(starting, changes);
-        }
-        
+        }*/
+
         if (values != null && mWindowManager != null) {
             mWindowManager.setNewConfiguration(mConfiguration);
         }
-        
+
         return kept;
     }
 
@@ -14670,6 +16620,12 @@ public final class ActivityManagerService extends ActivityManagerNative
         return success;
     }
 
+    /**
+     * Author: Onskreen
+     * Date: 27/01/2011
+     *
+     * Used by OOM logic. Leave only applicable to main stack records for now
+     */
     private final ActivityRecord resumedAppLocked() {
         ActivityRecord resumedActivity = mMainStack.mResumedActivity;
         if (resumedActivity == null || resumedActivity.app == null) {
@@ -15349,4 +17305,850 @@ public final class ActivityManagerService extends ActivityManagerNative
             return map;
         }
     }
+
+    /**
+     * Author: Onskreen
+     * Date: 15/02/2010
+     *
+     * Switch the topmost task of the indicated cornerstone panel and the main panel
+     *
+     * @param panelIndex The panel index being swapped with the main panel.
+     */
+    public void swapPanels(int panelIndex) {
+		//TODO have to create and enforce a custom permission that only cs apps have.
+        //enforceCallingPermission(android.Manifest.permission.XXX, "moveActivityTaskToMainPanel()");
+
+		//Get Cornerstone Panel Tasks to be moved
+		ActivityStack panelStack = mCornerstonePanelStacks.get(panelIndex);
+		ArrayList<ActivityRecord> csPanelActivitiesToMove;
+		ArrayList<IBinder> csPanelTokensToMove = new ArrayList<IBinder>();
+
+        if(DEBUG_CORNERSTONE) {
+			Log.v(TAG, "Swap Panel: Start");
+        }
+
+		//Check that topmost Activity Record is not the Cornerstone Launcher
+		ActivityRecord topMostCSPanelActivity = panelStack.mResumedActivity;
+
+        /**
+         * Author: Onskreen
+         * Date: 11/08/2011
+         *
+         * Compares the top cs activity packageName with cornerstone packageName
+         * and resolves the issue of string comparison causing swapping the cslauncher
+         * from cs panel to main panel and vice-versa.
+         *
+         */
+		if(topMostCSPanelActivity == null || (topMostCSPanelActivity.packageName != null &&
+                topMostCSPanelActivity.packageName.equals(mCornerstoneLauncherAppPackageName))) {
+            if(DEBUG_CORNERSTONE) {
+                Log.v(TAG, "CS Panel: Null or Cornerstone Launcher\tSkipping");
+            }
+            //List of activities should be empty
+			csPanelActivitiesToMove = new ArrayList<ActivityRecord>();
+		} else {
+			//csPanelActivitiesToMove = new ArrayList<ActivityRecord>(panelStack.mHistory);
+			csPanelActivitiesToMove = new ArrayList<ActivityRecord>();
+			/**
+             * Author: Onskreen
+             * Date: 26/09/2011
+             *
+             * When cornerstone launcher is available in either of cs panels,
+             * don't move the CSLauncher token to main panel while swapping.
+             */
+			for (int i=0; i< panelStack.mHistory.size(); i++) {
+                ActivityRecord r = (ActivityRecord)panelStack.mHistory.get(i);
+                if(r.packageName != null && !r.packageName.equals(mCornerstoneLauncherAppPackageName)) {
+                    csPanelActivitiesToMove.add(r);
+                }
+            }
+			for (int i=0; i<csPanelActivitiesToMove.size(); i++) {
+				csPanelTokensToMove.add(csPanelActivitiesToMove.get(i).appToken.asBinder());
+			}
+		}
+
+        //Get Main Panel Tasks to be moved
+		//Compile a z-ordered list of activityrecords to move from the main panel
+        final int N = mMainStack.mHistory.size();
+        ArrayList<ActivityRecord> mainPanelActivitiesToMove = new ArrayList<ActivityRecord>();
+        int taskId = -1;
+        boolean top = true;
+        for (int i=N-1; i>=0; i--) {
+            ActivityRecord r = (ActivityRecord)mMainStack.mHistory.get(i);
+            //Ignore the home activity, can't swap
+            if(top && r.isHomeActivity) {
+                if(DEBUG_CORNERSTONE) {
+					Log.v(TAG, "Main Panel: Launcher\tSkipping");
+                }
+                break;
+            } else if(top) {
+                //First one make note of task id and add to list
+				taskId = r.task.taskId;
+				top = false;
+				mainPanelActivitiesToMove.add(r);
+            } else if(r.task.taskId == taskId) {
+				//Add any activities of the same task
+				mainPanelActivitiesToMove.add(0, r);
+            } else {
+				//When reached another task stop searching
+				break;
+            }
+        }
+        ArrayList<IBinder> mainPanelTokensToMove = new ArrayList<IBinder>();
+        for(int i=0; i<mainPanelActivitiesToMove.size(); i++) {
+           mainPanelTokensToMove.add(mainPanelActivitiesToMove.get(i).appToken.asBinder());
+        }
+
+        //Determine which panels have tokens that are being swapped.
+        boolean onlyMovingMainPanel, onlyMovingCSPanel, movingBothPanels;
+        //Case: Only Moving Main Panel Tokens
+        if(!mainPanelActivitiesToMove.isEmpty() && csPanelActivitiesToMove.isEmpty()) {
+			onlyMovingMainPanel = true;
+			onlyMovingCSPanel = false;
+			movingBothPanels = false;
+            if(DEBUG_CORNERSTONE) {
+				Log.v(TAG, "Case: Only moving tokens from main to cs panel");
+            }
+        } else if(mainPanelActivitiesToMove.isEmpty() && !csPanelActivitiesToMove.isEmpty()) {
+            //Case: Only Moving CS Panel Tokens
+			onlyMovingMainPanel = false;
+			onlyMovingCSPanel = true;
+			movingBothPanels = false;
+            if(DEBUG_CORNERSTONE) {
+				Log.v(TAG, "Case: Only moving tokens from cs to main panel");
+            }
+        } else if(mainPanelActivitiesToMove.isEmpty() && csPanelActivitiesToMove.isEmpty()) {
+            //Case: Not Moving Any Tokens
+            if(DEBUG_CORNERSTONE) {
+				Log.v(TAG, "Case: No tokens to swap");
+            }
+            /*
+             * Author: Onskreen
+             * Date: 09/08/2011
+             *
+             * Notifies the CSPanel to change the swap control's state.
+             */
+            String pkg = "";
+            if(topMostCSPanelActivity!=null) {
+                pkg = topMostCSPanelActivity.packageName;
+                if(pkg != null) {
+                    broadcastCornerstonePanelFocusChanged(pkg, true, panelIndex);
+                }
+            }
+			return;
+        } else {
+			//Case: Swapping between both panels
+			onlyMovingMainPanel = false;
+			onlyMovingCSPanel = false;
+			movingBothPanels = true;
+            if(DEBUG_CORNERSTONE) {
+				Log.v(TAG, "Case: Swapping tokens from both main and cs panels");
+            }
+        }
+
+        if(DEBUG_CORNERSTONE) {
+			Log.v(TAG, "Tokens To Swap");
+			if(onlyMovingMainPanel || movingBothPanels) {
+				Log.v(TAG, "\tFrom: " + mMainStack.mStackName + " To: " + panelStack.mStackName);
+				for(int k=0; k<mainPanelActivitiesToMove.size(); k++) {
+					Log.v(TAG, "\t\t" + k + ": " + mainPanelActivitiesToMove.get(k));
+				}
+			}
+			if(onlyMovingCSPanel || movingBothPanels) {
+				Log.v(TAG, "\tFrom: " + panelStack.mStackName + " To: " + mMainStack.mStackName);
+				for(int k=0; k<csPanelActivitiesToMove.size(); k++) {
+					Log.v(TAG, "\t\t" + k + ": " + csPanelActivitiesToMove.get(k));
+				}
+			}
+        }
+
+        if(DEBUG_VISBILITY) logActivityStackState();
+        synchronized(this) {
+            final long origId = Binder.clearCallingIdentity();
+
+            /**
+             * Remove the tasks from their panels. After these are complete the ActivityRecords
+             * are not visible to the user and are not in any ActivityStack. They are held in memory
+             * in the AMS.
+             */
+            //Remove the tasks from the main panel
+            if(movingBothPanels || onlyMovingMainPanel) {
+                mMainStack.removeSetOfTasksLocked(mainPanelActivitiesToMove);
+            }
+            //Remove the tasks from the cornerstone
+            if(movingBothPanels || onlyMovingCSPanel) {
+                panelStack.removeSetOfTasksLocked(csPanelActivitiesToMove);
+            }
+
+            //Inform wms of changes so the frame is visually prepared before displayed
+            mWindowManager.executePanelSwap(panelIndex,
+					mainPanelTokensToMove,
+					csPanelTokensToMove,
+					!csPanelTokensToMove.isEmpty());
+
+            //Add the tokens to the main panel
+            if(movingBothPanels || onlyMovingCSPanel) {
+				mMainStack.addSetOfTasksLocked(csPanelActivitiesToMove);
+            } else {
+				//There was no activity to move from cs to main panel.
+                if(DEBUG_CORNERSTONE) {
+					Log.v(TAG, "Not starting activity explicitly for main panel. Resume" +
+							" next top activity.");
+                }
+                //mMainStack.resumeTopActivityLocked(null);
+            }
+            //Add the tokens to the cs panel
+            if(movingBothPanels || onlyMovingMainPanel) {
+                panelStack.addSetOfTasksLocked(mainPanelActivitiesToMove);
+            } else {
+                startCornerstoneLauncherLocked(panelIndex);
+            }
+
+
+            /**
+             * Author: Onskreen
+             * Date: 03/05/2011
+             *
+             * Ensure that activities are in thier appropriate states
+             */
+//          panelStack.ensureActivitiesVisibleLocked(null, 0);
+//          mMainStack.ensureActivitiesVisibleLocked(null, 0);
+
+			/**
+             * Author: Onskreen
+             * Date: 24/12/2011
+             *
+             * Clean up recent tasks list.
+             * - Moved from Main Panel must be removed from recent tasks
+             * - Moved to Main Pane must be added to recent tasks
+             */
+			for(int i=0; i<mainPanelActivitiesToMove.size(); i++) {
+				ActivityRecord r = mainPanelActivitiesToMove.get(i);
+				removeRecentTaskLocked(r.task);
+			}
+			for(int i=0; i<csPanelActivitiesToMove.size(); i++) {
+				ActivityRecord r = csPanelActivitiesToMove.get(i);
+				addRecentTaskLocked(r.task);
+			}
+
+			//ONSKREEN-TEST
+			forceConfigurationLocked(mMainStack, WindowManagerService.Cornerstone_State.RUNNING_OPEN);
+			forceConfigurationLocked(panelStack, WindowManagerService.Cornerstone_State.RUNNING_OPEN);
+            Binder.restoreCallingIdentity(origId);
+		}
+        if(DEBUG_VISBILITY) logActivityStackState();
+        if(DEBUG_CORNERSTONE) {
+			Log.v(TAG, "After Panel Swap, Focused App: " + mWindowManager.getFocusedApp());
+        }
+    }
+
+
+    /**
+     * Author: Onskreen
+     * Data: 21/02/2010
+     *
+     * Manage cornerstone visibility. Right now pausing and resuming of the cornerstone activities
+     * is not implemented.
+     *
+     * TODO Enforce some custom permission so that only the cornerstone activity
+     * can call this.
+     *
+     * @param open Indicates whether cornerstone is open or not
+     */
+    public void setCornerstoneState(boolean open) {
+        final long origId = Binder.clearCallingIdentity();
+
+		//Hide the Cornerstone
+		if(!open) {
+			//Hide Cornerstone
+			mWindowManager.setCornerstoneState(WindowManagerService.Cornerstone_State.RUNNING_CLOSED);
+			//Pause the panel stacks
+			for(int i=0; i<mCornerstonePanelStacks.size(); i++) {
+				if(DEBUG_CORNERSTONE) {
+					Log.v(TAG, "Before Closing Cornerstone");
+					this.logActivityStackState();
+				}
+				ActivityStack stack = mCornerstonePanelStacks.get(i);
+				stack.mStackPaused = true;
+
+				try {
+					stack.startPausingLocked(true, false);
+				} catch(Exception e) {
+					e.printStackTrace();
+				}
+
+				if(DEBUG_CORNERSTONE) {
+					Log.v(TAG, "After Closing Cornerstone");
+					this.logActivityStackState();
+				}
+			}
+		} else {
+			for(int i=0; i<mCornerstonePanelStacks.size(); i++) {
+				if(DEBUG_CORNERSTONE) {
+					Log.v(TAG, "Before Opening Cornerstone");
+					this.logActivityStackState();
+				}
+				ActivityStack stack = mCornerstonePanelStacks.get(i);
+				stack.mStackPaused = false;
+				try {
+					stack.resumeTopActivityLocked(null);
+				} catch(Exception e) {
+					e.printStackTrace();
+				}
+			}
+			//Make the cornerstone visible
+			mWindowManager.setCornerstoneState(WindowManagerService.Cornerstone_State.RUNNING_OPEN);
+			if(DEBUG_CORNERSTONE) {
+				Log.v(TAG, "After Opening Cornerstone");
+				this.logActivityStackState();
+			}
+		}
+
+        /**
+         * Author: Onskreen
+         * Date: 10/06/2011
+         *
+         * Always transfer the focus to the top main panel activity whenever
+         * user opens/closes the cornerstone panel.
+         */
+		//Safety check in case something very bad happened in the main panel
+		if(mMainStack.mResumedActivity == null) {
+			mMainStack.resumeTopActivityLocked(null);
+		}
+		if(mMainStack.mResumedActivity != null) {
+			mWindowManager.handleFocusChange(mMainStack.mResumedActivity.appToken.asBinder());
+		}
+		/**
+         * Author: Onskreen
+         * Date: 26/12/2011
+         *
+         * Only the main panel config is actually changing. The CS Panels didn't have a config change,
+         * they are just now resumed and visible or paused and not visible.
+         */
+        if(DEBUG_CONFIGURATION) {
+			if(open) Slog.i(TAG, "State: Cornerstone Open\tAction: Config Main Panel");
+			else Slog.i(TAG, "State: Cornerstone Close\tAction: Config Main Panel");
+        }
+
+        WindowManagerService.Cornerstone_State csState;
+        if(open) csState = WindowManagerService.Cornerstone_State.RUNNING_OPEN;
+        else csState = WindowManagerService.Cornerstone_State.RUNNING_CLOSED;
+
+        //No longer re-config the main panel on cs state change
+        //Reconfig all the panels
+		//forceConfigurationLocked(mMainStack, csState);
+
+		//Technically, the Cornerstone should get a new configuration, but not getting it doesn't have an effect and saves sending new configs in these cases
+		//forceConfigurationLocked(mCornerstoneStack, csState);
+		/**for(ActivityStack as: mCornerstonePanelStacks) {
+			forceConfigurationLocked(as, csState);
+		}**/
+		Binder.restoreCallingIdentity(origId);
+
+    }
+
+   /**
+    * Author: Onskreen
+    * Date: 28/02/2011
+    *
+    * Sets the ICornerstoneManager interface, so that AMS can notify CSPanel app whenever CS app
+    * gains or loses the focus.
+    */
+    public void setCornerstoneManager(ICornerstoneManager manager) {
+		synchronized (this) {
+			final long origId = Binder.clearCallingIdentity();
+			mCornerstoneManager = manager;
+			Binder.restoreCallingIdentity(origId);
+        }
+    }
+
+   /**
+    * Author: Onskreen
+    * Date: 08/03/2011
+    *
+    * Launches the cornerstone app in the appropriate panel requested by the CSPanel app.
+    */
+    public void startCornerstoneApp(Intent intent, int panelIndex){
+        synchronized (this) {
+			final long origId = Binder.clearCallingIdentity();
+			ActivityInfo aInfo = intent.resolveActivityInfo(mContext.getPackageManager(),
+					STOCK_PM_FLAGS);
+			if (aInfo != null) {
+				intent.setComponent(new ComponentName(aInfo.applicationInfo.packageName, aInfo.name));
+				intent.setFlags(intent.getFlags() | Intent.FLAG_ACTIVITY_NEW_TASK);
+
+				//Security check in case this gets triggered before setup of the panel
+				//stacks is complete. In some cases at startup the CSLauncher can be
+				//requested to be started but the system isn't ready to start it. In
+				//these cases the panelIndex is -1.
+				if(mCornerstonePanelStacks.size() > panelIndex &&
+						panelIndex >= 0) {
+					ActivityStack targetStack = mCornerstonePanelStacks.get(panelIndex);
+					if(targetStack != null){
+						targetStack.startActivityLocked(null, intent, null, aInfo,
+							null, null, 0, 0, 0, 0, null, false, null);
+
+						/**
+                         * Author: Onskreen
+                         * Date: 08/03/2011
+                         *
+                         * Notifies CSPanel app to change the cs app header controls appropriately
+                         */
+						ComponentName cp = intent.getComponent();
+						if(cp != null){
+							String pkg = cp.getPackageName();
+							if(pkg != null){
+								broadcastCornerstonePanelFocusChanged(pkg, true, panelIndex);
+							}
+						}
+					}
+				/**
+                 * Author: Onskreen
+                 * Date: 13/07/2011
+                 *
+                 * Allows to launch the apps in main panel. Previously this method was restricted to launch only
+                 * apps in cornerstone panels.
+                 */
+                } else if(MAIN_STACK == panelIndex) {
+                    mMainStack.startActivityLocked(null, intent, null, aInfo,
+						null, null, 0, 0, 0, 0, null, false, null);
+                    mWindowManager.handleFocusChange(mMainStack.topRunningActivityLocked(null).appToken.asBinder());
+				} else {
+					if(DEBUG_CORNERSTONE) {
+						Log.w(TAG, "Tried to launch cornerstone panel app before cornerstone panel stacks are launched");
+					}
+				}
+			}
+			Binder.restoreCallingIdentity(origId);
+        }
+    }
+
+   /**
+    * Author: Onskreen
+    * Date: 11/04/2011
+    *
+    * Change the focus of cornerstone app in the requested panel
+    */
+    public void setCornerstoneFocusedApp(int panelIndex){
+        synchronized (this) {
+			final long origId = Binder.clearCallingIdentity();
+			try {
+				ActivityStack targetStack = null;
+				//Cornerstone Panel
+				if(panelIndex >= 0) {
+					if(panelIndex < mCornerstonePanelStacks.size()) {
+						targetStack = mCornerstonePanelStacks.get(panelIndex);
+					} else {
+						Log.e(TAG, "Found in Non-Existent Stack");
+						return;
+					}
+				}
+				if(targetStack != null && targetStack.mResumedActivity != null && targetStack.mResumedActivity.appToken != null){
+					mWindowManager.handleFocusChange(targetStack.mResumedActivity.appToken.asBinder());
+				}
+			} finally{
+				Binder.restoreCallingIdentity(origId);
+			}
+        }
+    }
+
+   /**
+     * Author: Onskreen
+     * Date: 28/02/2011
+     *
+     * WMS notifies to AMS to broadcst the CornerstoneManager's onCornerStonePanelFocusChanged
+     * method so that CSPanel changes the cs apps' controls appropriately.
+     */
+    public void broadcastCornerstonePanelFocusChanged(String pkgName, boolean focus, int panelIndex){
+		synchronized (this) {
+			final long origId = Binder.clearCallingIdentity();
+			if(mCornerstoneManager != null){
+				try{
+					mCornerstoneManager.onCornerstonePanelFocusChanged(pkgName, focus, panelIndex);
+				} catch(RemoteException e) {
+						e.printStackTrace();
+				}
+			}
+			Binder.restoreCallingIdentity(origId);
+		}
+    }
+
+    /**
+     * Author: Onskreen
+     * Date: 11/03/2011
+     *
+     * Start the Cornerstone Launcher in the specified CS Panel
+     */
+    boolean startCornerstoneLauncherLocked(int panelIndex) {
+		Intent intent = new Intent();
+        ComponentName cp = new ComponentName(mCornerstoneLauncherAppPackageName, mCornerstoneLauncherClassName);
+        intent.setComponent(cp);
+		startCornerstoneApp(intent, panelIndex);
+		return true;
+    }
+
+    /**
+     * Author: Onskreen
+     * Date: 24/01/2011
+     *
+     * Determines which stack an activity will be allocated to when launched. Make
+     * best assumptions based on the intent and resultTo and current state
+     * of the various stacks.
+     */
+    private int getActivityStack(Intent intent, IBinder resultTo) {
+
+		if(DEBUG_CORNERSTONE) {
+			Log.v(TAG, "Inspecting intent: " + intent + " resultTo: " + resultTo);
+			logActivityStackState();
+		}
+
+		if(intent.getComponent() != null) {
+			if(intent.getComponent().toString().contains(this.mCornerstoneAppPackageName)) {
+				if(DEBUG_CORNERSTONE) {
+					Log.v(TAG, "\tComponent identified as cornerstone");
+				}
+				return CORNERSTONE_STACK;
+			}
+		}
+
+        //Translate the resultTo to a record in an existing stack
+        ActivityRecord resultToActivityRecord = ActivityRecord.forToken(resultTo);
+
+        //Check the mainstack history
+        for (int i=mMainStack.mHistory.size()-1; i>=0; i--) {
+            Object o = mMainStack.mHistory.get(i);
+            if (o == resultToActivityRecord) {
+				if(DEBUG_CORNERSTONE) {
+					Log.v(TAG, "\tresultTo found in main stack");
+				}
+				return MAIN_STACK;
+            }
+        }
+
+        //search the cornerstone panels
+        for (int k=0; k<mCornerstonePanelStacks.size(); k++) {
+			ActivityStack currStack = mCornerstonePanelStacks.get(k);
+			for (int i=currStack.mHistory.size()-1; i>=0; i--) {
+                Object o = currStack.mHistory.get(i);
+                if (o == resultToActivityRecord) {
+					if(DEBUG_CORNERSTONE) {
+						Log.v(TAG, "\tresultTo found in cornerstone panel: " + k);
+					}
+					return k;
+                }
+			}
+        }
+
+        //If sending result to home, then assume belongs in main stack
+        if(resultToActivityRecord != null && resultToActivityRecord.isHomeActivity) {
+			return MAIN_STACK;
+        } else if(isCornerstone(resultToActivityRecord)) {
+            return mCornerstonePanelsCreated++;
+        }
+
+        /**
+         * Author: Onskreen
+         * Date: 26/12/2012
+         *
+         * In some cases, framework passes 'resultTo' as null and NO_STACK is
+         * being returned by getActivityStack. In such cases, getActivityStack
+         * method must consider the Intent.getPackage() and if that matches with
+         * any of the Activities running in Activity Stacks (Main or Cornerstone
+         * Panels), then appropriate Activity Stack is returned and calling
+         * Activity is not launched in Main Activity if it is suppose to be
+         * launched in Cornerstone Panel stacks.
+         */
+		if(resultToActivityRecord == null && resultTo == null && intent != null) {
+			String pkg = intent.getPackage();
+			/**
+             * Author: Onskreen
+             * Date: 25/01/2013
+             *
+             * Sometimes developers don't set the packageName while constructing
+             * Intent object but instead they set the packageName as ComponentName
+             * object. In such case, Intent.getPackage() is returned NULL. We should
+             * also check for ComponentName.getPackageName() and return the appropriate
+             * stack to the calling method.
+             */
+			if(pkg == null) {
+				ComponentName cp = intent.getComponent();
+				String data = intent.getDataString();
+				if(cp != null) {
+					pkg = cp.getPackageName();
+				} else if(data != null) {
+					/**
+                     * Author: Onskreen
+                     * Date: 01/02/2013
+                     *
+                     * When packageName can't be determined from Intent object
+                     * or from ComponentName, then it can be extracted from the
+                     * data string of Intent object. The data string normally
+                     * looks like as:
+                     *
+                     * file:///storage/sdcard0/Android/data/com.dropbox.android/
+                     * files/scratch/Getting%20Started.pdf
+                     */
+					int index = data.indexOf('.');
+					if(index != -1) {
+						String str1 = data.substring(0, index + 1);
+						String str2 = data.substring(index + 1);
+						if(str1 != null && str2 != null) {
+							index = str1.lastIndexOf('/');
+							if(index != -1) {
+								str1 = str1.substring(index+1);
+								index = str2.indexOf('/');
+								if(index != -1) {
+									str2 = str2.substring(0, index);
+									pkg = str1 + str2;
+								}
+							}
+						}
+					}
+				}
+			}
+
+			if(pkg != null) {
+				//search the cornerstone panels
+				for (int k=0; k<mCornerstonePanelStacks.size(); k++) {
+					ActivityStack currStack = mCornerstonePanelStacks.get(k);
+					for (int i=currStack.mHistory.size()-1; i>=0; i--) {
+						ActivityRecord r = (ActivityRecord)currStack.mHistory.get(i);
+						String intentPkg = r.packageName;
+						if (intentPkg != null && intentPkg.equals(pkg) && r.visible) {
+								if(DEBUG_CORNERSTONE) {
+									Log.v(TAG, "\tpackage found in cornerstone panel: " + k);
+								}
+							return k;
+						}
+					}
+				}
+
+				//Check the mainstack history
+				for (int i=mMainStack.mHistory.size()-1; i>=0; i--) {
+					ActivityRecord r = (ActivityRecord)mMainStack.mHistory.get(i);
+					String intentPkg = r.packageName;
+					if (intentPkg != null && intentPkg.equals(pkg) && r.visible) {
+						if(DEBUG_CORNERSTONE) {
+							Log.v(TAG, "\tpackage found in main stack");
+						}
+					return MAIN_STACK;
+					}
+				}
+			}
+		}
+
+		if(DEBUG_CORNERSTONE) {
+			Log.v(TAG, "\tresultTo found nowhere, default to main stack");
+		}
+        //If didn't find anywhere, then fail
+        return NO_STACK;
+    }
+
+    /**
+     * Author: Onskreen
+     * Date: 27/01/2011
+     *
+     * Utility methods to check which stack an activity is in.
+     */
+    private final int getActivityStack(int task) {
+		if(DEBUG_CORNERSTONE) {
+			Log.v(TAG, "Inspecting task: " + task);
+			logActivityStackState();
+		}
+
+		//Search Cornerstone
+		for(int i=0; i<mCornerstoneStack.mHistory.size(); i++) {
+			if(task == ((ActivityRecord)mCornerstoneStack.mHistory.get(i)).task.taskId) {
+				if(DEBUG_CORNERSTONE) Log.v(TAG, "\tTask found in cornerstone stack");
+				return CORNERSTONE_STACK;
+			}
+        }
+
+		//Search Cornerstone Panels
+        for (int k=0; k<mCornerstonePanelStacks.size(); k++) {
+			ActivityStack currStack = mCornerstonePanelStacks.get(k);
+			for (int i=currStack.mHistory.size()-1; i>=0; i--) {
+				if(task == ((ActivityRecord)currStack.mHistory.get(i)).task.taskId) {
+					if(DEBUG_CORNERSTONE) Log.v(TAG, "\tTask found in cornerstone panel: " + k);
+					return k;
+				}
+			}
+        }
+
+        //Search Main Stack
+        for(int i=0; i<mMainStack.mHistory.size(); i++) {
+			if(task == ((ActivityRecord)mMainStack.mHistory.get(i)).task.taskId) {
+				if(DEBUG_CORNERSTONE) Log.v(TAG, "\tTask found in main stack");
+				return MAIN_STACK;
+			}
+        }
+
+		if(DEBUG_CORNERSTONE) Log.v(TAG, "\tTask not found");
+        return NO_STACK;
+    }
+
+
+    /**
+     * Author: Onskreen
+     * Date: 27/01/2011
+     *
+     * Utility methods to check which stack an activity is in.
+     */
+    private final int getActivityStack(ActivityRecord r) {
+		if(DEBUG_CORNERSTONE) {
+			Log.v(TAG, "Inspecting record: " + r);
+			logActivityStackState();
+		}
+
+		//Search Main Stack
+        for(int i=0; i<mMainStack.mHistory.size(); i++) {
+			if(r == ((ActivityRecord)mMainStack.mHistory.get(i))) {
+				if(DEBUG_CORNERSTONE) Log.v(TAG, "\tActivityRecord found in main stack");
+				return MAIN_STACK;
+			}
+        }
+
+        //Search Cornerstone Panels
+        for (int k=0; k>mCornerstonePanelStacks.size(); k++) {
+			ActivityStack currStack = mCornerstonePanelStacks.get(k);
+			for (int i=currStack.mHistory.size()-1; i>=0; i--) {
+				if(r == ((ActivityRecord)currStack.mHistory.get(i))) {
+					if(DEBUG_CORNERSTONE) Log.v(TAG, "\tTask found in cornerstone panel: " + k);
+					return k;
+				}
+			}
+        }
+
+        //Search Cornerstone
+        if(isCornerstone(r)) {
+            if(DEBUG_CORNERSTONE) Log.v(TAG, "\tActivityRecord found to be cornerstone");
+            return CORNERSTONE_STACK;
+        }
+
+        if(DEBUG_CORNERSTONE) Log.v(TAG, "\tActivityRecord not found");
+        return NO_STACK;
+    }
+
+    /**
+     * Author: Onskreen
+     * Date: 27/01/2011
+     *
+     * Utility methods to check which stack a token is in.
+     */
+    private final int getActivityStack(IBinder token) {
+		if(DEBUG_CORNERSTONE) {
+			Log.v(TAG, "Inspecting token: " + token);
+			logActivityStackState();
+		}
+
+		//Check cornerstone panels
+		for(int k=0; k<mCornerstonePanelStacks.size(); k++) {
+			ActivityStack currStack = mCornerstonePanelStacks.get(k);
+			for(int i=0; i<currStack.mHistory.size(); i++) {
+				Object o = currStack.mHistory.get(i);
+				if(o==ActivityRecord.forToken(token)) {
+					if(DEBUG_CORNERSTONE) Log.v(TAG, "\tToken found to be cornerstone panel: " + k);
+					return k;
+				}
+			}
+		}
+
+			//Search Main Stack
+			for(int i=0; i<mMainStack.mHistory.size(); i++) {
+				Object o = mMainStack.mHistory.get(i);
+				if(o==ActivityRecord.forToken(token)) {
+					if(DEBUG_CORNERSTONE) Log.v(TAG, "\tActivityRecord found in main stack");
+					return MAIN_STACK;
+			}
+        }
+
+		//Search Cornerstone
+        for(int i=0; i<mCornerstoneStack.mHistory.size(); i++) {
+			Object o = mCornerstoneStack.mHistory.get(i);
+			if(o==ActivityRecord.forToken(token)) {
+				if(DEBUG_CORNERSTONE) Log.v(TAG, "\tActivityRecord found in cornerstone");
+				return CORNERSTONE_STACK;
+			}
+        }
+
+        if(DEBUG_CORNERSTONE) Log.v(TAG, "\tToken not found.");
+        return NO_STACK;
+    }
+
+    /**
+     * Author: Onskreen
+     * Date: 27/01/2011
+     *
+     * Utility methods to if an ActivityRecord is the Cornerstone app. Centralizing
+     * logic here so easily changed when we have a richer way of testing than
+     * package name.
+     */
+    public final boolean isCornerstone(ActivityRecord r) {
+
+        if(r!=null && r.packageName.contains(this.mCornerstoneAppPackageName)) {
+			return true;
+        } else {
+			return false;
+        }
+    }
+
+
+    /**
+     * Author: Onskreen
+     * Date: 27/01/2011
+     *
+     * Utility methods to dump to debug log brief state of all ActivityStacks
+     */
+    private final void logActivityStackState() {
+		Log.v(TAG, mMainStack.mStackName);
+        for (int i=mMainStack.mHistory.size()-1; i>=0; i--) {
+			ActivityRecord r = ((ActivityRecord)mMainStack.mHistory.get(i));
+			Log.v(TAG, "\t" + r.packageName + " State: " + r.state);
+        }
+        if(mMainStack.mHistory.isEmpty()) {
+			Log.v(TAG, "\tEmpty");
+        }
+
+        for(int k=0; k<mCornerstonePanelStacks.size(); k++) {
+			ActivityStack currStack = mCornerstonePanelStacks.get(k);
+			Log.v(TAG, currStack.mStackName);
+			for (int i=currStack.mHistory.size()-1; i>=0; i--) {
+				ActivityRecord r = ((ActivityRecord)currStack.mHistory.get(i));
+				Log.v(TAG, "\t" + r.packageName + " State: " + r.state);
+			}
+			if(currStack.mHistory.isEmpty()) {
+				Log.v(TAG, "\tEmpty");
+            }
+        }
+
+		Log.v(TAG, mCornerstoneStack.mStackName);
+        for (int i=mCornerstoneStack.mHistory.size()-1; i>=0; i--) {
+			ActivityRecord r = ((ActivityRecord)mCornerstoneStack.mHistory.get(i));
+			Log.v(TAG, "\t" + r.packageName + " State: " + r.state);
+        }
+        if(mCornerstoneStack.mHistory.isEmpty()) {
+			Log.v(TAG, "\tEmpty");
+        }
+    }
+
+    /**
+     * Author: Onskreen
+     * Date: 24/12/2011
+     *
+     * Utility method to specifically remove a task from the list of recent apps
+     * @param task
+     */
+    final void removeRecentTaskLocked(TaskRecord task) {
+        int N = mRecentTasks.size();
+        // Remove any existing entries that are the same kind of task.
+        for (int i=0; i<N; i++) {
+            TaskRecord tr = mRecentTasks.get(i);
+            if ((task.affinity != null && task.affinity.equals(tr.affinity))
+                    || (task.intent != null && task.intent.filterEquals(tr.intent))) {
+                mRecentTasks.remove(i);
+                i--;
+                N--;
+            }
+        }
+    }
 }
diff --git a/frameworks/base/services/java/com/android/server/am/ActivityStack.java b/frameworks/base/services/java/com/android/server/am/ActivityStack.java
index 336e3ce..3d387fd 100755
--- a/frameworks/base/services/java/com/android/server/am/ActivityStack.java
+++ b/frameworks/base/services/java/com/android/server/am/ActivityStack.java
@@ -22,6 +22,7 @@ import static android.content.pm.PackageManager.PERMISSION_GRANTED;
 import com.android.internal.app.HeavyWeightSwitcherActivity;
 import com.android.internal.os.BatteryStatsImpl;
 import com.android.server.am.ActivityManagerService.PendingActivityLaunch;
+import com.android.server.wm.WindowManagerService;
 
 import android.app.Activity;
 import android.app.ActivityManager;
@@ -70,8 +71,14 @@ import java.util.List;
 /**
  * State and management of a single stack of activities.
  */
-
-
+/**
+ * Author: Onskreen
+ * Date 1.27.2011
+ *
+ * Since ActivityStack is now used for both cornerstone and main stacks separately,
+ * logic is expanded in many places to test for now mCornerstoneStack in addition
+ * to mMainStack.
+ */
 final class ActivityStack {
     static final String TAG = ActivityManagerService.TAG;
     static final boolean localLOGV = ActivityManagerService.localLOGV;
@@ -143,9 +150,43 @@ final class ActivityStack {
 
     final ActivityManagerService mService;
     final boolean mMainStack;
-    
+
+    /**
+     * Author: Onskreen
+     * Date: 24/01/2011
+     *
+     * Cornerstone Specific Flags
+     */
+    final boolean mCornerstoneStack;			//Indicates stack is the cornerstone
+    final boolean mCornerstonePanelStack;		//Indicates stack is cornerstone panel
+    final int mCornerstonePanelIndex;			//Index of cornerstone panel. Only valid for cs panel stacks
+    String mStackName; 							//Convenience for debug statements
+
+    /**
+     * Author: Onskreen
+     * Date: 23/02/2011
+     *
+     * Flag indicating that stack is being paused completely. Used when cornerstone panel
+     * is not visible at all so all Activities can be paused and remain not visible.
+     */
+    boolean mStackPaused = false;
+
+    /**
+     * Author: Onskreen
+     * Date: 30/12/2011
+     *
+     * The last ActivityRecord that was tried to change. Used to ensure we don't end up
+     * in any infinite config update loops due to a WindowPanel config difference. We track
+     * the last activity updated because of purely WP changes, and how it was changed
+     * so that we don't try to repeat this config change.
+     *
+     * This is a hack until the config update process is smoother.
+     */
+    ActivityRecord mLastActivityConfigUpdated;
+    int mLastActivityConfigUpdateChangeFlags;
+
     final Context mContext;
-    
+
     /**
      * The back history of all previous (and possibly still
      * running) activities.  It contains HistoryRecord objects.
@@ -407,8 +448,9 @@ final class ActivityStack {
             }
         }
     };
-    
-    ActivityStack(ActivityManagerService service, Context context, boolean mainStack) {
+
+    ActivityStack(ActivityManagerService service, Context context, boolean mainStack,
+		boolean cornerstonePanelStack, int cornerstonePanelIndex) {
         mService = service;
         mContext = context;
         mMainStack = mainStack;
@@ -417,8 +459,33 @@ final class ActivityStack {
         mGoingToSleep = pm.newWakeLock(PowerManager.PARTIAL_WAKE_LOCK, "ActivityManager-Sleep");
         mLaunchingActivity = pm.newWakeLock(PowerManager.PARTIAL_WAKE_LOCK, "ActivityManager-Launch");
         mLaunchingActivity.setReferenceCounted(false);
+        /**
+         * Author: Onskreen
+         * Date: 24/01/2011
+         *
+         * Set cornerstone flags and indexs appropriately
+         */
+        //Cornerstone Stack
+        if(!mMainStack && !cornerstonePanelStack) {
+            mStackName = "Cornerstone_Stack";
+            mCornerstoneStack = true;
+            mCornerstonePanelStack = false;
+            mCornerstonePanelIndex = -1;
+        } else if(!mMainStack && cornerstonePanelStack) {
+            //Cornerstone Panel Stack
+            mStackName = "CornerstonePanel_Stack:" + cornerstonePanelIndex;
+            mCornerstoneStack = false;
+            mCornerstonePanelStack = true;
+            mCornerstonePanelIndex = cornerstonePanelIndex;
+        } else {
+            //Main Panel Stack
+            mStackName = "Main_Stack";
+            mCornerstoneStack = false;
+            mCornerstonePanelStack = false;
+            mCornerstonePanelIndex = -1;
+        }
     }
-    
+
     final ActivityRecord topRunningActivityLocked(ActivityRecord notTop) {
         // TODO: Don't look for any tasks from other users
         int i = mHistory.size()-1;
@@ -615,6 +682,14 @@ final class ActivityStack {
         r.startFreezingScreenLocked(app, 0);
         mService.mWindowManager.setAppVisibility(r.appToken, true);
 
+        /**
+         * Author: Onskreen
+         * Date: 26/12/2011
+         *
+         * Determine the WindowPanel specific config.
+         */
+        Configuration wpConfig = mService.mWindowManager.computeWindowPanelConfiguration(getWindowPanel());
+
         // schedule launch ticks to collect information about slow apps.
         r.startLaunchTickingLocked();
 
@@ -689,13 +764,20 @@ final class ActivityStack {
                     profileFd = null;
                 }
             }
+            /**
+             * Author: Onskreen
+             * Date: 26/12/2011
+             *
+             * Starting the activity with the wp specific activity instead of the default
+             * AMS.mConfiguration.
+             */
             app.thread.scheduleLaunchActivity(new Intent(r.intent), r.appToken,
                     System.identityHashCode(r), r.info,
-                    new Configuration(mService.mConfiguration),
+                    new Configuration(wpConfig/*mService.mConfiguration*/),
                     r.compat, r.icicle, results, newIntents, !andResume,
                     mService.isNextTransitionForward(), profileFile, profileFd,
                     profileAutoStop);
-            
+
             if ((app.info.flags&ApplicationInfo.FLAG_CANT_SAVE_STATE) != 0) {
                 // This may be a heavy-weight process!  Note that the package
                 // manager will ensure that only activity can run in the main
@@ -794,10 +876,21 @@ final class ActivityStack {
         } else if (mInitialStartTime == 0) {
             mInitialStartTime = SystemClock.uptimeMillis();
         }
-        
+
         if (app != null && app.thread != null) {
             try {
                 app.addPackage(r.info.packageName);
+                /**
+                 * Author: Onskreen
+                 * Date: 07/01/2012
+                 *
+                 * In cases where the Process was already started (perhaps at launch), we need to be sure the
+                 * activity gets launched with the config of the WindowPanel and not the config that was
+                 * sent to the ProcessRecord at its launch.
+                 */
+                if(checkConfig) {
+                    mService.forceConfigurationLocked(this, app);
+                }
                 realStartActivityLocked(r, app, andResume, checkConfig);
                 return;
             } catch (RemoteException e) {
@@ -926,7 +1019,16 @@ final class ActivityStack {
         return null;
     }
 
-    private final void startPausingLocked(boolean userLeaving, boolean uiSleeping) {
+   /**
+    * Author: Onskreen
+    * Date: 23/02/2011
+    *
+    * Made public so that AMS can make call to pause top activity and pause all activities
+    * in the stack when the stack is not visible to the user but activities should be paused
+    * and available to reopen in their previous state.
+    */
+    public final void startPausingLocked(boolean userLeaving, boolean uiSleeping) {
+    //private final void startPausingLocked(boolean userLeaving, boolean uiSleeping) {
         if (mPausingActivity != null) {
             RuntimeException e = new RuntimeException();
             Slog.e(TAG, "Trying to pause when pause is already pending for "
@@ -958,7 +1060,14 @@ final class ActivityStack {
                         prev.shortComponentName);
                 prev.app.thread.schedulePauseActivity(prev.appToken, prev.finishing,
                         userLeaving, prev.configChangeFlags);
-                if (mMainStack) {
+                if (mMainStack || mCornerstoneStack || mCornerstonePanelStack) {
+                    /**
+                     * Author: Onskreen
+                     * Date: 23/02/2011
+                     *
+                     * Security Exception Warning. Triggered by AMS.setCornerstoneState() which must have cleared
+                     * it's identity before executing.
+                     */
                     mService.updateUsageStats(prev, false);
                 }
             } catch (Exception e) {
@@ -975,6 +1084,13 @@ final class ActivityStack {
         // If we are not going to sleep, we want to ensure the device is
         // awake until the next activity is started.
         if (!mService.mSleeping && !mService.mShuttingDown) {
+            /**
+             * Author: Onskreen
+             * Date: 23/02/2011
+             *
+             * Security Exception Warning. Triggered by AMS.setCornerstoneState() which must have cleared
+             * it's identity before executing.
+             */
             mLaunchingActivity.acquire();
             if (!mHandler.hasMessages(LAUNCH_TIMEOUT_MSG)) {
                 // To be safe, don't allow the wake lock to be held for too long.
@@ -1010,7 +1126,104 @@ final class ActivityStack {
             resumeTopActivityLocked(null);
         }
     }
-    
+
+    /**
+     * Author: Onskreen
+     * Date: 03/05/2011
+     *
+     * Trying to pause specific activity with no side effects. This is used in cases where the
+     * resuming/pausing of activities is not in a one to one relationship as the ActivityStack
+     * originally expected. It is basically a replica of startPausingLocked with
+     * any side effects or assumptions about which activity will be paused removed.
+     *
+     * This will fail in cases where multiple Activities are to be paused at once. In that case,
+     * the second call to this method will not execute because the previous one will still
+     * be pausing. Haven't found test case for that yet, but pretty sure it exists
+     */
+    public final void startSpecificPausingLocked(ActivityRecord toPause, boolean userLeaving, boolean uiSleeping) {
+        if (mPausingActivity != null) {
+            RuntimeException e = new RuntimeException();
+            Slog.e(TAG, "Trying to pause when pause is already pending for "
+                  + mPausingActivity, e);
+        }
+
+        if (DEBUG_PAUSE) Slog.v(TAG, "Start pausing: " + toPause);
+        mPausingActivity = toPause;
+        mLastPausedActivity = toPause;
+        toPause.state = ActivityState.PAUSING;
+        toPause.task.touchActiveTime();
+
+        mService.updateCpuStats();
+
+        if (toPause.app != null && toPause.app.thread != null) {
+            if (DEBUG_PAUSE) Slog.v(TAG, "Enqueueing pending pause: " + toPause);
+            try {
+                EventLog.writeEvent(EventLogTags.AM_PAUSE_ACTIVITY,
+                        System.identityHashCode(toPause),
+                        toPause.shortComponentName);
+                toPause.app.thread.schedulePauseActivity(toPause.appToken, toPause.finishing, userLeaving,
+					toPause.configChangeFlags);
+                if (mMainStack || mCornerstoneStack || mCornerstonePanelStack) {
+                    /**
+                     * Author: Onskreen
+                     * Date: 23/02/2011
+                     *
+                     * Security Exception Warning. Triggered by AMS.setCornerstoneState() which must have cleared
+                     * it's identity before executing.
+                     */
+                    mService.updateUsageStats(toPause, false);
+                }
+            } catch (Exception e) {
+                // Ignore exception, if process died other code will cleanup.
+                Slog.w(TAG, "Exception thrown during pause", e);
+                mPausingActivity = null;
+                mLastPausedActivity = null;
+            }
+        } else {
+            mPausingActivity = null;
+            mLastPausedActivity = null;
+        }
+
+        // If we are not going to sleep, we want to ensure the device is
+        // awake until the next activity is started.
+        if (!mService.mSleeping && !mService.mShuttingDown) {
+            /**
+             * Author: Onskreen
+             * Date: 23/02/2011
+             *
+             * Security Exception Warning. Triggered by AMS.setCornerstoneState() which must have cleared
+             * it's identity before executing.
+             */
+            mLaunchingActivity.acquire();
+            if (!mHandler.hasMessages(LAUNCH_TIMEOUT_MSG)) {
+                // To be safe, don't allow the wake lock to be held for too long.
+                Message msg = mHandler.obtainMessage(LAUNCH_TIMEOUT_MSG);
+                mHandler.sendMessageDelayed(msg, LAUNCH_TIMEOUT);
+            }
+        }
+
+
+        if (mPausingActivity != null) {
+            // Have the window manager pause its key dispatching until the new
+            // activity has started.  If we're pausing the activity just because
+            // the screen is being turned off and the UI is sleeping, don't interrupt
+            // key dispatch; the same activity will pick it up again on wakeup.
+            if (!uiSleeping) {
+                toPause.pauseKeyDispatchingLocked();
+            } else {
+                if (DEBUG_PAUSE) Slog.v(TAG, "Key dispatch not paused for screen off");
+            }
+
+            // Schedule a pause timeout in case the app doesn't respond.
+            // We don't give it much time because this directly impacts the
+            // responsiveness seen by the user.
+            Message msg = mHandler.obtainMessage(PAUSE_TIMEOUT_MSG);
+            msg.obj = toPause;
+            mHandler.sendMessageDelayed(msg, PAUSE_TIMEOUT);
+            if (DEBUG_PAUSE) Slog.v(TAG, "Waiting for pause to complete...");
+        }
+    }
+
     final void activityPaused(IBinder token, boolean timeout) {
         if (DEBUG_PAUSE) Slog.v(
             TAG, "Activity paused: token=" + token + ", timeout=" + timeout);
@@ -1087,11 +1300,25 @@ final class ActivityStack {
     private final void completePauseLocked() {
         ActivityRecord prev = mPausingActivity;
         if (DEBUG_PAUSE) Slog.v(TAG, "Complete pause: " + prev);
-        
+
         if (prev != null) {
             if (prev.finishing) {
                 if (DEBUG_PAUSE) Slog.v(TAG, "Executing finish of activity: " + prev);
-                prev = finishCurrentActivityLocked(prev, FINISH_AFTER_VISIBLE);
+                /*
+                 * Onscreen-Cornerstone
+                 * Version: 0.84
+                 * Date: 08.11.2011
+                 *
+                 * When cornerstone is exiting, we must kill the activities in the specific stack.
+                 * As we don't want to resume any previous activity in the stack, we should call the
+                 * finishCurrentActivityLocked with FINISH_IMMEDIATELY mode.
+                 */
+                 if(mService.mActivityStackExiting) {
+                     mStackPaused = false;
+                     prev = finishCurrentActivityLocked(prev, FINISH_IMMEDIATELY);
+                 } else {
+                     prev = finishCurrentActivityLocked(prev, FINISH_AFTER_VISIBLE);
+                 }
             } else if (prev.app != null) {
                 if (DEBUG_PAUSE) Slog.v(TAG, "Enqueueing pending stop: " + prev);
                 if (prev.waitingVisible) {
@@ -1189,12 +1416,12 @@ final class ActivityStack {
             mHandler.sendMessage(msg);
         }
 
-        if (mMainStack) {
+        if (mMainStack || mCornerstoneStack || mCornerstonePanelStack) {
             mService.reportResumedActivityLocked(next);
         }
-        
+
         next.clearThumbnail();
-        if (mMainStack) {
+        if (mMainStack || mCornerstoneStack || mCornerstonePanelStack) {
             mService.setFocusedActivityLocked(next);
         }
         next.resumeKeyDispatchingLocked();
@@ -1277,6 +1504,15 @@ final class ActivityStack {
                 // else to do here.
                 if (DEBUG_VISBILITY) Slog.v(
                         TAG, "Skipping: already visible at " + r);
+                /**
+                 * Author: Onskreen
+                 * Date: 20/02/2012
+                 *
+                 * Ensure the visible Activity has the current focus.
+                 */
+				if (r.intent.hasCategory(Intent.CATEGORY_HOME)) {
+					mService.mWindowManager.handleFocusChange(r.appToken.asBinder());
+				}
                 r.stopFreezingScreenLocked(false);
 
             } else if (onlyThisProcess == null) {
@@ -1383,11 +1619,37 @@ final class ActivityStack {
         return resumeTopActivityLocked(prev, null);
     }
 
-	private native void checkFileName(String name);
-
     final boolean resumeTopActivityLocked(ActivityRecord prev, Bundle options) {
-        // Find the first activity that is not finishing.
-        ActivityRecord next = topRunningActivityLocked(null);
+        /**
+         * Author: Onskreen
+         * Date: 23/02/2011
+         *
+         * If the entire stack is paused, ignore requests to resume top activity. Centralizing
+         * this logic allows less changes throughout the class while enabling us to stop all actvities
+         */
+        if(mStackPaused) {
+            if (DEBUG_SWITCH) {
+                Log.v(TAG, "Stack: " + mStackName);
+                Log.v(TAG, "\tIgnoring request to resume top activity as stack is paused");
+              }
+            return false;
+        }
+
+
+        /**
+         * Author: Onskreen
+         * Date: 31/01/2011
+         *
+         * Determining task to be resumed based on panel. In cornerstone, the task to be
+         * resumed may or may not be the top activity and the activity to be paused may or may not
+         * be mResumedActivity. This is because tasks below the bottom one may be the one we
+         * are dealing with.
+         */
+        ActivityRecord next = null;
+        if(mMainStack || mCornerstonePanelStack || mCornerstoneStack) {
+            // Find the first activity that is not finishing.
+            next = topRunningActivityLocked(null);
+        }
 
         // Remember how we'll process this pause/resume situation, and ensure
         // that the state is reset however we wind up proceeding.
@@ -1400,12 +1662,50 @@ final class ActivityStack {
             if (mMainStack) {
                 ActivityOptions.abort(options);
                 return mService.startHomeActivityLocked(0);
+            /**
+             * Author: Onskreen
+             * Date: 16/07/2011
+             *
+             * When cornerstone is exiting, we shouldn't allow launching
+             * Cornerstone Launcher to start in either of panels.
+             */
+            } else if(mCornerstonePanelStack && !mService.mActivityStackExiting) {
+                /**
+                 * Author: Onskreen
+                 * Date: 03/05/2011
+                 *
+                 * No more activities, startup the Cornerstone Launcher
+                 */
+                if(DEBUG_SWITCH) {
+                    Log.w(TAG, "No activity records in: " + mStackName);
+                    Log.w(TAG, "Starting Cornerstone Launcher in this Panel");
+                }
+                return mService.startCornerstoneLauncherLocked(mCornerstonePanelIndex);
+            } else if(mCornerstoneStack) {
+                /**
+                 * Author: Onskreen
+                 * Date: 03/05/2011
+                 *
+                 * If the CS itself is not resumed something bad happened
+                 */
+                if(DEBUG_SWITCH) {
+                    Log.e(TAG, "No activity records in: " + mStackName);
+                }
+                return false;
+            /**
+             * Author: Onskreen
+             * Date: 16/07/2011
+             *
+             * Just return false when cornerstone is exiting and resumeTopActivityLocked
+             * method getting triggered by other methods.
+             */
+            } else {
+                return false;
             }
         }
-		checkFileName(next.packageName);
 
         next.delayedResume = false;
-        
+
         // If the top activity is the resumed one, nothing to do.
         if (mResumedActivity == next && next.state == ActivityState.RESUMED) {
             // Make sure we have executed any pending transitions, since there
@@ -1622,8 +1922,22 @@ final class ActivityStack {
             // Have the window manager re-evaluate the orientation of
             // the screen based on the new activity order.
             boolean updated = false;
-            if (mMainStack) {
+            if (mMainStack || mCornerstoneStack || mCornerstonePanelStack) {
                 synchronized (mService) {
+                  /**
+                   * Author: Onskreen
+                   * Date : 26/12/2011
+                   */
+                    WindowManagerService.WP_Panel conf = WindowManagerService.WP_Panel.UNDEFINED;
+                    if(mMainStack) {
+                        conf = WindowManagerService.WP_Panel.MAIN_PANEL;
+                    } else if(mCornerstonePanelStack && mCornerstonePanelIndex == 0) {
+                        conf = WindowManagerService.WP_Panel.CS_APP_0;
+                    } else if(mCornerstonePanelStack && mCornerstonePanelIndex == 1) {
+                        conf = WindowManagerService.WP_Panel.CS_APP_1;
+                    } else if(mCornerstoneStack) {
+                        conf = WindowManagerService.WP_Panel.CORNERSTONE;
+                    }
                     Configuration config = mService.mWindowManager.updateOrientationFromAppTokens(
                             mService.mConfiguration,
                             next.mayFreezeScreenLocked(next.app) ? next.appToken : null);
@@ -1647,7 +1961,7 @@ final class ActivityStack {
                     // Do over!
                     mHandler.sendEmptyMessage(RESUME_TOP_ACTIVITY_MSG);
                 }
-                if (mMainStack) {
+                if (mMainStack || mCornerstoneStack || mCornerstonePanelStack) {
                     mService.setFocusedActivityLocked(next);
                 }
                 ensureActivitiesVisibleLocked(null, 0);
@@ -1779,8 +2093,19 @@ final class ActivityStack {
                         }
                         mHistory.add(addPos, r);
                         r.putInHistory();
+                        //mService.mWindowManager.addAppToken(addPos, r.appToken, r.task.taskId,
+                        //        r.info.screenOrientation, r.fullscreen);
+                        /**
+                         * Author: Onskreen
+                         * Date: 24/01/2011
+                         *
+                         * Udpated to use new overloaded version
+                         */
                         mService.mWindowManager.addAppToken(addPos, r.appToken, r.task.taskId,
-                                r.info.screenOrientation, r.fullscreen);
+                                r.info.screenOrientation, r.fullscreen,
+                                mMainStack,
+                                mService.isCornerstone(r),
+                                mCornerstonePanelIndex);
                         if (VALIDATE_TOKENS) {
                             validateAppTokensLocked();
                         }
@@ -1843,8 +2168,19 @@ final class ActivityStack {
                 mNoAnimActivities.remove(r);
             }
             r.updateOptionsLocked(options);
+            //mService.mWindowManager.addAppToken(
+            //        addPos, r.appToken, r.task.taskId, r.info.screenOrientation, r.fullscreen);
+			/**
+             * Author: Onskreen
+             * Date: 24/01/2011
+             *
+             * Updated to use new overloaded version
+             */
             mService.mWindowManager.addAppToken(
-                    addPos, r.appToken, r.task.taskId, r.info.screenOrientation, r.fullscreen);
+                    addPos, r.appToken, r.task.taskId, r.info.screenOrientation, r.fullscreen,
+                    mMainStack,
+                    mService.isCornerstone(r),
+                    mCornerstonePanelIndex);
             boolean doShow = true;
             if (newTask) {
                 // Even though this activity is starting fresh, we still need
@@ -1881,8 +2217,20 @@ final class ActivityStack {
         } else {
             // If this is the first activity, don't do any fancy animations,
             // because there is nothing for it to animate on top of.
-            mService.mWindowManager.addAppToken(addPos, r.appToken, r.task.taskId,
-                    r.info.screenOrientation, r.fullscreen);
+            //mService.mWindowManager.addAppToken(addPos, r.appToken, r.task.taskId,
+            //        r.info.screenOrientation, r.fullscreen);
+            /**
+             * Author: Onskreen
+             * Date: 24/01/2011
+             *
+             * Updated to use new overloaded version
+             */
+             //Log.i(TAG, "First Activity in the stack");
+             mService.mWindowManager.addAppToken(addPos, r.appToken, r.task.taskId,
+                   r.info.screenOrientation, r.fullscreen,
+                   mMainStack,
+                   mService.isCornerstone(r),
+                   mCornerstonePanelIndex);
             ActivityOptions.abort(options);
         }
         if (VALIDATE_TOKENS) {
@@ -2498,7 +2846,7 @@ final class ActivityStack {
             throw new SecurityException(msg);
         }
 
-        if (mMainStack) {
+        if (mMainStack || mCornerstoneStack || mCornerstonePanelStack) {
             if (mService.mController != null) {
                 boolean abort = false;
                 try {
@@ -2525,15 +2873,21 @@ final class ActivityStack {
                 }
             }
         }
-
+        /**
+         * Author: Onskreen
+         * Date: 26/12/2011
+         *
+         * Starting the activity with the WP specific config instead of default one.
+         */
+        Configuration wpConfig = mService.mWindowManager.computeWindowPanelConfiguration(getWindowPanel());
         ActivityRecord r = new ActivityRecord(mService, this, callerApp, callingUid,
-                intent, resolvedType, aInfo, mService.mConfiguration,
+                intent, resolvedType, aInfo, wpConfig /*mService.mConfiguration*/,
                 resultRecord, resultWho, requestCode, componentSpecified);
         if (outActivity != null) {
             outActivity[0] = r;
         }
 
-        if (mMainStack) {
+        if (mMainStack || mCornerstoneStack || mCornerstonePanelStack) {
             if (mResumedActivity == null
                     || mResumedActivity.info.applicationInfo.uid != callingUid) {
                 if (!mService.checkAppSwitchAllowedLocked(callingPid, callingUid, "Activity start")) {
@@ -3020,7 +3374,21 @@ final class ActivityStack {
         if (aInfo != null && mService.isSingleton(aInfo.processName, aInfo.applicationInfo)) {
             userId = 0;
         }
-        aInfo = mService.getActivityInfoForUser(aInfo, userId);	
+        /**
+         * Author: Onskreen
+         * Date: 07/01/2012
+         *
+         * Check if Cornerstone is ok with this activity launching. Inform the
+         * caller appropriately if we can't proceed.
+         */
+        boolean okToProceed = mService.isActivityPermittedToStart(aInfo, this);
+        if(!okToProceed) {
+            //This isn't a success, but is not a failure of the calling activity,
+            // so return success and let things proceed.
+            return ActivityManager.START_SUCCESS;
+        }
+        aInfo = mService.getActivityInfoForUser(aInfo, userId);
+
         synchronized (mService) {
             int callingPid;
             if (callingUid >= 0) {
@@ -3031,15 +3399,15 @@ final class ActivityStack {
             } else {
                 callingPid = callingUid = -1;
             }
-            
+
             mConfigWillChange = config != null
                     && mService.mConfiguration.diff(config) != 0;
             if (DEBUG_CONFIGURATION) Slog.v(TAG,
                     "Starting activity when config will change = " + mConfigWillChange);
-            
+
             final long origId = Binder.clearCallingIdentity();
-            
-            if (mMainStack && aInfo != null &&
+
+            if ((mMainStack || mCornerstoneStack || mCornerstonePanelStack) && aInfo != null &&
                     (aInfo.applicationInfo.flags&ApplicationInfo.FLAG_CANT_SAVE_STATE) != 0) {
                 // This may be a heavy-weight process!  Check to see if we already
                 // have another, different heavy-weight process running.
@@ -3108,12 +3476,12 @@ final class ActivityStack {
                     }
                 }
             }
-            
+
             int res = startActivityLocked(caller, intent, resolvedType,
                     aInfo, resultTo, resultWho, requestCode, callingPid, callingUid,
                     startFlags, options, componentSpecified, null);
-            
-            if (mConfigWillChange && mMainStack) {
+
+            if (mConfigWillChange && (mMainStack || mCornerstoneStack || mCornerstonePanelStack)) {
                 // If the caller also wants to switch to a new configuration,
                 // do so now.  This allows a clean switch, as we are waiting
                 // for the current activity to pause (so we will not destroy
@@ -3124,10 +3492,22 @@ final class ActivityStack {
                 if (DEBUG_CONFIGURATION) Slog.v(TAG,
                         "Updating to new configuration after starting activity.");
                 mService.updateConfigurationLocked(config, null, false, false);
+            } else {
+                /**
+                 * Author: Onskreen
+                 * Date: 07/01/2012
+                 *
+                 * It is possible the process this activity will be added to was re-config'd so we have
+                 * to be sure that this activity has the correct config before launching. In essence, this
+                 * is the same as just setting mConfigWillChange to true, but forcing on the specific stack
+                 * if it wasn't considered to be true.
+                 *
+                 */
+                mService.forceConfigurationLocked(this, mService.mWindowManager.mCornerstoneState);
             }
-            
+
             Binder.restoreCallingIdentity(origId);
-            
+
             if (outResult != null) {
                 outResult.result = res;
                 if (res == ActivityManager.START_SUCCESS) {
@@ -3212,7 +3592,7 @@ final class ActivityStack {
                     // TODO: New, check if this is correct
                     aInfo = mService.getActivityInfoForUser(aInfo, userId);
 
-                    if (mMainStack && aInfo != null && (aInfo.applicationInfo.flags
+                    if ((mMainStack || mCornerstoneStack || mCornerstonePanelStack) && aInfo != null && (aInfo.applicationInfo.flags
                             & ApplicationInfo.FLAG_CANT_SAVE_STATE) != 0) {
                         throw new IllegalArgumentException(
                                 "FLAG_CANT_SAVE_STATE not supported here");
@@ -3318,7 +3698,7 @@ final class ActivityStack {
         }
 
         if (r.app != null && r.app.thread != null) {
-            if (mMainStack) {
+            if (mMainStack || mCornerstoneStack || mCornerstonePanelStack) {
                 if (mService.mFocusedActivity == r) {
                     mService.setFocusedActivityLocked(topRunningActivityLocked(null));
                 }
@@ -3469,13 +3849,13 @@ final class ActivityStack {
                 ensureActivitiesVisibleLocked(null, 0);
 
                 //Slog.i(TAG, "IDLE: mBooted=" + mBooted + ", fromTimeout=" + fromTimeout);
-                if (mMainStack) {
+                if (mMainStack || mCornerstoneStack || mCornerstonePanelStack) {
                     if (!mService.mBooted) {
                         mService.mBooted = true;
                         enableScreen = true;
                     }
                 }
-                
+
             } else if (fromTimeout) {
                 reportActivityLaunchedLocked(fromTimeout, null, -1, -1);
             }
@@ -3492,7 +3872,7 @@ final class ActivityStack {
                 mService.mCancelledThumbnails.clear();
             }
 
-            if (mMainStack) {
+            if (mMainStack || mCornerstoneStack || mCornerstonePanelStack) {
                 booting = mService.mBooting;
                 mService.mBooting = false;
             }
@@ -3572,7 +3952,45 @@ final class ActivityStack {
             return false;
         }
         ActivityRecord r = mHistory.get(index);
+        // Is this the last activity left?
+        boolean lastActivity = true;
+        for (int i=mHistory.size()-1; i>=0; i--) {
+            ActivityRecord p = mHistory.get(i);
+            if (!p.finishing && p != r) {
+                lastActivity = false;
+                break;
+            }
+        }
 
+         // If this is the last activity, but it is the home activity, then
+        // just don't finish it.
+        if (lastActivity) {
+            /**
+             * Author: Onskreen
+             * Date: 04/02/2011
+             *
+             * In the case of the cornerstone panel, the back key should not be able to finish the last
+             * activity in the last task or there would be no activities visible behind it.
+             */
+            if(!mMainStack && !mService.mActivityStackExiting) {
+                return false;
+            } else {
+               /**
+                * Author: Onskreen
+                * Date: 29/12/2011
+                *
+                * Identifies the HOME app by checking the category
+                * as well as matching the AMS.mHomeProcess. Any HOME
+                * app must pass this test else it's not considered as
+                * HOME app and should be killed immediately as requested
+                * by the framework.
+                */
+               if (r.intent.hasCategory(Intent.CATEGORY_HOME)
+                       && r.app != mService.mHomeProcess) {
+                    return false;
+               }
+            }
+        }
         finishActivityLocked(r, index, resultCode, resultData, reason);
         return true;
     }
@@ -3690,14 +4108,14 @@ final class ActivityStack {
         }
 
         r.pauseKeyDispatchingLocked();
-        if (mMainStack) {
+        if (mMainStack || mCornerstoneStack || mCornerstonePanelStack) {
             if (mService.mFocusedActivity == r) {
                 mService.setFocusedActivityLocked(topRunningActivityLocked(null));
             }
         }
 
         finishActivityResultsLocked(r, resultCode, resultData);
-        
+
         if (mService.mPendingThumbnails.size() > 0) {
             // There are clients waiting to receive thumbnails so, in case
             // this is an activity that someone is waiting for, add it
@@ -3730,8 +4148,22 @@ final class ActivityStack {
             // If the activity is PAUSING, we will complete the finish once
             // it is done pausing; else we can just directly finish it here.
             if (DEBUG_PAUSE) Slog.v(TAG, "Finish not pausing: " + r);
-            return finishCurrentActivityLocked(r, index,
-                    FINISH_AFTER_PAUSE) == null;
+            /*
+             * Onscreen-Cornerstone
+             * Date: 08.11.2011
+             *
+             * When cornerstone is exiting, we must kill the activities in the specific stack.
+             * As we don't want to resume any previous activity in the stack, we should call the
+             * finishCurrentActivityLocked with FINISH_IMMEDIATELY mode.
+             */
+            boolean finished = false;
+            if(mService.mActivityStackExiting) {
+                mStackPaused = false;
+                finished = finishCurrentActivityLocked(r, index, FINISH_IMMEDIATELY) == null;
+            } else {
+                finished = finishCurrentActivityLocked(r, index, FINISH_AFTER_PAUSE) == null;
+            }
+            return finished;
         } else {
             if (DEBUG_PAUSE) Slog.v(TAG, "Finish waiting for pause of: " + r);
         }
@@ -4100,14 +4532,12 @@ final class ActivityStack {
         removeHistoryRecordsForAppLocked(mWaitingVisibleActivities, app);
         removeHistoryRecordsForAppLocked(mFinishingActivities, app);
     }
-    
+
     /**
      * Move the current home activity's task (if one exists) to the front
      * of the stack.
      */
     final void moveHomeToFrontLocked() {
-
-	Slog.v("+++++++","return home activity +++++++++++++++++");
         TaskRecord homeTask = null;
         for (int i=mHistory.size()-1; i>=0; i--) {
             ActivityRecord hr = mHistory.get(i);
@@ -4202,28 +4632,157 @@ final class ActivityStack {
         EventLog.writeEvent(EventLogTags.AM_TASK_TO_FRONT, task);
     }
 
+    /**
+     * Author: Onskreen
+     * Date: 04/02/2011
+     *
+     * Remove an entire set of activities (set of ActivityRecords as defined by
+     * a WMS.WindowFrame) from the stack but keep them in RESUMED state in
+     * preparation for a swap to another panel (ActivityStack).
+     * Used to switch wf's between panels.
+     *
+     */
+    final void removeSetOfTasksLocked(List<ActivityRecord> recordsToRemove) {
+
+        if (DEBUG_TRANSITION) Slog.v(TAG,
+                "Remove Tasks To Prepare to Move: tokens=" + recordsToRemove);
+
+        final int N = mHistory.size();
+        int bottom = 0;
+        int pos = 0;
+
+        // Shift all activities with this task down to the bottom
+        // of the stack, keeping them in the same internal order.
+        while (pos < N) {
+            ActivityRecord r = (ActivityRecord)mHistory.get(pos);
+            if (localLOGV) Slog.v(TAG, "At " + pos + " ckp " + r.task + ": " + r);
+            if (recordsToRemove.contains(r)) {
+                if (localLOGV) Slog.v(TAG, "Removing and adding at " + (N-1));
+                mHistory.remove(pos);
+                mHistory.add(bottom, r);
+                bottom++;
+            }
+            pos++;
+        }
+
+        ArrayList<IBinder> tokensToRemove = new ArrayList<IBinder>();
+        for(int i=0; i<recordsToRemove.size(); i++) {
+            tokensToRemove.add(recordsToRemove.get(i).appToken.asBinder());
+        }
+
+        mService.mWindowManager.prepareAppTransition(WindowManagerPolicy.TRANSIT_TASK_TO_BACK, false);
+        mService.mWindowManager.moveAppTokensToBottom(tokensToRemove);
+        //Remove tokens from the list
+        //Don't want to call removeFromHistoryLocked() because don't want the side effects of destroying the record
+        for(int i=0; i<recordsToRemove.size(); i++) {
+            mHistory.remove(recordsToRemove.get(i));
+        }
+
+        //Ensure that the Activity just removed does not get processed during the next resume
+        mResumedActivity = null;
+        mPausingActivity = null;
+        if(recordsToRemove.contains(mLastPausedActivity)) {
+            mLastPausedActivity = null;
+        }
+        if(recordsToRemove.contains(mLastStartedActivity)) {
+            mLastStartedActivity = null;
+        }
+
+        /**
+         * Author: Onskreen
+         * Date: 06/07/2011
+         *
+         * Calling finishTaskMoveLocked method triggers the resumeTopActivityLocked method
+         * which unnecessary delays the activity transition when user performs swap operation.
+         */
+        //finishTaskMoveLocked(-1);
+
+    }
+
+    /**
+     * Author: Onskreen
+     * Date: 04/02/2011
+     *
+     * Add an entire set of ActivityRecords (as defined by a WMS.WindowFrame to the front of the stack).
+     * Used to switch wf's between panels.
+     */
+    final void addSetOfTasksLocked(List<ActivityRecord> recordsToAdd) {
+        if (DEBUG_SWITCH) Slog.v(TAG, "addSetOfTasksLocked: " + recordsToAdd);
+
+        //The topmost activity of the set to be moved, used to know which to animate
+        ActivityRecord newTop = null;
+
+        //Testing - top before adding new ones
+        ActivityRecord previousTop = topRunningActivityLocked(null);
+
+        // Add all activities in the list up to the top
+        // of the stack, keeping them in the same order.
+        for(int i=0; i<recordsToAdd.size(); i++) {
+            ActivityRecord r = recordsToAdd.get(i);
+            if (localLOGV) Slog.v(TAG, "Adding: " + r);
+            mHistory.add(r);
+            //If this is the topmost activity
+            if (i+1 == recordsToAdd.size()) {
+                newTop = r;
+                if(mMainStack) {
+                    mService.addRecentTaskLocked(r.task);
+                }
+            }
+        }
+
+        if (DEBUG_TRANSITION) Slog.v(TAG, "Prepare to front transition: tasks=" + recordsToAdd);
+        ArrayList<IBinder> tokensToAdd = new ArrayList<IBinder>();
+        for(int i=0; i<recordsToAdd.size(); i++) {
+            tokensToAdd.add(recordsToAdd.get(i).appToken.asBinder());
+        }
+        //mService.mWindowManager.prepareAppTransition(WindowManagerPolicy.TRANSIT_TASK_TO_FRONT);
+        mService.mWindowManager.prepareAppTransition(WindowManagerPolicy.TRANSIT_UNSET, false);
+        mService.mWindowManager.moveAppTokensToTop(tokensToAdd);
+
+        //Ensure that the Activity just removed does not get processed during the next resume
+        mResumedActivity = null;
+        mPausingActivity = null;
+
+        finishTaskMoveLocked(-1);
+
+    }
+
     private final void finishTaskMoveLocked(int task) {
         resumeTopActivityLocked(null);
     }
 
     /**
-     * Worker method for rearranging history stack.  Implements the function of moving all 
-     * activities for a specific task (gathering them if disjoint) into a single group at the 
+     * Worker method for rearranging history stack.  Implements the function of moving all
+     * activities for a specific task (gathering them if disjoint) into a single group at the
      * bottom of the stack.
-     * 
+     *
      * If a watcher is installed, the action is preflighted and the watcher has an opportunity
      * to premeptively cancel the move.
-     * 
+     *
      * @param task The taskId to collect and move to the bottom.
      * @return Returns true if the move completed, false if not.
      */
     final boolean moveTaskToBackLocked(int task, ActivityRecord reason) {
         Slog.i(TAG, "moveTaskToBack: " + task);
-        
+        // Is this the last activity left?
+        /**
+         * Author: Onskreen
+         * Date: 16/09/2011
+         *
+         * If user tries to move back to the only top most activity left
+         * in the history list, then just ignore it. At least one activity
+         * always should be visible in either of cornerstone panels.
+         */
+        final int N = mHistory.size();
+        ActivityRecord p = mHistory.get(N-1);
+        if(task == p.task.taskId && mCornerstonePanelStack) {
+            Slog.i(TAG, "last Activity left, returning false");
+            return false;
+        }
         // If we have a watcher, preflight the move before committing to it.  First check
         // for *other* available tasks, but if none are available, then try again allowing the
         // current task to be selected.
-        if (mMainStack && mService.mController != null) {
+        if ((mMainStack || mCornerstoneStack || mCornerstonePanelStack) && mService.mController != null) {
             ActivityRecord next = topRunningActivityLocked(null, task);
             if (next == null) {
                 next = topRunningActivityLocked(null, 0);
@@ -4246,8 +4805,8 @@ final class ActivityStack {
 
         if (DEBUG_TRANSITION) Slog.v(TAG,
                 "Prepare to back transition: task=" + task);
-        
-        final int N = mHistory.size();
+
+        //final int N = mHistory.size();
         int bottom = 0;
         int pos = 0;
 
@@ -4442,21 +5001,110 @@ final class ActivityStack {
             r.stopFreezingScreenLocked(false);
             return true;
         }
-        
+
+        /**
+         * Author: Onskreen
+         * Date: 26/12/2011
+         *
+         * Diff the ActivityRecord.configuration with the AMS.mConfiguration taking into account the WindowPanel
+         * differences we expect. If these are the same, then we move on.
+         *
+         */
+        //Configuration wpConfig = mService.mWindowManager.computeWindowPanelConfiguration(getWindowPanel());
+        Configuration wpConfig = mService.mWindowManager.computeWindowPanelConfiguration(mService.mConfiguration, r.appToken, mService.mWindowManager.mCornerstoneState);
+        if(DEBUG_CONFIGURATION) {
+            Slog.v(TAG, "Starting Values");
+            Slog.v(TAG, "\tCornerstone State: " + mService.mWindowManager.mCornerstoneState);
+            Slog.v(TAG, "\tActivity " + r);
+            Slog.v(TAG, "\tActivity Configuration " + r.configuration);
+            Slog.v(TAG, "\tActivity forceNewConfig " + r.forceNewConfig);
+            Slog.v(TAG, "\tPanel: " + getWindowPanel() + " WP: " + wpConfig);
+            Slog.v(TAG, "\tglobalChanges " + globalChanges);
+            Slog.v(TAG, "\tAMS.mConfiguration " + mService.mConfiguration);
+            Slog.v(TAG, "\tLast Activity Config Updated: " + mLastActivityConfigUpdated);
+            RuntimeException here = new RuntimeException("here");
+            here.fillInStackTrace();
+            Slog.i(TAG, "Called from:", here);
+        }
+
         // Okay we now are going to make this activity have the new config.
         // But then we need to figure out how it needs to deal with that.
         Configuration oldConfig = r.configuration;
-        r.configuration = newConfig;
+        /**
+         * Author: Onskreen
+         * Date: 07/01/2012
+         *
+         * The new Activity Configuration needs to actually include:
+         * - The changes from the AMS.mConfiguration which are non-WindowPanel specific
+         * - TODO Any new size Configuration info from the Window Panel which contains this ActivityRecord
+         */
+        //r.configuration = newConfig;
+        mService.mWindowManager.updateNonWindowPanelConfigurationFrom(r.configuration, newConfig);
+
+        if(DEBUG_CONFIGURATION) {
+            Slog.v(TAG, "New Activity Configuration: " + r.configuration);
+        }
 
         // Determine what has changed.  May be nothing, if this is a config
         // that has come back from the app after going idle.  In that case
         // we just want to leave the official config object now in the
         // activity and do nothing else.
-        final int changes = oldConfig.diff(newConfig);
+        //final int changes = oldConfig.diff(newConfig);
+        int changes = mService.mWindowManager.diffNonWindowPanelConfiguration(oldConfig, newConfig);
+        if(DEBUG_CONFIGURATION) {
+            Slog.v(TAG, "Non WindowPanel Changes between " + oldConfig + " and " + newConfig);
+            Slog.v(TAG, "\t" + changes);
+        }
+        boolean nonWPChanges = true;
         if (changes == 0 && !r.forceNewConfig) {
             if (DEBUG_SWITCH || DEBUG_CONFIGURATION) Slog.v(TAG,
                     "Configuration no differences in " + r);
+            //return true;
+            nonWPChanges = false;
+        }
+
+        /**
+         * Author: Onskreen
+         * Date: 07/01/2012
+         *
+         * Include WP specific changes. we assume the Activity has been launched/executing with the
+         * appropriate Window Panel Configuration and can diff against that.
+         */
+        if(DEBUG_CONFIGURATION) {
+            Slog.v(TAG, "Including Window Panel Changes between " + r.configuration + " and " + wpConfig);
+        }
+        int wpChanges = mService.mWindowManager.updateWindowPanelConfigurationFrom(r.configuration, wpConfig);
+        changes |= wpChanges;
+        if(DEBUG_CONFIGURATION) {
+            Slog.v(TAG, "Updated r.configuration " + r.configuration);
+            Slog.v(TAG, "WP Changes\t" + wpChanges);
+        }
+        if(!nonWPChanges &&
+                wpChanges == 0 &&
+                !r.forceNewConfig) {
+            if(DEBUG_CONFIGURATION) {
+                Slog.v(TAG, "No Configuration Changes Found" );
+            }
+            mLastActivityConfigUpdateChangeFlags = wpChanges;
             return true;
+        } else {							//Only updating due to WP changes
+            if(DEBUG_CONFIGURATION) {
+                Slog.v(TAG, "mLastActivityConfigUpdated " + mLastActivityConfigUpdated);
+                Slog.v(TAG, "mLastActivityConfigUpdateChangeFlags " + mLastActivityConfigUpdateChangeFlags);
+            }
+            if(mLastActivityConfigUpdated == r &&
+                    changes==mLastActivityConfigUpdateChangeFlags) {
+                if(DEBUG_CONFIGURATION) {
+                    Slog.e(TAG, "ActivityRecord: " + r + " just tried to update due to WP config differences. Ignore this one to be safe");
+                    Slog.e(TAG, "This indicates we had a Configuration sequencing mistake somewhere.");
+                }
+                return true;
+            } else {
+                //Keep track of what and how we are updating based on WP changes so we don't try to repeat
+                mLastActivityConfigUpdated = r;
+                mLastActivityConfigUpdateChangeFlags = changes;
+                r.configuration.seq++;
+            }
         }
 
         // If the activity isn't currently running, just leave the new
@@ -4468,13 +5116,21 @@ final class ActivityStack {
             r.forceNewConfig = false;
             return true;
         }
-        
+
         // Figure out how to handle the changes between the configurations.
         if (DEBUG_SWITCH || DEBUG_CONFIGURATION) {
             Slog.v(TAG, "Checking to restart " + r.info.name + ": changed=0x"
                     + Integer.toHexString(changes) + ", handles=0x"
                     + Integer.toHexString(r.info.getRealConfigChanged())
                     + ", newConfig=" + newConfig);
+            Slog.v(TAG, "Activity: " + r);
+            Slog.v(TAG, "ActivityInfo: " + r.info);
+            Slog.v(TAG, "r.configChanges: " + r.info.configChanges);
+            Slog.v(TAG, "r.info.CONFIG_FONT_SCALE: " + r.info.CONFIG_FONT_SCALE);
+            Slog.v(TAG, "r.info.CONFIG_ORIENTATION: " + r.info.CONFIG_ORIENTATION);
+            Slog.v(TAG, "r.info.CONFIG_SCREEN_LAYOUT: " + r.info.CONFIG_SCREEN_LAYOUT);
+            Slog.v(TAG, "r.info.CONFIG_SCREEN_SIZE: " + r.info.CONFIG_SCREEN_SIZE);
+            Slog.v(TAG, "r.info.CONFIG_SMALLEST_SCREEN_SIZE: " + r.info.CONFIG_SMALLEST_SCREEN_SIZE);
         }
         if ((changes&(~r.info.getRealConfigChanged())) != 0 || r.forceNewConfig) {
             // Aha, the activity isn't handling the change, so DIE DIE DIE.
@@ -4546,16 +5202,22 @@ final class ActivityStack {
         EventLog.writeEvent(andResume ? EventLogTags.AM_RELAUNCH_RESUME_ACTIVITY
                 : EventLogTags.AM_RELAUNCH_ACTIVITY, System.identityHashCode(r),
                 r.task.taskId, r.shortComponentName);
-        
+
         r.startFreezingScreenLocked(r.app, 0);
-        
+
         try {
+            /**
+             * Author: Onskreen
+             * Date: 26/12/2011
+             *
+             * r.configuration contains all the changes.
+             */
             if (DEBUG_SWITCH || DEBUG_STATES) Slog.i(TAG,
                     (andResume ? "Relaunching to RESUMED " : "Relaunching to PAUSED ")
                     + r);
             r.forceNewConfig = false;
             r.app.thread.scheduleRelaunchActivity(r.appToken, results, newIntents,
-                    changes, !andResume, new Configuration(mService.mConfiguration));
+                    changes, !andResume, new Configuration(r.configuration/**mService.mConfiguration**/));
             // Note: don't need to call pauseIfSleepingLocked() here, because
             // the caller will only pass in 'andResume' if this activity is
             // currently resumed, which implies we aren't sleeping.
@@ -4566,7 +5228,7 @@ final class ActivityStack {
         if (andResume) {
             r.results = null;
             r.newIntents = null;
-            if (mMainStack) {
+            if (mMainStack || mCornerstoneStack|| mCornerstonePanelStack) {
                 mService.reportResumedActivityLocked(r);
             }
             r.state = ActivityState.RESUMED;
@@ -4577,8 +5239,31 @@ final class ActivityStack {
 
         return true;
     }
-    
+
     public void dismissKeyguardOnNextActivityLocked() {
         mDismissKeyguardOnNextActivity = true;
     }
+
+    /**
+     * Author: Onskreen
+     * Date: 07/01/2012
+     *
+     * Utility to get the WP_Panel of this ActivityStack
+     */
+    private WindowManagerService.WP_Panel getWindowPanel() {
+        WindowManagerService.WP_Panel conf = WindowManagerService.WP_Panel.UNDEFINED;
+        if(mMainStack) {
+            return WindowManagerService.WP_Panel.MAIN_PANEL;
+        } else if(mCornerstonePanelStack && mCornerstonePanelIndex == 0) {
+			return WindowManagerService.WP_Panel.CS_APP_0;
+        } else if(mCornerstonePanelStack && mCornerstonePanelIndex == 1) {
+			return WindowManagerService.WP_Panel.CS_APP_1;
+        } else if(mCornerstoneStack) {
+			return WindowManagerService.WP_Panel.CORNERSTONE;
+        } else {
+            //Should never happen
+            return WindowManagerService.WP_Panel.DISPLAY;
+        }
+
+    }
 }
diff --git a/frameworks/base/services/java/com/android/server/wm/AppWindowToken.java b/frameworks/base/services/java/com/android/server/wm/AppWindowToken.java
index 6ecbb8e..f2e34ae 100644
--- a/frameworks/base/services/java/com/android/server/wm/AppWindowToken.java
+++ b/frameworks/base/services/java/com/android/server/wm/AppWindowToken.java
@@ -20,6 +20,7 @@ import static android.view.WindowManager.LayoutParams.TYPE_APPLICATION_STARTING;
 
 import com.android.server.input.InputApplicationHandle;
 import com.android.server.wm.WindowManagerService.H;
+import com.android.server.wm.WindowManagerService.WindowPanel;
 
 import android.content.pm.ActivityInfo;
 import android.os.Message;
@@ -97,9 +98,20 @@ class AppWindowToken extends WindowToken {
     // Input application handle used by the input dispatcher.
     final InputApplicationHandle mInputApplicationHandle;
 
+    /**
+     * Author: Onskreen
+     * Date: 11/02/2010
+     *
+     * Flag indiciating if token is the cornerstone.
+     */
+    boolean isCornerstone;
+
+    final WindowManagerService mService;
+
     AppWindowToken(WindowManagerService _service, IApplicationToken _token) {
         super(_service, _token.asBinder(),
                 WindowManager.LayoutParams.TYPE_APPLICATION, true);
+	mService = _service;
         appWindowToken = this;
         appToken = _token;
         mInputApplicationHandle = new InputApplicationHandle(this);
@@ -279,4 +291,46 @@ class AppWindowToken extends WindowToken {
         }
         return stringName;
     }
-}
+
+    /**
+     * Author: Onskreen
+     * Date: 11/03/2011
+     *
+     * Utility method to check if the token is in the main panel or not. Returns true
+     * if can't figure out which panel it is in
+     */
+     public boolean isInMainPanelWindowPanel() {
+		final ArrayList<WindowPanel> WindowPanels = mService.getWindowPanels();
+		for(int i=0; i<WindowPanels.size(); i++) {
+			WindowPanel wp = WindowPanels.get(i);
+			if(wp.isMainPanel()) {
+				if(wp.contains(token)) {
+					return true;
+				} else {
+					break;
+				}
+			}
+		}
+		return false;
+     }
+
+    /**
+     * Author: Onskreen
+     * Date: 19/04/2011
+     *
+     * Utility method to check if the token is in the cornerstone panel or not.
+     * Returns true if it's in cornerstone panel else false.
+     */
+    public boolean isInCornerstonePanelWindowPanel() {
+		final ArrayList<WindowPanel> WindowPanels = mService.getWindowPanels();
+		for(int i=0; i<WindowPanels.size(); i++) {
+			WindowPanel wp = WindowPanels.get(i);
+			if(wp.isCornerstonePanel()) {
+				if(wp.contains(groupId)) {
+					return true;
+				}
+			}
+		}
+		return false;
+    }
+}
\ No newline at end of file
diff --git a/frameworks/base/services/java/com/android/server/wm/DimAnimator.java b/frameworks/base/services/java/com/android/server/wm/DimAnimator.java
index e8f56c8..77cc854 100644
--- a/frameworks/base/services/java/com/android/server/wm/DimAnimator.java
+++ b/frameworks/base/services/java/com/android/server/wm/DimAnimator.java
@@ -39,6 +39,14 @@ class DimAnimator {
     
     int mLastDimWidth, mLastDimHeight;
 
+    /**
+     * Author: Onskreen
+     * Date: 06/05/2011
+     *
+     * Setting DimAnimator position variables
+     */
+    int mDimX = 0, mDimY = 0;
+
     DimAnimator (SurfaceSession session) {
         if (mDimSurface == null) {
             try {
@@ -70,8 +78,8 @@ class DimAnimator {
     void updateParameters(final Resources res, final Parameters params, final long currentTime) {
         // Multiply by 1.5 so that rotating a frozen surface that includes this does not expose a
         // corner.
-        final int dw = (int) (params.mDimWidth * 1.5);
-        final int dh = (int) (params.mDimHeight * 1.5);
+        final int dw = (int) (params.mDimWidth);//(int) (params.mDimWidth * 1.5);
+        final int dh = (int) (params.mDimHeight);//(int) (params.mDimHeight * 1.5);
         final WindowStateAnimator winAnimator = params.mDimWinAnimator;
         final float target = params.mDimTarget;
         if (!mDimShown) {
@@ -82,7 +90,17 @@ class DimAnimator {
                 mLastDimWidth = dw;
                 mLastDimHeight = dh;
                 // back off position so mDimXXX/4 is before and mDimXXX/4 is after
-                mDimSurface.setPosition(-1 * dw / 6, -1 * dh /6);
+                //mDimSurface.setPosition(-1 * dw / 6, -1 * dh /6);
+                /**
+                 * Author: Onskreen
+                 * Date: 30/03/2011
+                 *
+                 * set the correct position based on the x,y set in
+                 * performLayoutAndPlaceSurfacesLockedInner method.
+                 * NOTE (4.8.2011): Dimming feature reverted for now until can
+                 * be resolved why causing issue on Viewsonic.
+                 */
+                mDimSurface.setPosition(mDimX, mDimY);
                 mDimSurface.setSize(dw, dh);
                 mDimSurface.show();
             } catch (RuntimeException e) {
@@ -93,8 +111,11 @@ class DimAnimator {
             mLastDimHeight = dh;
             mDimSurface.setSize(dw, dh);
             // back off position so mDimXXX/4 is before and mDimXXX/4 is after
-            mDimSurface.setPosition(-1 * dw / 6, -1 * dh /6);
-        }
+            //mDimSurface.setPosition(-1 * dw / 6, -1 * dh /6);
+            mDimSurface.setPosition(mDimX, mDimY);
+		} else {
+			mDimSurface.setPosition(mDimX, mDimY);
+		}
 
         mDimSurface.setLayer(winAnimator.mAnimLayer - WindowManagerService.LAYER_OFFSET_DIM);
 
diff --git a/frameworks/base/services/java/com/android/server/wm/DimSurface.java b/frameworks/base/services/java/com/android/server/wm/DimSurface.java
index 9fca418..a027fde 100644
--- a/frameworks/base/services/java/com/android/server/wm/DimSurface.java
+++ b/frameworks/base/services/java/com/android/server/wm/DimSurface.java
@@ -30,6 +30,14 @@ class DimSurface {
     int mLayer = -1;
     int mLastDimWidth, mLastDimHeight;
 
+    /**
+     * Author: Onskreen
+     * Date: 21/12/2011
+     *
+     * Setting DimSurface position variables
+     */
+    int mDimX = 0, mDimY = 0;
+
     DimSurface(SurfaceSession session) {
         if (mDimSurface == null) {
             try {
@@ -65,7 +73,15 @@ class DimSurface {
             try {
                 mLastDimWidth = dw;
                 mLastDimHeight = dh;
-                mDimSurface.setPosition(0, 0);
+                //mDimSurface.setPosition(0, 0);
+                /**
+                 * Author: Onskreen
+                 * Date: 21/12/2011
+                 *
+                 * set the correct position based on the x,y set in
+                 * performLayoutAndPlaceSurfacesLockedInner method.
+                 */
+                mDimSurface.setPosition(mDimX, mDimY);
                 mDimSurface.setSize(dw, dh);
                 mDimSurface.setLayer(layer);
                 mDimSurface.show();
@@ -106,4 +122,4 @@ class DimSurface {
         pw.print(prefix); pw.print("mLastDimWidth="); pw.print(mLastDimWidth);
                 pw.print(" mLastDimWidth="); pw.println(mLastDimWidth);
     }
-}
+}
\ No newline at end of file
diff --git a/frameworks/base/services/java/com/android/server/wm/InputMonitor.java b/frameworks/base/services/java/com/android/server/wm/InputMonitor.java
index 285d230..d9b22ac 100644
--- a/frameworks/base/services/java/com/android/server/wm/InputMonitor.java
+++ b/frameworks/base/services/java/com/android/server/wm/InputMonitor.java
@@ -344,76 +344,83 @@ final class InputMonitor implements InputManagerService.Callbacks {
             }
         }
     }
-    
+
     public void setFocusedAppLw(AppWindowToken newApp) {
         // Focused app has changed.
         if (newApp == null) {
             mService.mInputManager.setFocusedApplication(null);
         } else {
-            final InputApplicationHandle handle = newApp.mInputApplicationHandle;
+            /**
+             * Author: Onskreen
+             * Date: 10/12/2011
+             *
+             * commented out to support the user input for
+             * multiple visible apps running in Cornerstone.
+             */
+            /*final InputApplicationHandle handle = newApp.mInputApplicationHandle;
             handle.name = newApp.toString();
             handle.dispatchingTimeoutNanos = newApp.inputDispatchingTimeoutNanos;
 
-            mService.mInputManager.setFocusedApplication(handle);
+            mService.mInputManager.setFocusedApplication(handle);*/
         }
     }
diff --git a/frameworks/base/services/java/com/android/server/wm/Session.java b/frameworks/base/services/java/com/android/server/wm/Session.java
index de877c6..512ef9d 100644
--- a/frameworks/base/services/java/com/android/server/wm/Session.java
+++ b/frameworks/base/services/java/com/android/server/wm/Session.java
@@ -442,4 +437,20 @@ final class Session extends IWindowSession.Stub
     public String toString() {
         return mStringName;
     }
+
+   /**
+    * Author: Onskreen
+    * Date: 14/02/2011
+    *
+    * Trigger a move of all the contents of a WindowPanel to the top of the z-order. Also triggers move
+    * of all tokens/window panels that are in the same panel to the top. This is to ensure that the z-order
+    * contains all the app tokesn in order from the same panel at the top.
+    *
+    * This does not necessarily indicate a change in visibility because multiple WP's are visible at the
+    * same time, but is used in the context of focus changes so that the currently focused app
+    * is the top of the mWindows z-order.
+    */
+    public void handleFocusChange(IBinder token) {
+	  mService.handleFocusChangeLocked(token);
+    }
 }
\ No newline at end of file
diff --git a/frameworks/base/services/java/com/android/server/wm/WindowAnimator.java b/frameworks/base/services/java/com/android/server/wm/WindowAnimator.java
index db3b2bd..fb8be8e 100644
--- a/frameworks/base/services/java/com/android/server/wm/WindowAnimator.java
+++ b/frameworks/base/services/java/com/android/server/wm/WindowAnimator.java
@@ -12,6 +12,8 @@ import static com.android.server.wm.WindowManagerService.LayoutFields.SET_FORCE_
 import static com.android.server.wm.WindowManagerService.H.SET_DIM_PARAMETERS;
 
 import android.content.Context;
+import android.graphics.Rect;
+import android.os.IBinder;
 import android.os.SystemClock;
 import android.util.Log;
 import android.util.Slog;
@@ -21,6 +23,7 @@ import android.view.WindowManagerPolicy;
 import android.view.animation.Animation;
 
 import com.android.internal.policy.impl.PhoneWindowManager;
+import com.android.server.wm.WindowManagerService.WindowPanel;
 
 import java.io.PrintWriter;
 import java.util.ArrayList;
@@ -131,8 +134,19 @@ public class WindowAnimator {
             if (mWindowAnimationBackgroundSurface == null) {
                 mWindowAnimationBackgroundSurface = new DimSurface(mService.mFxSession);
             }
-            final int dw = mDw;
-            final int dh = mDh;
+            /**
+             * Author: Onskreen
+             * Date: 11/23/2012
+             *
+             * Sets the DimSurface width and height as per panel
+             * rect's width/height to restrict the DimSurface anim
+             * by not applying the screen width/height.
+             */
+            final int dw = target.mFrame.width();//mDw;
+            final int dh = target.mFrame.height();//mDh;
+			mWindowAnimationBackgroundSurface.mDimX = target.mFrame.left;
+			mWindowAnimationBackgroundSurface.mDimY = target.mFrame.top;
+
             mWindowAnimationBackgroundSurface.show(dw, dh,
                     target.mWinAnimator.mAnimLayer - WindowManagerService.LAYER_OFFSET_DIM,
                     mWindowAnimationBackgroundColor);
@@ -519,8 +533,42 @@ public class WindowAnimator {
         if (winAnimator.mSurfaceShown &&
                 (dimWinAnimator == null || !dimWinAnimator.mSurfaceShown
                 || dimWinAnimator.mAnimLayer < winAnimator.mAnimLayer)) {
-            mService.mH.sendMessage(mService.mH.obtainMessage(SET_DIM_PARAMETERS,
+            /**
+             * Author: Onskreen
+             * Date: 21/12/2012
+             *
+             * Sets the dimming rect and position as per panel(main or
+             * either of cornerstone panels)'s current position in which
+             * this window is running.
+             */
+            if(winAnimator.mWin != null) {
+                if(winAnimator.mWin.mAppToken != null) {
+                    IBinder token = winAnimator.mWin.mAppToken.token;
+                    if(token != null) {
+						WindowPanel wp = mService.findWindowPanel(token);
+						if(wp != null) {
+							Rect dimRect = new Rect();
+							dimRect.set(wp.getPos());
+							mDimAnimator.mDimX = dimRect.left;
+							mDimAnimator.mDimY = dimRect.top;
+							mService.mH.sendMessage(mService.mH.obtainMessage(SET_DIM_PARAMETERS,
+								new DimAnimator.Parameters(winAnimator, dimRect.width(), dimRect.height(), target)));
+						} else {
+							mService.mH.sendMessage(mService.mH.obtainMessage(SET_DIM_PARAMETERS,
+									new DimAnimator.Parameters(winAnimator, width, height, target)));
+						}
+                    } else {
+                        mService.mH.sendMessage(mService.mH.obtainMessage(SET_DIM_PARAMETERS,
+                                new DimAnimator.Parameters(winAnimator, width, height, target)));
+                    }
+                } else {
+                    mService.mH.sendMessage(mService.mH.obtainMessage(SET_DIM_PARAMETERS,
+                            new DimAnimator.Parameters(winAnimator, width, height, target)));
+                }
+            } else {
+                mService.mH.sendMessage(mService.mH.obtainMessage(SET_DIM_PARAMETERS,
                     new DimAnimator.Parameters(winAnimator, width, height, target)));
+            }
         }
     }
 
diff --git a/frameworks/base/services/java/com/android/server/wm/WindowManagerService.java b/frameworks/base/services/java/com/android/server/wm/WindowManagerService.java
index 3013223..1289e25 100755
--- a/frameworks/base/services/java/com/android/server/wm/WindowManagerService.java
+++ b/frameworks/base/services/java/com/android/server/wm/WindowManagerService.java
@@ -27,11 +27,16 @@ import static android.view.WindowManager.LayoutParams.FLAG_SHOW_WALLPAPER;
 import static android.view.WindowManager.LayoutParams.LAST_APPLICATION_WINDOW;
 import static android.view.WindowManager.LayoutParams.LAST_SUB_WINDOW;
 import static android.view.WindowManager.LayoutParams.TYPE_APPLICATION_STARTING;
+import static android.view.WindowManager.LayoutParams.TYPE_APPLICATION_PANEL;
 import static android.view.WindowManager.LayoutParams.TYPE_BASE_APPLICATION;
 import static android.view.WindowManager.LayoutParams.TYPE_DREAM;
 import static android.view.WindowManager.LayoutParams.TYPE_INPUT_METHOD;
 import static android.view.WindowManager.LayoutParams.TYPE_INPUT_METHOD_DIALOG;
 import static android.view.WindowManager.LayoutParams.TYPE_WALLPAPER;
+import static android.view.WindowManager.LayoutParams.FLAG_LAYOUT_IN_SCREEN;
+import static android.view.WindowManager.LayoutParams.FLAG_FULLSCREEN;
+import static android.view.WindowManager.LayoutParams.FLAG_LAYOUT_INSET_DECOR;
+import static android.view.WindowManager.LayoutParams.FLAG_LAYOUT_NO_LIMITS;
 
 import com.android.internal.app.IBatteryStats;
 import com.android.internal.policy.PolicyManager;
@@ -63,6 +68,8 @@ import android.content.pm.ActivityInfo;
 import android.content.pm.PackageManager;
 import android.content.res.CompatibilityInfo;
 import android.content.res.Configuration;
+import android.content.res.Resources;
+import android.content.res.XmlResourceParser;
 import android.graphics.Bitmap;
 import android.graphics.Canvas;
 import android.graphics.Matrix;
@@ -98,6 +104,7 @@ import android.util.EventLog;
 import android.util.FloatMath;
 import android.util.Log;
 import android.util.LogPrinter;
+import android.util.LocaleUtil;
 import android.util.Pair;
 import android.util.Slog;
 import android.util.SparseIntArray;
@@ -132,6 +139,8 @@ import android.view.animation.AnimationUtils;
 import android.view.animation.DecelerateInterpolator;
 import android.view.animation.Interpolator;
 import android.view.animation.ScaleAnimation;
+import android.view.animation.Transformation;
+import android.view.animation.TranslateAnimation;
 
 import java.io.BufferedWriter;
 import java.io.DataInputStream;
@@ -152,39 +161,76 @@ import java.util.HashMap;
 import java.util.HashSet;
 import java.util.Iterator;
 import java.util.List;
+import java.util.Locale;
+
+import org.xmlpull.v1.XmlPullParser;
+import org.xmlpull.v1.XmlPullParserException;
 
 /** {@hide} */
 public class WindowManagerService extends IWindowManager.Stub
         implements Watchdog.Monitor, WindowManagerPolicy.WindowManagerFuncs {
     static final String TAG = "WindowManager";
+    /**
+     * Author: Onskreen
+     * Date: 24/01/2011
+     *
+     * Debug flag for window panel positioning
+     */
+    static final boolean DEBUG_WP_POSITIONS = true;
+
+
+    /**
+     * Author: Onskreen
+     * Date: 24/01/2011
+     *
+     * Debug flag for window panel groupings
+     */
+    static final boolean DEBUG_WP_GROUPING = true;
+
+    /**
+     * Author: Onskreen
+     * Date: 26/12/2011
+     *
+     * Debug flag for window panel groupings
+     */
+    static final boolean DEBUG_WP_CONFIG = false;
+
+    /**
+     * Author: Onskreen
+     * Date: 24/01/2011
+     *
+     * Debug flag for cornerstone specific logic
+     */
+    static final boolean DEBUG_CORNERSTONE = true;
+
     static final boolean DEBUG = false;
-    static final boolean DEBUG_ADD_REMOVE = false;
-    static final boolean DEBUG_FOCUS = false;
+    static final boolean DEBUG_ADD_REMOVE = true;
+    static final boolean DEBUG_FOCUS = true;
     static final boolean DEBUG_ANIM = false;
-    static final boolean DEBUG_LAYOUT = false;
-    static final boolean DEBUG_RESIZE = false;
+    static final boolean DEBUG_LAYOUT = true;
+    static final boolean DEBUG_RESIZE = true;
     static final boolean DEBUG_LAYERS = false;
     static final boolean DEBUG_INPUT = false;
     static final boolean DEBUG_INPUT_METHOD = false;
-    static final boolean DEBUG_VISIBILITY = false;
-    static final boolean DEBUG_WINDOW_MOVEMENT = false;
-    static final boolean DEBUG_TOKEN_MOVEMENT = false;
+    static final boolean DEBUG_VISIBILITY = true;
+    static final boolean DEBUG_WINDOW_MOVEMENT = true;
+    static final boolean DEBUG_TOKEN_MOVEMENT = true;
     static final boolean DEBUG_ORIENTATION = false;
     static final boolean DEBUG_APP_ORIENTATION = false;
     static final boolean DEBUG_CONFIGURATION = false;
     static final boolean DEBUG_APP_TRANSITIONS = false;
     static final boolean DEBUG_STARTING_WINDOW = false;
-    static final boolean DEBUG_REORDER = false;
+    static final boolean DEBUG_REORDER = true;
     static final boolean DEBUG_WALLPAPER = false;
     static final boolean DEBUG_DRAG = false;
     static final boolean DEBUG_SCREEN_ON = false;
     static final boolean DEBUG_SCREENSHOT = false;
     static final boolean DEBUG_BOOT = false;
-    static final boolean DEBUG_LAYOUT_REPEATS = false;
+    static final boolean DEBUG_LAYOUT_REPEATS = true;
     static final boolean DEBUG_SURFACE_TRACE = false;
-    static final boolean DEBUG_WINDOW_TRACE = false;
+    static final boolean DEBUG_WINDOW_TRACE = true;
     static final boolean SHOW_SURFACE_ALLOC = false;
-    static final boolean SHOW_TRANSACTIONS = false;
+    static final boolean SHOW_TRANSACTIONS = true;
     static final boolean SHOW_LIGHT_TRANSACTIONS = false || SHOW_TRANSACTIONS;
     static final boolean HIDE_STACK_CRAWLS = true;
     static final int LAYOUT_REPEAT_THRESHOLD = 4;
@@ -389,6 +435,18 @@ public class WindowManagerService extends IWindowManager.Stub
     final ArrayList<WindowState> mWindows = new ArrayList<WindowState>();
 
     /**
+     * Author: Onskreen
+     * Date: 24/01/2011
+     *
+     * Rich tracking of Window Panels. Enables tracking of multiple groupIds
+     * contained in the same Window Panel as seen with Activities which are
+     * not marked as 'appFullScreen' that can be logically associated with
+     * the WindowPanel from which they were launched, but actually have a distinct
+     * groupId. Distinct groupIds should be associated with exactly one Window Panel.
+     */
+    final ArrayList<WindowPanel> mWindowPanels = new ArrayList<WindowPanel>();
+
+    /**
      * Fake windows added to the window manager.  Note: ordered from top to
      * bottom, opposite of mWindows.
      */
@@ -663,7 +721,16 @@ public class WindowManagerService extends IWindowManager.Stub
                     final ArrayList<WindowStateAnimator> winAnimators = mAnimator.mWinAnimators;
                     winAnimators.clear();
                     final int N = mWindows.size();
-                    for (int i = 0; i < N; i++) {
+                    /**
+                     * Author: Onskreen
+                     * Date: 11/19/2012
+                     *
+                     * This method triggers animation by WindowStateAnimator.animate() method.
+                     * The loop must start from mWindows.size()-1 to 0 to recify the
+                     * Z-order list of Windows. Hence, animation is applied in the order
+                     * from top to bottom Windows.
+                     */
+                    for (int i = N-1; i >= 0; i--) {
                         final WindowStateAnimator winAnimator = mWindows.get(i).mWinAnimator;
                         if (winAnimator.mSurface != null) {
                             winAnimators.add(winAnimator);
@@ -761,8 +828,6 @@ public class WindowManagerService extends IWindowManager.Stub
 
     final Configuration mTempConfiguration = new Configuration();
 
-    private DynamicPManager mDPM;
-    
     // The desired scaling factor for compatible apps.
     float mCompatibleScreenScale;
 
@@ -771,6 +836,85 @@ public class WindowManagerService extends IWindowManager.Stub
     // For example, when this flag is true, there will be no wallpaper service.
     final boolean mOnlyCore;
 
+    /**
+     * Author: Onskreen
+     * Date: 12/01/2011
+     *
+     * Cornerstone Panel Constants. These are ideal values based on full layout in landscape mode.
+     */
+    int mCornerstonePanelLandscapeWidth;
+    int mCornerstonePanelLandscapeHeight;
+    int mCornerstoneHandlerLandscapeWidth;
+    int mCornerstoneAppHeaderLandscapeHeight;
+
+    /**
+     * Author: Onskreen
+     * Date: 13/04/2011
+     *
+     * Cornerstone Panel Constants. These are ideal values based on full layout in portrait mode.
+     *
+     */
+    int mCornerstonePanelPortraitWidth;
+    int mCornerstonePanelPortraitHeight;
+    int mCornerstonePanelPortraitGutter;
+    int mCornerstoneHandlerPortraitWidth;
+    int mCornerstoneAppHeaderPortraitHeight;
+
+    /**
+     * Author: Onskreen
+     * Date: 26/12/2011
+     *
+     * Indicates the panel of the screen in terms of Window Panels
+     */
+    public enum WP_Panel {
+		CORNERSTONE,			//Cornerstone itself
+		CS_APP_0,				//Cornerstone App:0
+		CS_APP_1,				//Cornerstone App:1
+		MAIN_PANEL,				//Main Panel
+		DISPLAY,				//Entire Display (minus decor)
+		UNDEFINED				//Not Used
+    };
+
+    /**
+     * Author: Onskreen
+     * Date: 25/02/2011
+     *
+     * Indicates if Cornerstone is currently in the midst of a state change animation.
+     * Effects during layout and surface updates.
+     */
+    public boolean mCornerstoneStateChangeAnimating = false;
+    /**
+     * Author: Onskreen
+     * Date: 03/01/2012
+     *
+     * Indicates if Cornerstone is currently in the midst of a state change.
+     */
+    public boolean mCornerstoneStateChangeProcessing = false;
+
+    /**
+     * Author: Onskreen
+     * Date: 24/04/2011
+     *
+     * Cornerstone State Value.
+     *
+     */
+    public enum Cornerstone_State{
+		RUNNING_OPEN,				//Running and fully visible
+		RUNNING_CLOSED,				//Running but minimized so panels are not visible to user
+		TERMINATED					//Not currently running
+    }
+    public Cornerstone_State mCornerstoneState = Cornerstone_State.TERMINATED;
+
+    /**
+     * Author: Onskreen
+     * Date: 26/09/2011
+     *
+     * CSLauncher Pkg variable.
+     *
+     * TODO hardcoded for now, to be cleaned up.
+     */
+    static final String CSLAUNCHER = "com.onskreen.cornerstone.launcher";
+
     public static WindowManagerService main(Context context,
             PowerManagerService pm, boolean haveInputMethods, boolean allowBootMsgs,
             boolean onlyCore) {
@@ -915,8 +1059,6 @@ public class WindowManagerService extends IWindowManager.Stub
         mInputManager = new InputManagerService(context, mInputMonitor);
         mAnimator = new WindowAnimator(this, context, mPolicy);
 
-        mDPM = new DynamicPManager();
-        
         PolicyThread thr = new PolicyThread(mPolicy, this, context, pm);
         thr.start();
 
@@ -933,12 +1075,154 @@ public class WindowManagerService extends IWindowManager.Stub
 
         // Add ourself to the Watchdog monitors.
         Watchdog.getInstance().addMonitor(this);
-        mFxSession = new SurfaceSession();    
-        
-        
+        mFxSession = new SurfaceSession();
+
         Surface.openTransaction();
         createWatermark();
         Surface.closeTransaction();
+
+        /**
+         * Author: Onskreen
+         * Date: 20/07/2011
+         *
+         * populate the layout rect constants for portrait and landscape modes.
+         */
+        XmlResourceParser xpp = null;
+        WindowManager wm = (WindowManager)context.getSystemService(Context.WINDOW_SERVICE);
+        Display display = wm.getDefaultDisplay();
+        final int dw = display.getWidth();
+        final int dh = display.getHeight();
+        try {
+            Resources res = context.getResources();
+            xpp = res.getXml(com.android.internal.R.xml.cornerstone);
+            xpp.next();
+            int eventType = xpp.getEventType();
+            String tag;
+            while (eventType != XmlPullParser.END_DOCUMENT) {
+                if(eventType == XmlPullParser.START_DOCUMENT) {
+                } else if(eventType == XmlPullParser.START_TAG) {
+                     tag = xpp.getName();
+                     if(tag.equals("layout")){
+                         int width = xpp.getAttributeIntValue(null, "width", 0);
+                         int height = xpp.getAttributeIntValue(null, "height", 0);
+                         if((dw == width) && (dh == height)) {
+                             xpp.next();
+                             tag = xpp.getName();
+                             if(tag.equals("landscape")) {
+                                 xpp.next();
+                                 tag = xpp.getName();
+                                 if(tag.equals("width")){
+                                    xpp.next();
+                                    mCornerstonePanelLandscapeWidth = Integer.parseInt(xpp.getText());
+                                    xpp.next();
+                                 }
+                                 xpp.next();
+                                 tag = xpp.getName();
+                                 if(tag.equals("height")){
+                                    xpp.next();
+                                    mCornerstonePanelLandscapeHeight = Integer.parseInt(xpp.getText());
+                                    xpp.next();
+                                 }
+                                 xpp.next();
+                                 tag = xpp.getName();
+                                 if(tag.equals("handler")){
+                                    xpp.next();
+                                    tag = xpp.getName();
+                                    if(tag.equals("width")){
+                                        xpp.next();
+                                        mCornerstoneHandlerLandscapeWidth = Integer.parseInt(xpp.getText());
+                                        xpp.next();
+                                    }
+                                    xpp.next();
+                                 }
+                                 xpp.next();
+                                 tag = xpp.getName();
+                                 if(tag.equals("appheader")){
+                                    xpp.next();
+                                    tag = xpp.getName();
+                                    if(tag.equals("height")){
+                                        xpp.next();
+                                        mCornerstoneAppHeaderLandscapeHeight = Integer.parseInt(xpp.getText());
+                                        xpp.next();
+                                    }
+                                    xpp.next();
+                                 }
+                                 xpp.next();
+                             }
+
+                             xpp.next();
+                             tag = xpp.getName();
+                             if(tag.equals("portrait")) {
+                                 xpp.next();
+                                 tag = xpp.getName();
+                                 if(tag.equals("width")){
+                                    xpp.next();
+                                    mCornerstonePanelPortraitWidth = Integer.parseInt(xpp.getText());
+                                    xpp.next();
+                                 }
+                                 xpp.next();
+                                 tag = xpp.getName();
+                                 if(tag.equals("height")){
+                                    xpp.next();
+                                    mCornerstonePanelPortraitHeight = Integer.parseInt(xpp.getText());
+                                    xpp.next();
+                                 }
+                                 xpp.next();
+                                 tag = xpp.getName();
+                                 if(tag.equals("handler")){
+                                    xpp.next();
+                                    tag = xpp.getName();
+                                    if(tag.equals("width")){
+                                        xpp.next();
+                                        mCornerstoneHandlerPortraitWidth = Integer.parseInt(xpp.getText());
+                                        xpp.next();
+                                    }
+                                    xpp.next();
+                                 }
+                                 xpp.next();
+                                 tag = xpp.getName();
+                                 if(tag.equals("appheader")){
+                                    xpp.next();
+                                    tag = xpp.getName();
+                                    if(tag.equals("height")){
+                                        xpp.next();
+                                        mCornerstoneAppHeaderPortraitHeight = Integer.parseInt(xpp.getText());
+                                        xpp.next();
+                                    }
+                                    xpp.next();
+                                 }
+                                 xpp.next();
+                                 tag = xpp.getName();
+                                 if(tag.equals("gutter")){
+                                    xpp.next();
+                                    mCornerstonePanelPortraitGutter = Integer.parseInt(xpp.getText());
+                                    xpp.next();
+                                 }
+                                 xpp.next();
+                             }
+                             break;
+                        }
+                     }
+                }
+                eventType = xpp.next();
+            }
+            xpp.close();
+         } catch (XmlPullParserException e) {
+              // TODO Auto-generated catch block
+              e.printStackTrace();
+              xpp.close();
+         } catch (IOException e) {
+             // TODO Auto-generated catch block
+             e.printStackTrace();
+             xpp.close();
+         }
+        /**
+         * Author: Onskreen
+         * Date: 20/01/2011
+         *
+         * Turn off the keyguard window which is active by default Release
+         */
+        mPolicy.enableKeyguard(false);
     }
 
     public InputManagerService getInputManagerService() {
@@ -1469,6 +1753,86 @@ public class WindowManagerService extends IWindowManager.Stub
         }
     }
 
+    /**
+     * Author: Onskreen
+     * Date: 10/03/2011
+     *
+     * Utility method to dump quick status of app windows. For debugging.
+     * Ignores non-app windows.
+     */
+    public void logQuickWMSState() {
+        // dump the WMS data
+        for (int i = 0; i < mWindows.size(); i++) {
+            WindowState win = (WindowState) mWindows.get(i);
+            if (win.mAppToken != null) {
+                Log.v(TAG, i + ". " + win);
+
+                //Dump Window Panel Info
+                boolean wpFound = false;
+                for(int k=0; k<mWindowPanels.size(); k++) {
+                    WindowPanel wp = mWindowPanels.get(k);
+                    if(wp.contains(win.mAppToken.token)) {
+                        Log.i(TAG, "\tWindow Panel: " + wp);
+                        wpFound = true;
+                        break;
+                    }
+                }
+                if(!wpFound) {
+                    Log.i(TAG, "\tWindow Panel: None!");
+                }
+            }
+        }
+    }
+
+    /**
+     * Author: Onskreen
+     * Date: 27/01/2011
+     *
+     * Utility method to dump relevant window output to log. For debugging.
+     */
+    public void logWMSState(boolean logAppTokenDetail, boolean ignoreNonAppTokens) {
+        // dump the WMS data
+        for (int i = 0; i < mWindows.size(); i++) {
+            WindowState win = (WindowState) mWindows.get(i);
+            if (win.mAppToken == null && ignoreNonAppTokens) {
+                Log.v(TAG, i + ". " + win + " Ignored (non-apptoken)");
+            } else {
+                Log.v(TAG, i + ". " + win);
+
+                //Dump Window Panel Info
+                boolean wpFound = false;
+                for(int k=0; k<mWindowPanels.size(); k++) {
+                    WindowPanel wp = mWindowPanels.get(k);
+                    if(wp.contains(win.mAppToken.token)) {
+                        Log.i(TAG, "Window Panel: " + wp);
+                        wpFound = true;
+                        break;
+                    }
+                }
+                if(!wpFound) {
+                    Log.i(TAG, "Window Panel: None!");
+                }
+
+                // Dump the WindowState
+                StringWriter sw = new StringWriter();
+                PrintWriter pw = new PrintWriter(sw);
+                win.dump(pw, "Window " + i + ": ", true);
+                Log.i(TAG, sw.toString());
+                // Dump the App Token Info
+                if (logAppTokenDetail) {
+                    if (win.mAppToken == null) {
+                        Log.v(TAG, i + ". " + win + " Mode: Non-AppToken");
+                    } else {
+                        StringWriter sw2 = new StringWriter();
+                        PrintWriter pw2 = new PrintWriter(sw2);
+                        win.mAppToken.dump(pw2, "AppToken " + i + ": ");
+                        Log.i(TAG, sw2.toString());
+                    }
+                }
+            }
+        }
+    }
+
     void moveInputMethodDialogsLocked(int pos) {
         ArrayList<WindowState> dialogs = mInputMethodDialogs;
 
@@ -1637,7 +2001,14 @@ public class WindowManagerService extends IWindowManager.Stub
         mInnerFields.mWallpaperMayChange = false;
         int changed = 0;
 
-        final int dw = mAppDisplayWidth;
+        /**
+         * Author: Onskreen
+         * Date: 11/14/2012
+         *
+         * Cornerstone keeps the wallpaper window at always bottom of the Z-order
+         * list and to do that we have to comment the below implementation.
+         */
+        /*final int dw = mAppDisplayWidth;
         final int dh = mAppDisplayHeight;
 
         // First find top-most window that has asked to be on top of the
@@ -1935,7 +2306,7 @@ public class WindowManagerService extends IWindowManager.Stub
                 mWindowsChanged = true;
                 changed |= ADJUST_WALLPAPER_LAYERS_CHANGED;
             }
-        }
+        }*/
 
         return changed;
     }
@@ -2257,6 +2628,22 @@ public class WindowManagerService extends IWindowManager.Stub
 
             win = new WindowState(this, session, client, token,
                     attachedWindow, seq, attrs, viewVisibility);
+            /**
+             * Author: Onskreen
+             * Date: 12/01/2011
+             *
+             * Sets the WindowPanel rect for apptokens.
+             */
+            if(token.appWindowToken != null) {
+                setWindowPanel(token.appWindowToken.groupId);
+                //Since the windowstate has not yet been added to mWindows, it
+                //must be manually updated here.
+                WindowPanel wp = findWindowPanel(token.appWindowToken.groupId);
+                if(wp != null) {
+                    win.mFrame.set(wp.getPos());
+                }
+            }
+
             if (win.mDeathRecipient == null) {
                 // Client has apparently died, so there is no reason to
                 // continue.
@@ -2912,6 +3207,50 @@ public class WindowManagerService extends IWindowManager.Stub
                         win.mTurnOnScreen = true;
                     }
                     int diff = 0;
+                    /**
+                     * Author: Onskreen
+                     * Date: 26/12/2011
+                     *
+                     * Do not consider the config changed if the Win is in a window panel unless the orientation is different.
+                     * TODO this could backfire when other non orientation values change. we might need a config compare method
+                     * that compares a WP config and mCurConfiguration exluding the WP specific values?
+                     */
+                    if(mCornerstoneState != Cornerstone_State.TERMINATED	&&										//Only do special layout when Cornerstone is on
+                            win.mAppToken != null &&
+                            (win.mAppToken.isCornerstone ||
+                            win.mAppToken.isInCornerstonePanelWindowPanel() ||
+                            win.mAppToken.isInMainPanelWindowPanel())) {
+                        /**
+                         * Make sure that window had its configuration set by its WindowPanel. It's possible that
+                         * it didn't when added if this is the first Window in the Panel
+                         */
+                        WindowPanel wp = findWindowPanel(win.mAppToken.groupId);
+                        wp.updateConfiguration(true);
+                        outConfig.setTo(wp.getConfiguration());
+
+                        Rect rect = this.computeWindowPanelRect(wp, wp.getConfiguration().orientation, mCornerstoneState);
+                        if(DEBUG_CORNERSTONE) {
+                            Slog.v(TAG, "Relayout: " + wp);
+                            Slog.v(TAG, "mCornerstoneStateChangeAnimating: " + this.mCornerstoneStateChangeAnimating);
+                            Slog.v(TAG, "mCornerstoneStateChangeProcessing: " + this.mCornerstoneStateChangeProcessing);
+                            Slog.v(TAG, "to rect: " + rect);
+                        }
+                        if(!mCornerstoneStateChangeAnimating || !wp.isCornerstonePanel()) {
+                            if(DEBUG_CORNERSTONE) {
+                                Slog.v(TAG, "Cornerstone not animating, or non cornerstone panel - reposition window panel frame");
+                            }
+                            wp.setFrame(rect);
+                        } else {
+                            if(DEBUG_CORNERSTONE) {
+                                Slog.v(TAG, "Cornerstone animating - do not reposition window panel frame");
+                            }
+                        }
+
+						if(DEBUG_WP_CONFIG) {
+							Slog.v(TAG, "Ignoring diff in configuration for WindowPanel: " + win);
+							Slog.v(TAG, "with config: " + win.mConfiguration);
+						}
+                    } else {
                     if (win.mConfiguration != mCurConfiguration
                             && (win.mConfiguration == null
                                     || (diff=mCurConfiguration.diff(win.mConfiguration)) != 0)) {
@@ -2924,6 +3263,20 @@ public class WindowManagerService extends IWindowManager.Stub
                         outConfig.setTo(mCurConfiguration);
                     }
                 }
+
+                    /** ORIGINAL IMPLEMENTATION**/
+                    /*if (win.mConfiguration != mCurConfiguration
+                            && (win.mConfiguration == null
+                                    || (diff=mCurConfiguration.diff(win.mConfiguration)) != 0)) {
+                        win.mConfiguration = mCurConfiguration;
+                        if (DEBUG_CONFIGURATION) {
+                            Slog.i(TAG, "Window " + win + " visible with new config: "
+                                    + win.mConfiguration + " / 0x"
+                                    + Integer.toHexString(diff));
+                        }
+                        outConfig.setTo(mCurConfiguration);
+                    }*/
+                }
                 if ((attrChanges&WindowManager.LayoutParams.FORMAT_CHANGED) != 0) {
                     // To change the format, we need to re-build the surface.
                     winAnimator.destroySurfaceLocked();
@@ -2946,7 +3299,6 @@ public class WindowManagerService extends IWindowManager.Stub
                     }
                 } catch (Exception e) {
                     mInputMonitor.updateInputWindowsLw(true /*force*/);
-                    
                     Slog.w(TAG, "Exception thrown when creating surface for client "
                              + client + " (" + win.mAttrs.getTitle() + ")",
                              e);
@@ -3411,36 +3763,327 @@ public class WindowManagerService extends IWindowManager.Stub
                 }
             } else {
                 int animAttr = 0;
+                /**
+                 * Onskree-Cornerstone
+                 * Date: 3.16.2011
+                 *
+                 * Determine which panel we are dealing with to appropriately set transition animation. In
+                 * appropriate cases the transition animations are set to their reverse so that
+                 * animations do not draw above the other panels on the screen.
+                 *
+                 * Wallpaper animations are not dealt with at this time since it isn't clear
+                 * they are causing any conflicts with Cornerstone.
+                 */
+                boolean isMainPanel = false;
+                boolean isCSPanel0 = false;
+                boolean isCSPanel1 = false;
+                if(wtoken == null) {
+					isMainPanel = true;
+                } else {
+                    WindowPanel wp = findWindowPanel(wtoken.groupId);
+                    if(wp==null) {
+						isMainPanel = true;		//When all else fails, just act as if main panel
+						if (DEBUG_CORNERSTONE) Log.v(TAG, "Failed to find WindowPanel containing token: " + wtoken);
+					} else if(wp.isMainPanel()) {
+						isMainPanel = true;
+					} else if(wp.isCornerstone()) {
+						isMainPanel = true; 	//This is actually a failure of some type
+					} else if(wp.isCornerstonePanel()) {
+						if(wp.mCornerstonePanelIndex == 0) {
+							isCSPanel0 = true;
+						} else if(wp.mCornerstonePanelIndex == 1) {
+							isCSPanel1 = true;
+						}
+					}
+                }
+
+                /**
+                 * Onskree-Cornerstone
+                 * Date: 4.18.2011
+                 *
+                 * Store orientation for use in configuring transitions.
+                 * Landscape Mode:
+                 * - Main panel transitions out to left
+                 * - CS Panels transitions out to right
+                 *
+                 * Portrait Mode:
+                 * - Main Panel and CS Panel 1 - transition out to right
+                 * - CS Panel 0 - transitions out to left
+                 *
+                 * Using mCurConfiguration. Calling mActivityManager.getConfiguratin() can
+                 * result in a synchronized block.
+                 */
+                boolean isPortraitMode = false;
+                boolean isLandscapeMode = false;
+                if(mCurConfiguration.orientation == Configuration.ORIENTATION_PORTRAIT) {
+					isPortraitMode = true;
+                } else if(mCurConfiguration.orientation == Configuration.ORIENTATION_LANDSCAPE) {
+					isLandscapeMode = true;
+                }
+
+                /**Original switch() retained for reference**/
+                /*switch (transit) {
+                    case WindowManagerPolicy.TRANSIT_ACTIVITY_OPEN:
+                        animAttr = enter
+                                ? com.android.internal.R.styleable.WindowAnimation_activityOpenEnterAnimation
+                                : com.android.internal.R.styleable.WindowAnimation_activityOpenExitAnimation;
+                        break;
+                    case WindowManagerPolicy.TRANSIT_ACTIVITY_CLOSE:
+                        animAttr = enter
+                                ? com.android.internal.R.styleable.WindowAnimation_activityCloseEnterAnimation
+                                : com.android.internal.R.styleable.WindowAnimation_activityCloseExitAnimation;
+                        break;
+                    case WindowManagerPolicy.TRANSIT_TASK_OPEN:
+                        animAttr = enter
+                                ? com.android.internal.R.styleable.WindowAnimation_taskOpenEnterAnimation
+                                : com.android.internal.R.styleable.WindowAnimation_taskOpenExitAnimation;
+                        break;
+                    case WindowManagerPolicy.TRANSIT_TASK_CLOSE:
+                        animAttr = enter
+                                ? com.android.internal.R.styleable.WindowAnimation_taskCloseEnterAnimation
+                                : com.android.internal.R.styleable.WindowAnimation_taskCloseExitAnimation;
+                        break;
+                    case WindowManagerPolicy.TRANSIT_TASK_TO_FRONT:
+                        animAttr = enter
+                                ? com.android.internal.R.styleable.WindowAnimation_taskToFrontEnterAnimation
+                                : com.android.internal.R.styleable.WindowAnimation_taskToFrontExitAnimation;
+                        break;
+                    case WindowManagerPolicy.TRANSIT_TASK_TO_BACK:
+                        animAttr = enter
+                                ? com.android.internal.R.styleable.WindowAnimation_taskToBackEnterAnimation
+                                : com.android.internal.R.styleable.WindowAnimation_taskToBackExitAnimation;
+                        break;
+                    case WindowManagerPolicy.TRANSIT_WALLPAPER_OPEN:
+                        animAttr = enter
+                                ? com.android.internal.R.styleable.WindowAnimation_wallpaperOpenEnterAnimation
+                                : com.android.internal.R.styleable.WindowAnimation_wallpaperOpenExitAnimation;
+                        break;
+                    case WindowManagerPolicy.TRANSIT_WALLPAPER_CLOSE:
+                        animAttr = enter
+                                ? com.android.internal.R.styleable.WindowAnimation_wallpaperCloseEnterAnimation
+                                : com.android.internal.R.styleable.WindowAnimation_wallpaperCloseExitAnimation;
+                        break;
+                    case WindowManagerPolicy.TRANSIT_WALLPAPER_INTRA_OPEN:
+                        animAttr = enter
+                                ? com.android.internal.R.styleable.WindowAnimation_wallpaperIntraOpenEnterAnimation
+                                : com.android.internal.R.styleable.WindowAnimation_wallpaperIntraOpenExitAnimation;
+                        break;
+                    case WindowManagerPolicy.TRANSIT_WALLPAPER_INTRA_CLOSE:
+                        animAttr = enter
+                                ? com.android.internal.R.styleable.WindowAnimation_wallpaperIntraCloseEnterAnimation
+                                : com.android.internal.R.styleable.WindowAnimation_wallpaperIntraCloseExitAnimation;
+                        break;
+                }*/
                 switch (transit) {
                     case WindowManagerPolicy.TRANSIT_ACTIVITY_OPEN:
+						if(isLandscapeMode) {
+							if(isMainPanel) {			//Main Panel Transitions
+								animAttr = enter
+								? com.android.internal.R.styleable.WindowAnimation_activityOpenEnterAnimation_reverse
+								: com.android.internal.R.styleable.WindowAnimation_activityOpenExitAnimation;
+							} else {					//Cs Panel Transitions
+								animAttr = enter
+								? com.android.internal.R.styleable.WindowAnimation_activityOpenEnterAnimation
+								: com.android.internal.R.styleable.WindowAnimation_activityOpenExitAnimation_reverse;
+							}
+						} else if(isPortraitMode) {
+							if(isMainPanel) {			//Main Panel Transitions
                         animAttr = enter
                                 ? com.android.internal.R.styleable.WindowAnimation_activityOpenEnterAnimation
                                 : com.android.internal.R.styleable.WindowAnimation_activityOpenExitAnimation;
+							} else {					//CS Panel Transitions
+								if(isCSPanel0) {
+									animAttr = enter
+									? com.android.internal.R.styleable.WindowAnimation_activityOpenEnterAnimation_reverse
+									: com.android.internal.R.styleable.WindowAnimation_activityOpenExitAnimation;
+								} else if(isCSPanel1) {
+									animAttr = enter
+									? com.android.internal.R.styleable.WindowAnimation_activityOpenEnterAnimation
+									: com.android.internal.R.styleable.WindowAnimation_activityOpenExitAnimation_reverse;
+								}
+							}
+						}
                         break;
                     case WindowManagerPolicy.TRANSIT_ACTIVITY_CLOSE:
+						if(isLandscapeMode) {
+							if(isMainPanel) {			//Main Panel Transitions
                         animAttr = enter
                                 ? com.android.internal.R.styleable.WindowAnimation_activityCloseEnterAnimation
+								: com.android.internal.R.styleable.WindowAnimation_activityCloseExitAnimation_reverse;
+							} else {					//Cs Panel Transitions
+								animAttr = enter
+								? com.android.internal.R.styleable.WindowAnimation_activityCloseEnterAnimation_reverse
                                 : com.android.internal.R.styleable.WindowAnimation_activityCloseExitAnimation;
+							}
+						} else if(isPortraitMode) {
+							if(isMainPanel) {			//Main Panel Transitions
+								animAttr = enter
+								? com.android.internal.R.styleable.WindowAnimation_activityCloseEnterAnimation
+								: com.android.internal.R.styleable.WindowAnimation_activityCloseExitAnimation;
+							} else {					//CS Panel Transitions
+								if(isCSPanel0) {
+									animAttr = enter
+									? com.android.internal.R.styleable.WindowAnimation_activityCloseEnterAnimation
+									: com.android.internal.R.styleable.WindowAnimation_activityCloseExitAnimation_reverse;
+								} else if(isCSPanel1) {
+									animAttr = enter
+									? com.android.internal.R.styleable.WindowAnimation_activityCloseEnterAnimation_reverse
+									: com.android.internal.R.styleable.WindowAnimation_activityCloseExitAnimation;
+								}
+							}
+						}
                         break;
                     case WindowManagerPolicy.TRANSIT_TASK_OPEN:
+						if(isLandscapeMode) {
+							if(isMainPanel) {			//Main Panel Transitions
+								animAttr = enter
+								? com.android.internal.R.styleable.WindowAnimation_taskOpenEnterAnimation_reverse
+								: com.android.internal.R.styleable.WindowAnimation_taskOpenExitAnimation;
+							} else {					//Cs Panel Transitions
+								animAttr = enter
+								? com.android.internal.R.styleable.WindowAnimation_taskOpenEnterAnimation
+								: com.android.internal.R.styleable.WindowAnimation_taskOpenExitAnimation_reverse;
+							}
+						} else if(isPortraitMode) {
+							if(isMainPanel) {			//Main Panel Transitions
                         animAttr = enter
                                 ? com.android.internal.R.styleable.WindowAnimation_taskOpenEnterAnimation
                                 : com.android.internal.R.styleable.WindowAnimation_taskOpenExitAnimation;
+							} else {					//CS Panel Transitions
+								if(isCSPanel0) {
+									animAttr = enter
+									? com.android.internal.R.styleable.WindowAnimation_taskOpenEnterAnimation_reverse
+                                    /**
+                                     * Author: Onskreen
+                                     * Date: 11/01/2013
+                                     *
+                                     * For CS Panel 0 App in portrait mode, we are applying the Cornerstone
+                                     * specific transition settings than the default one. This ensures that
+                                     * open/exit transition is played correct on screen without interrupting
+                                     * other panel apps.
+                                     */
+									: com.android.internal.R.styleable.WindowAnimation_taskOpenExitAnimation_cornerstone;
+								} else if(isCSPanel1) {
+									animAttr = enter
+									? com.android.internal.R.styleable.WindowAnimation_taskOpenEnterAnimation
+									: com.android.internal.R.styleable.WindowAnimation_taskOpenExitAnimation_reverse;
+								}
+							}
+						}
                         break;
                     case WindowManagerPolicy.TRANSIT_TASK_CLOSE:
+						if(isLandscapeMode) {
+							if(isMainPanel) {			//Main Panel Transitions
                         animAttr = enter
                                 ? com.android.internal.R.styleable.WindowAnimation_taskCloseEnterAnimation
+								: com.android.internal.R.styleable.WindowAnimation_taskCloseExitAnimation_reverse;
+							} else {					//Cs Panel Transitions
+								animAttr = enter
+								? com.android.internal.R.styleable.WindowAnimation_taskCloseEnterAnimation_reverse
                                 : com.android.internal.R.styleable.WindowAnimation_taskCloseExitAnimation;
+							}
+						} else if(isPortraitMode) {
+							if(isMainPanel) {			//Main Panel Transitions
+								animAttr = enter
+								? com.android.internal.R.styleable.WindowAnimation_taskCloseEnterAnimation
+								: com.android.internal.R.styleable.WindowAnimation_taskCloseExitAnimation;
+							} else {					//CS Panel Transitions
+								if(isCSPanel0) {
+									animAttr = enter
+                                    /**
+                                     * Author: Onskreen
+                                     * Date: 11/01/2013
+                                     *
+                                     * For CS Panel 0 App in portrait mode, we are applying the Cornerstone
+                                     * specific transition settings than the default one. This ensures that
+                                     * open/exit transition is played correct on screen without interrupting
+                                     * other panel apps.
+                                     */
+									? com.android.internal.R.styleable.WindowAnimation_taskCloseEnterAnimation_cornerstone
+									: com.android.internal.R.styleable.WindowAnimation_taskCloseExitAnimation_reverse;
+								} else if(isCSPanel1) {
+									animAttr = enter
+									? com.android.internal.R.styleable.WindowAnimation_taskCloseEnterAnimation_reverse
+									: com.android.internal.R.styleable.WindowAnimation_taskCloseExitAnimation;
+								}
+							}
+						}
                         break;
                     case WindowManagerPolicy.TRANSIT_TASK_TO_FRONT:
+						if(isLandscapeMode) {
+							if(isMainPanel) {			//Main Panel Transitions
+								animAttr = enter
+								? com.android.internal.R.styleable.WindowAnimation_taskToFrontEnterAnimation_reverse
+								: com.android.internal.R.styleable.WindowAnimation_taskToFrontExitAnimation;
+							} else {					//Cs Panel Transitions
+									animAttr = enter
+									? com.android.internal.R.styleable.WindowAnimation_taskToFrontEnterAnimation
+									: com.android.internal.R.styleable.WindowAnimation_taskToFrontExitAnimation_reverse;
+							}
+						} else if(isPortraitMode) {
+							if(isMainPanel) {			//Main Panel Transitions
                         animAttr = enter
                                 ? com.android.internal.R.styleable.WindowAnimation_taskToFrontEnterAnimation
                                 : com.android.internal.R.styleable.WindowAnimation_taskToFrontExitAnimation;
+							} else {					//CS Panel Transitions
+								if(isCSPanel0) {
+									animAttr = enter
+									? com.android.internal.R.styleable.WindowAnimation_taskToFrontEnterAnimation_reverse
+                                    /**
+                                     * Author: Onskreen
+                                     * Date: 11/01/2013
+                                     *
+                                     * For CS Panel 0 App in portrait mode, we are applying the Cornerstone
+                                     * specific transition settings than the default one. This ensures that
+                                     * open/exit transition is played correct on screen without interrupting
+                                     * other panel apps.
+                                     */
+									: com.android.internal.R.styleable.WindowAnimation_taskToFrontExitAnimation_cornerstone;
+								} else if(isCSPanel1) {
+									animAttr = enter
+									? com.android.internal.R.styleable.WindowAnimation_taskToFrontEnterAnimation
+									: com.android.internal.R.styleable.WindowAnimation_taskToFrontExitAnimation_reverse;
+								}
+							}
+						}
                         break;
                     case WindowManagerPolicy.TRANSIT_TASK_TO_BACK:
+						if(isLandscapeMode) {
+							if(isMainPanel) {			//Main Panel Transitions
+								animAttr = enter
+								? com.android.internal.R.styleable.WindowAnimation_taskToBackEnterAnimation
+								: com.android.internal.R.styleable.WindowAnimation_taskToBackExitAnimation_reverse;
+							} else {					//Cs Panel Transitions
+								animAttr = enter
+								? com.android.internal.R.styleable.WindowAnimation_taskToBackEnterAnimation_reverse
+								: com.android.internal.R.styleable.WindowAnimation_taskToBackExitAnimation;
+							}
+						} else if(isPortraitMode) {
+							if(isMainPanel) {			//Main Panel Transitions
                         animAttr = enter
                                 ? com.android.internal.R.styleable.WindowAnimation_taskToBackEnterAnimation
                                 : com.android.internal.R.styleable.WindowAnimation_taskToBackExitAnimation;
+							} else {					//CS Panel Transitions
+								if(isCSPanel0) {
+									animAttr = enter
+                                    /**
+                                     * Author: Onskreen
+                                     * Date: 11/01/2013
+                                     *
+                                     * For CS Panel 0 App in portrait mode, we are applying the Cornerstone
+                                     * specific transition settings than the default one. This ensures that
+                                     * open/exit transition is played correct on screen without interrupting
+                                     * other panel apps.
+                                     */
+									? com.android.internal.R.styleable.WindowAnimation_taskToBackEnterAnimation_cornerstone
+									: com.android.internal.R.styleable.WindowAnimation_taskToBackExitAnimation_reverse;
+								} else if(isCSPanel1) {
+									animAttr = enter
+									? com.android.internal.R.styleable.WindowAnimation_taskToBackEnterAnimation_reverse
+									: com.android.internal.R.styleable.WindowAnimation_taskToBackExitAnimation;
+								}
+							}
+						}
                         break;
                     case WindowManagerPolicy.TRANSIT_WALLPAPER_OPEN:
                         animAttr = enter
@@ -3642,9 +4285,35 @@ public class WindowManagerService extends IWindowManager.Stub
         mAnimatingAppTokens.add(mAnimatingAppTokens.indexOf(aboveAnchor), wtoken);
     }
 
+    /**
+     * Author: Onskreen
+     * Date: 24/01/2011
+     *
+     * Rather than change the IWindowManager interface, left this as a stub and put its implementation
+     * into the overridden method below.
+     */
     @Override
     public void addAppToken(int addPos, IApplicationToken token,
             int groupId, int requestedOrientation, boolean fullscreen) {
+
+    }
+
+    /**
+     * Author: Onskreen
+     * Date: 24/01/2011
+     *
+     * Overloaded version which also takes as cornerstone specific parameters:
+     * - inMainPanel - boolean indicating if the app should be in the main panel.
+     * - isCornerstone - boolean indicating if the token is the cornerstone
+     * - cornerstonePanelIndex - int indicating which cornerstone panel. -1 indicates
+     * invalid value (not a cornerstone panel)
+     */
+
+    public void addAppToken(int addPos, IApplicationToken token,
+            int groupId, int requestedOrientation, boolean fullscreen,
+            boolean inMainPanel,
+            boolean isCornerstone,
+            int cornerstonePanelIndex) {
         if (!checkCallingPermission(android.Manifest.permission.MANAGE_APP_TOKENS,
                 "addAppToken()")) {
             throw new SecurityException("Requires MANAGE_APP_TOKENS permission");
@@ -3675,10 +4344,183 @@ public class WindowManagerService extends IWindowManager.Stub
             wtoken.groupId = groupId;
             wtoken.appFullscreen = fullscreen;
             wtoken.requestedOrientation = requestedOrientation;
+
+
+            /**
+             * Author: Onskreen
+             * Date: 11/02/2011
+             *
+             * Set the cornerstone flag in the token
+             */
+            wtoken.isCornerstone = isCornerstone;
+
+            /**
+             * Author: Onskreen
+             * Date: 12/01/2011
+             *
+             * Add the new apptoken to an existing WindowPanel, or create a new one
+             * for that panel if required.
+             */
+            WindowPanel wpToAddTo = null;
+            //Main Panel
+            if(inMainPanel) {
+                if (DEBUG_WP_GROUPING) {
+                    Log.w(TAG, "Trying to add: " + wtoken + " to Main Panel");
+                }
+                for (int k = 0; k < mWindowPanels.size(); k++) {
+                    WindowPanel wp = mWindowPanels.get(k);
+                    if(wp.isMainPanel()) {
+                        wpToAddTo = wp;
+                        if (DEBUG_WP_GROUPING) {
+                            Log.w(TAG, "\tFound matching Window Panel" + wp);
+                        }
+                        break;
+                    }
+                }
+            } else if(isCornerstone) {
+                //Cornerstone
+                if (DEBUG_WP_GROUPING) {
+                    Log.w(TAG, "Trying to add: " + wtoken + " to Cornerstone");
+                }
+                for (int k = 0; k < mWindowPanels.size(); k++) {
+                    WindowPanel wp = mWindowPanels.get(k);
+                    if(wp.isCornerstone()) {
+                        wpToAddTo = wp;
+                        if (DEBUG_WP_GROUPING) {
+                            Log.w(TAG, "\tFound matching Window Panel" + wp);
+                        }
+                        break;
+                    }
+                }
+            } else {
+                //Cornerstone Panel
+                if (DEBUG_WP_GROUPING) {
+                    Log.w(TAG, "Trying to add: " + wtoken + " to Cornerstone Panel: " + cornerstonePanelIndex);
+                }
+                for (int k = 0; k < mWindowPanels.size(); k++) {
+                    WindowPanel wp = mWindowPanels.get(k);
+                    if(wp.isCornerstonePanel() && wp.mCornerstonePanelIndex==cornerstonePanelIndex) {
+                        wpToAddTo = wp;
+                        if (DEBUG_WP_GROUPING) {
+                            Log.w(TAG, "\tFound matching Window Panel" + wp);
+                        }
+                        break;
+                    }
+                }
+            }
+
+            //Add to existing Window Panel
+            if(wpToAddTo != null) {
+                if (DEBUG_WP_GROUPING) {
+                    Log.w(TAG, "\tAdding to Window Panel");
+                }
+                wpToAddTo.addGroupId(wtoken.groupId);
+
+            } else {
+                //Create new Window Panel
+                WindowPanel newWP = new WindowPanel();
+                newWP.setName(wtoken.stringName);
+                newWP.addGroupId(wtoken.groupId);
+                mWindowPanels.add(newWP);
+
+                if(inMainPanel) {
+                    if (DEBUG_WP_GROUPING) {
+                        Log.w(TAG, "\tCreating new Window Panel: Main Panel");
+                    }
+                    newWP.setInMainPanel(inMainPanel);
+                    newWP.setIsCornerstonePanel(false);
+                } else if(isCornerstone) {
+                    if (DEBUG_WP_GROUPING) {
+                        Log.w(TAG, "\tCreating new Window Panel: Cornerstone");
+                    }
+                    newWP.setInMainPanel(inMainPanel);
+                    newWP.setIsCornerstonePanel(false);
+                } else {
+                    if (DEBUG_WP_GROUPING) {
+                        Log.w(TAG, "\tCreating new Window Panel: Cornerstone Panel: " + cornerstonePanelIndex);
+                    }
+                    newWP.setInMainPanel(inMainPanel);
+                    newWP.setIsCornerstonePanel(true);
+                    newWP.mCornerstonePanelIndex = cornerstonePanelIndex;
+                }
+            }
+
+        /**
+         * Author: Onskreen
+         * Date: 01/02/2010
+         *
+         * Translate the addPos to be appropriate for the WMS. The addPos is given by the ActivityStack
+         * based on its known tasks, however those could be in variable z-order in mWindows.
+         *
+         * TO CONSIDER:
+         * - If the apptoken wanted to be the top apptoken in its stack, should it be placed
+         * at the top of mapptokens, regardless of where the last activity of it's stack is in
+         * mAppTokens?
+         */
+        int newAddPos = addPos; 		//Translated addPos
+        if(DEBUG_CORNERSTONE) {
+            Log.v(TAG, "State of mAppTokens before calculating where token should be added:");
+            for(int k=0; k<mAppTokens.size(); k++) {
+                Log.v(TAG, k + ": " + mAppTokens.get(k));
+            }
+        }
+
+        WindowPanel targetWP = null;
+        for(int k=0; k<mWindowPanels.size(); k++) {
+            WindowPanel wp = mWindowPanels.get(k);
+            //Found the window panel which contains the token being added. Use this version of contains() because
+            //the appwindowtoken has not been added to internal data structures yet so other version will fail
+            if(wp.contains(wtoken.groupId)) {
+                targetWP = wp;
+                break;
+            }
+        }
+
+        //Cornerstone
+        if(wtoken.isCornerstone) {
+            if(DEBUG_CORNERSTONE) {
+                Log.v(TAG, "Token is cornerstone, place at bottom.");
+            }
+            newAddPos = 0;
+        } else {
+			//For any other ActivityStack count the spot to place the token
+			int numAppTokensInPanel = 0;
+			boolean cornerstoneFound = false;
+			for(int i=0; i<mAppTokens.size(); i++) {
+				if(targetWP.contains(mAppTokens.get(i).groupId)) {
+					numAppTokensInPanel++;
+					if(DEBUG_CORNERSTONE) {
+						Log.v(TAG, "Found other token of same wp: " + mAppTokens.get(i));
+					}
+				}
+				if(mAppTokens.get(i).isCornerstone) {
+					cornerstoneFound = true;
+					if(DEBUG_CORNERSTONE) {
+						Log.v(TAG, "Found cornerstone: " + mAppTokens.get(i));
+					}
+				}
+				if(addPos == 0 && numAppTokensInPanel==1) {
+					newAddPos = i;
+					break;
+				} else if(addPos>0 && addPos==numAppTokensInPanel) {
+					newAddPos = i;
+					break;
+				}
+		}
+		newAddPos = mAppTokens.size();
+/*		//If went through whole list put at bottom (taking into account cornerstone)
+		if(cornerstoneFound) {
+			newAddPos = addPos + 1;
+		} else {
+			newAddPos = addPos;
+		}
+*/
+        }
+
             if (DEBUG_TOKEN_MOVEMENT || DEBUG_ADD_REMOVE) Slog.v(TAG, "addAppToken: " + wtoken
-                    + " at " + addPos);
-            mAppTokens.add(addPos, wtoken);
-            addAppTokenToAnimating(addPos, wtoken);
+                    + " at " + newAddPos);
+            mAppTokens.add(newAddPos, wtoken);
+            addAppTokenToAnimating(newAddPos, wtoken);
             mTokenMap.put(token.asBinder(), wtoken);
 
             // Application tokens start out hidden.
@@ -3786,6 +4628,39 @@ public class WindowManagerService extends IWindowManager.Stub
             } 
 
             int or = wtoken.requestedOrientation;
+
+            /**
+             * Author: Onskreen
+             * Date: 19/04/2011
+             *
+             * Sets the main panel app/activity orientation to cornerstone apps/activities
+             * if cornerstone apps/activities request the orientation change.
+             *
+             * START: ORIENTATION_FIX
+             * Removed to disable orientation support
+             */
+            if(wtoken.isInCornerstonePanelWindowPanel()){
+                /**
+                 * Author: Onskreen
+                 * Date: 09/06/2011
+                 *
+                 * Only changes the orientation if main panel activity is requested to do so
+                 * or user rotates the device accordingly.
+                 */
+                for(int i = pos; i >= 0; i--){
+                    AppWindowToken token = mAppTokens.get(i);
+                    if(token.isInMainPanelWindowPanel() && token.reportedVisible){
+                        return token.requestedOrientation;
+                    }
+                }
+            }
+
+            /**
+             * Author: Onskreen
+             * Date: 30/04/2011
+             *
+             * END: ORIENTATION_FIX
+             */
             // If this application is fullscreen, and didn't explicitly say
             // to use the orientation behind it, then just take whatever
             // orientation it has and ignores whatever is under it.
@@ -3810,6 +4685,544 @@ public class WindowManagerService extends IWindowManager.Stub
         return ActivityInfo.SCREEN_ORIENTATION_UNSPECIFIED;
     }
 
+    /**
+     * Author: Onskreen
+     * Date: 26/12/2011
+     *
+     * Update wpConfig from another config. Same as Configuration.updateFrom()
+     * but takes into account that WP config will have different rect values than the AMS or
+     * WMS configs; so ignores those values in the updating.
+     *
+     * If the Cornerstone is not active, this method is the same as calling Configuration.updateFrom()
+     *
+     * TODO This should be an overloaded method in Configuration class.
+     */
+     public int updateNonWindowPanelConfigurationFrom(Configuration wpConfig, Configuration otherConfig) {
+         if(mCornerstoneState == Cornerstone_State.TERMINATED) {
+             return wpConfig.updateFrom(otherConfig);
+         }
+         int changed = 0;
+
+         if (otherConfig.fontScale > 0 && wpConfig.fontScale != otherConfig.fontScale) {
+             changed |= ActivityInfo.CONFIG_FONT_SCALE;
+             wpConfig.fontScale = otherConfig.fontScale;
+         }
+         if (otherConfig.mcc != 0 && wpConfig.mcc != otherConfig.mcc) {
+             changed |= ActivityInfo.CONFIG_MCC;
+             wpConfig.mcc = otherConfig.mcc;
+         }
+         if (otherConfig.mnc != 0 && wpConfig.mnc != otherConfig.mnc) {
+             changed |= ActivityInfo.CONFIG_MNC;
+             wpConfig.mnc = otherConfig.mnc;
+         }
+         if (otherConfig.locale != null
+                 && (wpConfig.locale == null || !wpConfig.locale.equals(otherConfig.locale))) {
+             changed |= ActivityInfo.CONFIG_LOCALE;
+             wpConfig.locale = otherConfig.locale != null
+                     ? (Locale) otherConfig.locale.clone() : null;
+             wpConfig.layoutDirection = LocaleUtil.getLayoutDirectionFromLocale(wpConfig.locale);
+         }
+         if (otherConfig.userSetLocale && (!wpConfig.userSetLocale || ((changed & ActivityInfo.CONFIG_LOCALE) != 0))) {
+             wpConfig.userSetLocale = true;
+             changed |= ActivityInfo.CONFIG_LOCALE;
+         }
+         if (otherConfig.touchscreen != Configuration.TOUCHSCREEN_UNDEFINED
+                 && wpConfig.touchscreen != otherConfig.touchscreen) {
+             changed |= ActivityInfo.CONFIG_TOUCHSCREEN;
+             wpConfig.touchscreen = otherConfig.touchscreen;
+         }
+         if (otherConfig.keyboard != Configuration.KEYBOARD_UNDEFINED
+                 && wpConfig.keyboard != otherConfig.keyboard) {
+             changed |= ActivityInfo.CONFIG_KEYBOARD;
+             wpConfig.keyboard = otherConfig.keyboard;
+         }
+         if (otherConfig.keyboardHidden != Configuration.KEYBOARDHIDDEN_UNDEFINED
+                 && wpConfig.keyboardHidden != otherConfig.keyboardHidden) {
+             changed |= ActivityInfo.CONFIG_KEYBOARD_HIDDEN;
+             wpConfig.keyboardHidden = otherConfig.keyboardHidden;
+         }
+         if (otherConfig.hardKeyboardHidden != Configuration.HARDKEYBOARDHIDDEN_UNDEFINED
+                 && wpConfig.hardKeyboardHidden != otherConfig.hardKeyboardHidden) {
+             changed |= ActivityInfo.CONFIG_KEYBOARD_HIDDEN;
+             wpConfig.hardKeyboardHidden = otherConfig.hardKeyboardHidden;
+         }
+         if (otherConfig.navigation != Configuration.NAVIGATION_UNDEFINED
+                 && wpConfig.navigation != otherConfig.navigation) {
+             changed |= ActivityInfo.CONFIG_NAVIGATION;
+             wpConfig.navigation = otherConfig.navigation;
+         }
+         if (otherConfig.navigationHidden != Configuration.NAVIGATIONHIDDEN_UNDEFINED
+                 && wpConfig.navigationHidden != otherConfig.navigationHidden) {
+             changed |= ActivityInfo.CONFIG_KEYBOARD_HIDDEN;
+             wpConfig.navigationHidden = otherConfig.navigationHidden;
+         }
+         if (otherConfig.orientation != Configuration.ORIENTATION_UNDEFINED
+                 && wpConfig.orientation != otherConfig.orientation) {
+             changed |= ActivityInfo.CONFIG_ORIENTATION;
+             wpConfig.orientation = otherConfig.orientation;
+         }
+         if (otherConfig.uiMode != (Configuration.UI_MODE_TYPE_UNDEFINED|Configuration.UI_MODE_NIGHT_UNDEFINED)
+                 && wpConfig.uiMode != otherConfig.uiMode) {
+             changed |= ActivityInfo.CONFIG_UI_MODE;
+             if ((otherConfig.uiMode&Configuration.UI_MODE_TYPE_MASK) != Configuration.UI_MODE_TYPE_UNDEFINED) {
+                 wpConfig.uiMode = (wpConfig.uiMode&~Configuration.UI_MODE_TYPE_MASK)
+                         | (otherConfig.uiMode&Configuration.UI_MODE_TYPE_MASK);
+             }
+             if ((otherConfig.uiMode&Configuration.UI_MODE_NIGHT_MASK) != Configuration.UI_MODE_NIGHT_UNDEFINED) {
+                 wpConfig.uiMode = (wpConfig.uiMode&~Configuration.UI_MODE_NIGHT_MASK)
+                         | (otherConfig.uiMode&Configuration.UI_MODE_NIGHT_MASK);
+             }
+         }
+         if (otherConfig.seq != 0) {
+             wpConfig.seq = otherConfig.seq;
+         }
+
+         return changed;
+
+     }
+     /**
+      * Author: Onskreen
+      * Date: 26/12/2011
+      *
+      * Update wpConfig from another config. Same as Configuration.updateFrom()
+      * but takes into account that WP config will have different rect values than the AMS or
+      * WMS configs; only deals with WP specific values in the updating.
+      *
+      * If the Cornerstone is not active, this method is the same as calling Configuration.updateFrom()
+      *
+      * TODO This should be an overloaded method in Configuration class.
+      */
+      public int updateWindowPanelConfigurationFrom(Configuration wpConfig, Configuration otherConfig) {
+          if(mCornerstoneState == Cornerstone_State.TERMINATED) {
+             return wpConfig.updateFrom(otherConfig);
+          }
+          int changed = 0;
+          if (otherConfig.screenLayout != Configuration.SCREENLAYOUT_SIZE_UNDEFINED
+                  && wpConfig.screenLayout != otherConfig.screenLayout) {
+              changed |= ActivityInfo.CONFIG_SCREEN_LAYOUT;
+              wpConfig.screenLayout = otherConfig.screenLayout;
+          }
+          if (otherConfig.screenWidthDp != Configuration.SCREEN_WIDTH_DP_UNDEFINED
+                  && wpConfig.screenWidthDp != otherConfig.screenWidthDp) {
+              changed |= ActivityInfo.CONFIG_SCREEN_SIZE;
+              wpConfig.screenWidthDp = otherConfig.screenWidthDp;
+          }
+          if (otherConfig.screenHeightDp != Configuration.SCREEN_HEIGHT_DP_UNDEFINED
+                  && wpConfig.screenHeightDp != otherConfig.screenHeightDp) {
+              changed |= ActivityInfo.CONFIG_SCREEN_SIZE;
+              wpConfig.screenHeightDp = otherConfig.screenHeightDp;
+          }
+          if (otherConfig.smallestScreenWidthDp != Configuration.SMALLEST_SCREEN_WIDTH_DP_UNDEFINED
+                  && wpConfig.smallestScreenWidthDp != otherConfig.smallestScreenWidthDp) {
+              changed |= ActivityInfo.CONFIG_SMALLEST_SCREEN_SIZE;
+              wpConfig.smallestScreenWidthDp = otherConfig.smallestScreenWidthDp;
+          }
+          /**
+           * TODO - Configuration compat screen width/height and smallestscreenwidth need
+           * to be fully managed
+           */
+          if (otherConfig.compatScreenWidthDp != Configuration.SCREEN_WIDTH_DP_UNDEFINED) {
+              wpConfig.compatScreenWidthDp = otherConfig.compatScreenWidthDp;
+          }
+          if (otherConfig.compatScreenHeightDp != Configuration.SCREEN_HEIGHT_DP_UNDEFINED) {
+              wpConfig.compatScreenHeightDp = otherConfig.compatScreenHeightDp;
+          }
+          if (otherConfig.compatSmallestScreenWidthDp != Configuration.SMALLEST_SCREEN_WIDTH_DP_UNDEFINED) {
+              wpConfig.compatSmallestScreenWidthDp = otherConfig.compatSmallestScreenWidthDp;
+          }
+
+          return changed;
+
+      }
+
+      /**
+       * Author: Onskreen
+       * Date: 26/12/2011
+       *
+       * Perform a diff of the given wpConfig with another config. Same as Configuration.diff()
+       * but takes into account that WP config will have different rect values than the AMS or
+       * WMS configs; so ignores those values in the diff.
+       *
+       * If the Cornerstone is not active, this method is the same as calling Configuration.diff()
+       *
+       * TODO This should be an overloaded method in Configuration class.
+       */
+     public int diffNonWindowPanelConfiguration(Configuration wpConfig, Configuration otherConfig) {
+         //When the Cornerstone is not active, ignore any Window Panel logic and
+         // return the standard response
+         if(mCornerstoneState == Cornerstone_State.TERMINATED) {
+             return wpConfig.diff(otherConfig);
+         }
+
+         int changed = 0;
+         if (otherConfig.fontScale > 0 && wpConfig.fontScale != otherConfig.fontScale) {
+             changed |= ActivityInfo.CONFIG_FONT_SCALE;
+         }
+         if (otherConfig.mcc != 0 && wpConfig.mcc != otherConfig.mcc) {
+             changed |= ActivityInfo.CONFIG_MCC;
+         }
+         if (otherConfig.mnc != 0 && wpConfig.mnc != otherConfig.mnc) {
+             changed |= ActivityInfo.CONFIG_MNC;
+         }
+         if (otherConfig.locale != null
+                 && (wpConfig.locale == null || !wpConfig.locale.equals(otherConfig.locale))) {
+             changed |= ActivityInfo.CONFIG_LOCALE;
+         }
+         if (otherConfig.touchscreen != Configuration.TOUCHSCREEN_UNDEFINED
+                 && wpConfig.touchscreen != otherConfig.touchscreen) {
+             changed |= ActivityInfo.CONFIG_TOUCHSCREEN;
+         }
+         if (otherConfig.keyboard != Configuration.KEYBOARD_UNDEFINED
+                 && wpConfig.keyboard != otherConfig.keyboard) {
+             changed |= ActivityInfo.CONFIG_KEYBOARD;
+         }
+         if (otherConfig.keyboardHidden != Configuration.KEYBOARDHIDDEN_UNDEFINED
+                 && wpConfig.keyboardHidden != otherConfig.keyboardHidden) {
+             changed |= ActivityInfo.CONFIG_KEYBOARD_HIDDEN;
+         }
+         if (otherConfig.hardKeyboardHidden != Configuration.HARDKEYBOARDHIDDEN_UNDEFINED
+                 && wpConfig.hardKeyboardHidden != otherConfig.hardKeyboardHidden) {
+             changed |= ActivityInfo.CONFIG_KEYBOARD_HIDDEN;
+         }
+         if (otherConfig.navigation != Configuration.NAVIGATION_UNDEFINED
+                 && wpConfig.navigation != otherConfig.navigation) {
+             changed |= ActivityInfo.CONFIG_NAVIGATION;
+         }
+         if (otherConfig.navigationHidden != Configuration.NAVIGATIONHIDDEN_UNDEFINED
+                 && wpConfig.navigationHidden != otherConfig.navigationHidden) {
+             changed |= ActivityInfo.CONFIG_KEYBOARD_HIDDEN;
+         }
+         if (otherConfig.orientation != Configuration.ORIENTATION_UNDEFINED
+                 && wpConfig.orientation != otherConfig.orientation) {
+             changed |= ActivityInfo.CONFIG_ORIENTATION;
+         }
+         if (otherConfig.uiMode != (Configuration.UI_MODE_TYPE_UNDEFINED|Configuration.UI_MODE_NIGHT_UNDEFINED)
+                 && wpConfig.uiMode != otherConfig.uiMode) {
+             changed |= ActivityInfo.CONFIG_UI_MODE;
+         }
+         return changed;
+     }
+
+     /**
+      * Author: Onskreen
+      * Date: 26/12/2011
+      *
+      * Perform a diff of the given wpConfig with another config. Same as Configuration.diff()
+      * but takes into account that WP config will have different rect values than the AMS or
+      * WMS configs; and only evaluates those values.
+      *
+      * If the Cornerstone is not active, this method is the same as calling Configuration.diff()
+      *
+      * TODO This should be an overloaded method in Configuration class.
+      */
+      public int diffWindowPanelConfiguration(Configuration wpConfig, Configuration otherConfig) {
+         //When the Cornerstone is not active, ignore any Window Panel logic and
+         // return the standard response
+         if(mCornerstoneState == Cornerstone_State.TERMINATED) {
+             return wpConfig.diff(otherConfig);
+         }
+         int changed = 0;
+
+         if (otherConfig.screenLayout != Configuration.SCREENLAYOUT_SIZE_UNDEFINED
+                 && wpConfig.screenLayout != otherConfig.screenLayout) {
+             changed |= ActivityInfo.CONFIG_SCREEN_LAYOUT;
+         }
+         if (otherConfig.screenWidthDp != Configuration.SCREEN_WIDTH_DP_UNDEFINED
+                 && wpConfig.screenWidthDp != otherConfig.screenWidthDp) {
+             changed |= ActivityInfo.CONFIG_SCREEN_SIZE;
+         }
+         if (otherConfig.screenHeightDp != Configuration.SCREEN_HEIGHT_DP_UNDEFINED
+                 && wpConfig.screenHeightDp != otherConfig.screenHeightDp) {
+             changed |= ActivityInfo.CONFIG_SCREEN_SIZE;
+         }
+         if (otherConfig.smallestScreenWidthDp != Configuration.SMALLEST_SCREEN_WIDTH_DP_UNDEFINED
+                 && wpConfig.smallestScreenWidthDp != otherConfig.smallestScreenWidthDp) {
+             changed |= ActivityInfo.CONFIG_SMALLEST_SCREEN_SIZE;
+         }
+
+          return changed;
+      }
+
+     /**
+      * Author: Onskreen
+      * Date: 26/12/2011
+      *
+      * Given an ActivityRecord and a configuration, returns a config which is manipulated
+      * to match what it should be for this ActivityRecord. If the ActivityRecord does
+      * not exist in a Window Panel (wallpaper, status bar, etc...), the config is returned
+      * unchanged.
+      */
+     public Configuration computeWindowPanelConfiguration(Configuration config, IBinder token, Cornerstone_State csState) {
+        WindowPanel wp = findWindowPanel(token);
+        //Token does not live in a Window Panel
+        if(wp == null) {
+            return config;
+        }
+
+        Configuration wpConfig = null;
+        if(wp.isCornerstone()) {
+            wpConfig = computeWindowPanelConfiguration(WP_Panel.CORNERSTONE, config.orientation, csState);
+        } else if(wp.isMainPanel()) {
+            wpConfig = computeWindowPanelConfiguration(WP_Panel.MAIN_PANEL, config.orientation, csState);
+        } else if(wp.isCornerstonePanel() && wp.mCornerstonePanelIndex == 0) {
+            wpConfig = computeWindowPanelConfiguration(WP_Panel.CS_APP_0, config.orientation, csState);
+        } else if(wp.isCornerstonePanel() && wp.mCornerstonePanelIndex == 1) {
+            wpConfig = computeWindowPanelConfiguration(WP_Panel.CS_APP_1, config.orientation, csState);
+        } else {
+             //Should never happen
+             return config;
+        }
+
+        //Copy the relevant portions of the WP specific config. Exclude orientation and locale,
+        //preserve that from the original
+        Configuration newConfig = new Configuration(config);
+        newConfig.screenWidthDp = wpConfig.screenWidthDp ;
+        newConfig.screenHeightDp = wpConfig.screenHeightDp;
+        newConfig.compatScreenHeightDp = wpConfig.compatScreenHeightDp;
+        newConfig.compatScreenWidthDp = wpConfig.compatScreenWidthDp ;
+        newConfig.compatSmallestScreenWidthDp = wpConfig.compatSmallestScreenWidthDp;
+        newConfig.smallestScreenWidthDp = wpConfig.smallestScreenWidthDp;
+        newConfig.screenLayout = wpConfig.screenLayout;
+        return newConfig;
+     }
+
+    /**
+     * Author: Onskreen
+     * Date: 26/12/2011
+     *
+     * Given a Window Panel, returns a Configuration which is the same as mCurConfiguration
+     * except for the specific values that are special for this Window Panel.
+     *
+     * - Defaults to using the WMS.mCurConfiguration.orientation and the current Cornerstone_State
+     *
+     */
+     public Configuration computeWindowPanelConfiguration(WP_Panel panel) {
+		int orientation = mCurConfiguration.orientation;
+		return computeWindowPanelConfiguration(panel, orientation, mCornerstoneState);
+     }
+
+    /**
+     * Author: Onskreen
+     * Date: 26/12/2011
+     *
+     * Given a Window Panel, orientation and Cornerstone_State, returns a Configuration which is the same
+     * as mCurConfiguration
+     * except for the specific values that are special for this Window Panel and in the specified
+     * orientation.
+     *
+     * Does the actual work of calculating the config. Mimics relevant portions of
+     * WMS.computeNewConfigurationLocked(Configuration)
+     *
+     * TODO The configuration logic is based on Surface.Rotation and not Configuration.orientation which we are
+     * accepting as input to this method. The mixing of this logic for comparison in the following chain
+     * of methods should be cleaned up.
+     */
+    private Configuration computeWindowPanelConfiguration(WP_Panel panel, int orientation, Cornerstone_State csState) {
+        /**
+         * To avoid re-configurations, we build up all WP configurations for the case where the CS is open. This is due
+         * to the large number of apps that crash when being relaunched by the framework on a screen_layout configuration change.
+         */
+        if(csState == Cornerstone_State.RUNNING_CLOSED)
+            csState = Cornerstone_State.RUNNING_OPEN;
+		Rect wpRect = computeWindowPanelRect(panel, orientation, csState);
+        //Besides what we config special for WindowPanel the rest of the config should match
+        //the existing config
+		Configuration wpConfig = new Configuration(mCurConfiguration);
+		wpConfig.orientation = orientation;
+		boolean rotated = false;
+		int realdw = wpRect.width();
+        int realdh = wpRect.height();
+
+        //Not dealing with configuring mAltOrientation
+        //Not explicitly calculating mCompatibleScreenScale since that is for the overall display. This could cause
+        // 	an issue when the Main Panel runs in compatibility mode and the CS is running.
+
+		wpConfig.screenWidthDp = (int)(realdw/mDisplayMetrics.density);
+		wpConfig.screenHeightDp = (int)(realdh/mDisplayMetrics.density);
+		computeSmallestWidthAndScreenLayout(rotated, realdw, realdh, mDisplayMetrics.density, wpConfig, panel, csState);
+
+        wpConfig.compatScreenWidthDp = (int)(wpConfig.screenWidthDp/mCompatibleScreenScale);
+		wpConfig.compatScreenHeightDp = (int)(wpConfig.screenHeightDp/mCompatibleScreenScale);
+		//TODO implement WP Version of computeCompatSmallestWidth
+		//wpConfig.compatSmallestScreenWidthDp = computeCompatSmallestWidth(rotated, dm, dw, dh, panel);
+
+		if(DEBUG_WP_CONFIG) {
+			String orientationStr;
+			if(orientation == Configuration.ORIENTATION_LANDSCAPE)
+				orientationStr = "landscape";
+			else if(orientation == Configuration.ORIENTATION_PORTRAIT)
+				orientationStr = "portrait";
+			else
+				orientationStr = "unknown";
+
+			Slog.v(TAG, "WPPanel: " + panel + " orientation: " + orientationStr + " CS State: " + mCornerstoneState );
+			Slog.v(TAG, "Rect: " + wpRect);
+			Slog.v(TAG, "Config:\t" + wpConfig );
+			Slog.v(TAG, "mCurConfiguration:\t" + mCurConfiguration );
+		}
+		return wpConfig;
+
+    }
+
+    /**
+     * Author: Onskreen
+     * Date: 26/12/2011
+     *
+     * Mimic of computeSmallestWidthAndScreenLayout() with Cornerstone specific config logic
+     */
+    private void computeSmallestWidthAndScreenLayout(boolean rotated, int dw, int dh,
+            float density, Configuration outConfig, WP_Panel panel, Cornerstone_State csState) {
+        // We need to determine the smallest width that will occur under normal
+        // operation.  To this, start with the base screen size and compute the
+        // width under the different possible rotations.  We need to un-rotate
+        // the current screen dimensions before doing this.
+        int unrotDw, unrotDh;
+        if (rotated) {
+            unrotDw = dh;
+            unrotDh = dw;
+        } else {
+            unrotDw = dw;
+            unrotDh = dh;
+        }
+        /**
+         * Since the WP rect is calculated based on Configuration.orientation and not Surface.Rotation
+         * we only have to test for 2 rotations to check all the cases. If we were to support
+         * all rotation and different orientations, the computeWindowPanelRect logic
+         * would need to be enhanced to calculate based on rotation, not orientation.
+         */
+        int sw = reduceConfigWidthSize(unrotDw, Surface.ROTATION_0, density, panel, csState);
+        sw = reduceConfigWidthSize(sw, Surface.ROTATION_90, density, panel, csState);
+        //sw = reduceConfigWidthSize(sw, Surface.ROTATION_180, density, panel, csState);
+        //sw = reduceConfigWidthSize(sw, Surface.ROTATION_270, density, panel, csState);
+        int sl = Configuration.SCREENLAYOUT_SIZE_XLARGE
+                | Configuration.SCREENLAYOUT_LONG_YES;
+        sl = reduceConfigLayout(sl, Surface.ROTATION_0, density, panel, csState);
+        sl = reduceConfigLayout(sl, Surface.ROTATION_90, density, panel, csState);
+        //sl = reduceConfigLayout(sl, Surface.ROTATION_180, density,panel, csState);
+        //sl = reduceConfigLayout(sl, Surface.ROTATION_270, density, panel, csState);
+        outConfig.smallestScreenWidthDp = sw;
+        outConfig.screenLayout = sl;
+    }
+
+    /**
+     * Author: Onskreen
+     * Date: 26/12/2011
+     *
+     * Mimic of reduceConfigWidthSize() with Cornerstone specific config logic.
+     *
+     * TODO This is actually WindowManagerPolicy logic and doesn't belong in the WMS. But since
+     * our WindowPanels are managing themelves for any decor it is ending up here.
+     */
+    private int reduceConfigWidthSize(int curSize, int rotation, float density, WP_Panel panel, Cornerstone_State csState) {
+        Rect rect;
+        if(rotation == Surface.ROTATION_0 || rotation == Surface.ROTATION_180) {
+            rect = computeWindowPanelRect(panel, Configuration.ORIENTATION_LANDSCAPE, csState);
+        } else if(rotation == Surface.ROTATION_90 || rotation == Surface.ROTATION_270) {
+            rect = computeWindowPanelRect(panel, Configuration.ORIENTATION_PORTRAIT, csState);
+        } else {
+            //If things go bad, default to landscape
+            rect = computeWindowPanelRect(panel, Configuration.ORIENTATION_LANDSCAPE, csState);
+        }
+		int size = rect.width();
+        if (size < curSize) {
+            curSize = size;
+        }
+        return curSize;
+    }
+
+    /**
+     * Author: Onskreen
+     * Date: 26/12/2011
+     *
+     * Mimic of reduceConfigLayout() with Cornerstone specific config logic
+     */
+    private int reduceConfigLayout(int curLayout, int rotation, float density, WP_Panel panel, Cornerstone_State csState) {
+        int screenLayoutSize;
+        boolean screenLayoutLong;
+        boolean screenLayoutCompatNeeded;
+
+        Rect rect;
+        if(rotation == Surface.ROTATION_0 || rotation == Surface.ROTATION_180) {
+            rect = computeWindowPanelRect(panel, Configuration.ORIENTATION_LANDSCAPE, csState);
+        } else if(rotation == Surface.ROTATION_90 || rotation == Surface.ROTATION_270) {
+            rect = computeWindowPanelRect(panel, Configuration.ORIENTATION_PORTRAIT, csState);
+        } else {
+            //If things go bad, default to landscape
+            rect = computeWindowPanelRect(panel, Configuration.ORIENTATION_LANDSCAPE, csState);
+        }
+		int longSize = rect.width();
+		int shortSize = rect.height();
+
+		//PORTRAIT
+		if (longSize < shortSize) {
+            int tmp = longSize;
+            longSize = shortSize;
+            shortSize = tmp;
+		}
+        longSize = (int)(longSize/density);
+        shortSize = (int)(shortSize/density);
+
+        // These semi-magic numbers define our compatibility modes for
+        // applications with different screens.  These are guarantees to
+        // app developers about the space they can expect for a particular
+        // configuration.  DO NOT CHANGE!
+        if (longSize < 470) {
+            // This is shorter than an HVGA normal density screen (which
+            // is 480 pixels on its long side).
+            screenLayoutSize = Configuration.SCREENLAYOUT_SIZE_SMALL;
+            screenLayoutLong = false;
+            screenLayoutCompatNeeded = false;
+        } else {
+            // What size is this screen screen?
+            if (longSize >= 960 && shortSize >= 720) {
+                // 1.5xVGA or larger screens at medium density are the point
+                // at which we consider it to be an extra large screen.
+                screenLayoutSize = Configuration.SCREENLAYOUT_SIZE_XLARGE;
+            } else if (longSize >= 640 && shortSize >= 480) {
+                // VGA or larger screreduceConfigLayoutens at medium density are the point
+                // at which we consider it to be a large screen.
+                screenLayoutSize = Configuration.SCREENLAYOUT_SIZE_LARGE;
+            } else {
+                screenLayoutSize = Configuration.SCREENLAYOUT_SIZE_NORMAL;
+            }
+
+            // If this screen is wider than normal HVGA, or taller
+            // than FWVGA, then for old apps we want to run in size
+            // compatibility mode.
+            if (shortSize > 321 || longSize > 570) {
+                screenLayoutCompatNeeded = true;
+            } else {
+                screenLayoutCompatNeeded = false;
+            }
+
+            // Is this a long screen?
+            if (((longSize*3)/5) >= (shortSize-1)) {
+                // Anything wider than WVGA (5:3) is considering to be long.
+                screenLayoutLong = true;
+            } else {
+                screenLayoutLong = false;
+            }
+        }
+
+        // Now reduce the last screenLayout to not be better than what we
+        // have found.
+        if (!screenLayoutLong) {
+            curLayout = (curLayout&~Configuration.SCREENLAYOUT_LONG_MASK)
+                    | Configuration.SCREENLAYOUT_LONG_NO;
+        }
+        if (screenLayoutCompatNeeded) {
+            curLayout |= Configuration.SCREENLAYOUT_COMPAT_NEEDED;
+        }
+        int curSize = curLayout&Configuration.SCREENLAYOUT_SIZE_MASK;
+        if (screenLayoutSize < curSize) {
+            curLayout = (curLayout&~Configuration.SCREENLAYOUT_SIZE_MASK)
+                    | screenLayoutSize;
+        }
+
+		return curLayout;
+
+    }
+
     public Configuration updateOrientationFromAppTokens(
             Configuration currentConfig, IBinder freezeThisOneIfNeeded) {
         if (!checkCallingPermission(android.Manifest.permission.MANAGE_APP_TOKENS,
@@ -3917,6 +5330,19 @@ public class WindowManagerService extends IWindowManager.Stub
         synchronized(mWindowMap) {
             mCurConfiguration = new Configuration(config);
             mWaitingForConfig = false;
+            /**
+             * Author: Onskreen
+             * Date: 14/04/2011
+             *
+             * Before calling PLAPLSL method, we should update the mFrame rect based on
+             * the current orientation of the main panel activity.
+             *
+             */
+            //NOTE: To tunr off the orientation support comment this code.
+            for(int k=0; k < mWindowPanels.size(); k++) {
+                WindowPanel wp = mWindowPanels.get(k);
+                wp.updateConfiguration(false);
+            }
             performLayoutAndPlaceSurfacesLocked();
         }
     }
@@ -4447,6 +5873,26 @@ public class WindowManagerService extends IWindowManager.Stub
                 return;
             }
 
+            /**
+             * Author: Onskreen
+             * Date: 31/05/2011
+             *
+             * Resolves the focus issue when user presses the HOME key or long presses the HOME key.
+             */
+            if(visible){
+                WindowPanel wp = findWindowPanel(token);
+                if(wp != null){
+                    try {
+                        WindowState win = wtoken.findMainWindow();
+                        if(win != null){
+                            mActivityManager.broadcastCornerstonePanelFocusChanged(win.mAttrs.packageName, visible, wp.mCornerstonePanelIndex);
+                        }
+                    } catch (android.os.RemoteException e){
+                        Log.i(TAG, "Remote Exception while notifying to CSPanel: " + e);
+                    }
+                }
+            }
+
             if (DEBUG_APP_TRANSITIONS || DEBUG_ORIENTATION) {
                 RuntimeException e = null;
                 if (!HIDE_STACK_CRAWLS) {
@@ -4673,6 +6119,55 @@ public class WindowManagerService extends IWindowManager.Stub
                         "removeAppToken: " + wtoken);
                 mAppTokens.remove(wtoken);
                 mAnimatingAppTokens.remove(wtoken);
+
+                /**
+                 * Author: Onskreen
+                 * Date: 24/01/2011
+                 *
+                 * When the AppWindowToken is removed, its WindowPanel
+                 * position must be wiped also if there are no remaining
+                 * AppWindowTokens included in that WP. At this point the
+                 * Windows associated with this AppWindowTOken should
+                 * have already been removed.
+                 */
+                boolean doTokensWithIdStillExist = false;
+                if (DEBUG_WP_GROUPING)
+                    Log.v(TAG, "Evaluating if Token with Group ID:" + wtoken.groupId
+                            + " has remaining");
+                for (int i = 0; i < mAppTokens.size(); i++) {
+                    AppWindowToken currAppWindowToken = mAppTokens.get(i);
+                    if (wtoken != currAppWindowToken
+                            && wtoken.groupId == currAppWindowToken.groupId) {
+                        if (DEBUG_WP_GROUPING)
+                            Log.v(TAG, "Other Token with Group ID:" + wtoken.groupId + " found");
+                        doTokensWithIdStillExist = true;
+                        break;
+                    }
+                }
+                // No other tokens with this groupid exist, remove it from it's
+                // window panel
+                if (!doTokensWithIdStillExist) {
+                    for (int i = 0; i < mWindowPanels.size(); i++) {
+                        WindowPanel wp = mWindowPanels.get(i);
+                        // Found the Window Panel containing this token's group
+                        if (wp.contains(wtoken.groupId)) {
+                            wp.removeGroupId(wtoken.groupId);
+                            if (wp.isWindowPanelEmpty()) {
+                                if (DEBUG_WP_GROUPING)
+                                    Log.v(TAG, "WP: " + wp + " now empty, removing...");
+                                mWindowPanels.remove(wp);
+                                if (DEBUG_WP_GROUPING) {
+                                    Log.v(TAG, "Active Window Panels:");
+                                    for (int i2 = 0; i2 < mWindowPanels.size(); i2++) {
+                                        WindowPanel wp2 = mWindowPanels.get(i2);
+                                        Log.v(TAG, wp2.toString());
+                                    }
+                                }
+                            }
+                        }
+                    }
+                }
+
                 wtoken.removed = true;
                 if (wtoken.startingData != null) {
                     startingToken = wtoken;
@@ -4741,6 +6236,15 @@ public class WindowManagerService extends IWindowManager.Stub
         }
     }
 
+    /**
+     * Author: Onskreen
+     * Date: 15/01/2011
+     *
+     * TODO - Does this have to be updated to ensure that the cornerstone panels are never rendered below
+     * the cornerstone itself? This may depend on if the cornerstone itself gets moved to the top when focused?
+     * @param tokenPos
+     * @return
+     */
     private int findWindowOffsetLocked(int tokenPos) {
         final int NW = mWindows.size();
 
@@ -5360,7 +6864,6 @@ public class WindowManagerService extends IWindowManager.Stub
                                 && w.mPolicyVisibility;
                         haveKeyguard = !vis;
                     }
-                   
                     if (w.isVisibleLw() && !w.mObscured && !w.isDrawnLw()) {
                         return;
                     }
@@ -5400,8 +6903,7 @@ public class WindowManagerService extends IWindowManager.Stub
             }
 
             mDisplayEnabled = true;
-            if (DEBUG_SCREEN_ON || DEBUG_BOOT) Slog.i(TAG, "******************** ENABLING SCREEN!");  
-            
+            if (DEBUG_SCREEN_ON || DEBUG_BOOT) Slog.i(TAG, "******************** ENABLING SCREEN!");
             if (false) {
                 StringWriter sw = new StringWriter();
                 PrintWriter pw = new PrintWriter(sw);
@@ -5628,10 +7130,6 @@ public class WindowManagerService extends IWindowManager.Stub
 
             // The screenshot API does not apply the current screen rotation.
             rot = mDisplay.getRotation();
-//			if(SystemProperties.getInt("ro.sf.hwrotation",0)==270)
-//			{						
-//				rot =( rot+3)%4;
-//			}
             int fw = frame.width();
             int fh = frame.height();
 
@@ -5690,8 +7188,60 @@ public class WindowManagerService extends IWindowManager.Stub
         canvas.setBitmap(null);
 
         rawss.recycle();
+        //return bm;
+
+        /**
+         * Author: Onskreen
+         * Date: 24/12/2011
+         *
+         * Crop and rescale the bmp to capture just the application panel
+         * that is being targeted. Perform operation separately to make
+         * easier to port later.
+         *
+         * Issue with this is that cropping and resizing the bmp causes a grainier
+         * screenshot. To truly solve this problem, it would be better to
+         * create/edit Surface.screenshot to accept additional parameters of the
+         * rect to take screenshot of instead of assuming the entire display.
+         *
+         * This cropping and resizing logic fails in some situations for the CSPanel
+         * and CS Apps. Not dealing with those cases right now since the screenshots
+         * taken of main panel apps are the only ones actually used.
+         *
+         */
+        WindowPanel wp = findWindowPanel(appToken);
+        if(wp.isMainPanel()) {
+            float targetWidthScale = width / (float) frame.width();
+            float targetHeightScale = height / (float) frame.height();
+
+            Rect targetRect = wp.getPos();
+            int top = (int)(targetRect.top*targetHeightScale);
+            int left = (int)(targetRect.left*targetWidthScale);
+            int bottom = (int)(targetRect.bottom*targetHeightScale);
+            int right = (int)(targetRect.right*targetWidthScale);
+            int scaledWidth = right-left;
+            int scaledHeight = bottom-top;
+            int bmWidth = bm.getWidth();
+            int bmHeight = bm.getHeight();
+            try {
+                Bitmap croppedBm = Bitmap.createBitmap(bm,
+                        left,
+                        top,
+                        scaledWidth,
+                        scaledHeight);
+                return croppedBm;
+            } catch(IllegalArgumentException e) {
+                if(DEBUG_SCREENSHOT) {
+                    Slog.e(TAG, "AppToken: " + appToken + " failed to crop");
+                    Slog.e(TAG, e.toString());
+                    Slog.e(TAG, "Source Bitmap - Height: " + bmHeight + " Width: " + bmWidth);
+                    Slog.e(TAG, "Cropped Bitmap - x: " + left + " y: " + top + " width: " + scaledWidth + " height: " + scaledHeight);
+                }
+                return bm;
+            }
+        } else {
         return bm;
     }
+    }
 
     /**
      * Freeze rotation changes.  (Enable "rotation lock".)
@@ -5800,8 +7334,7 @@ public class WindowManagerService extends IWindowManager.Stub
             }
         }
 
-        if (changed || alwaysSendConfiguration) {    
-        	mDPM.notifyUsrPulse();
+        if (changed || alwaysSendConfiguration) {
             sendNewConfiguration();
         }
 
@@ -5865,6 +7398,27 @@ public class WindowManagerService extends IWindowManager.Stub
                 + ", forceApp=" + mForcedAppOrientation);
         }
 
+        /**
+         * Author: Onskreen
+         * Date: 26/12/2011
+         *
+         * Before rotating, if a Cornerstone Panel app has the focus, transfer the focus to the
+         * Main Panel. This accomplishes transferring the focus as well as dismissing any system
+         * dialogs or keyboard that might be visible.
+         *
+         */
+        WindowState focusedWin = getFocusedWindow();
+        if(focusedWin != null && focusedWin.isInCornerstonePanelWindowPanel(focusedWin.getToken())) {
+            for(WindowPanel wp: mWindowPanels) {
+                if(wp.isMainPanel()) {
+                    if (DEBUG_ORIENTATION || DEBUG_CORNERSTONE) {
+                        Slog.v(TAG,"Panel App transferring focus to main panel before rotation. ");
+                    }
+                    handleFocusChange(wp.getVisibleToken().token);
+                }
+            }
+        }
+
         mRotation = rotation;
         mAltOrientation = altOrientation;
         mPolicy.setRotationLw(mRotation);
@@ -6131,23 +7685,15 @@ public class WindowManagerService extends IWindowManager.Stub
 
         // Any uncaught exception will crash the system process
         try {
-			int focus_hashcode = System.identityHashCode( mCurrentFocus );
-
-//			Slog.i( "zhaowenjie", " focus_hashcode ====== " + focus_hashcode );
             OutputStream clientStream = client.getOutputStream();
             out = new BufferedWriter(new OutputStreamWriter(clientStream), 8 * 1024);
 
             final int count = windows.length;
             for (int i = 0; i < count; i++) {
                 final WindowState w = windows[i];
-				int hashcode = System.identityHashCode(w);
-                out.write(Integer.toHexString( hashcode ));				
+                out.write(Integer.toHexString(System.identityHashCode(w)));
                 out.write(' ');
                 out.append(w.mAttrs.getTitle());
-				if ( hashcode == focus_hashcode )
-				{
-					out.write('$');
-				}
                 out.write('\n');
             }
 
@@ -6351,6 +7897,1381 @@ public class WindowManagerService extends IWindowManager.Stub
         }
     }
 
+    /**
+     * Author: Onskreen
+     * Date: 01/01/2012
+     *
+     * Marshall to the appropriate spot to manage change in Cornerstone state.
+     */
+    public void setCornerstoneState(Cornerstone_State csState) {
+        if(DEBUG_CORNERSTONE) {
+            Log.v(TAG, "Current Cornerstone State: " + mCornerstoneState);
+            Log.v(TAG, "Requested Cornerstone State: " + csState);
+        }
+
+        //Launch Cornerstone
+		if(mCornerstoneState == Cornerstone_State.TERMINATED &&				//Launch Cornerstone
+				(csState == Cornerstone_State.RUNNING_CLOSED ||
+						csState == Cornerstone_State.RUNNING_OPEN)) {
+			if(DEBUG_CORNERSTONE) {
+				Log.v(TAG, "Action: Launching Cornerstone");
+			}
+			handleCornerstoneLaunch(csState);
+		} else if((mCornerstoneState == Cornerstone_State.RUNNING_OPEN ||	//Exit Cornerstone
+				mCornerstoneState == Cornerstone_State.RUNNING_CLOSED) &&
+				csState == Cornerstone_State.TERMINATED) {
+			if(DEBUG_CORNERSTONE) {
+				Log.v(TAG, "Action: Exiting Cornerstone");
+			}
+			handleCornerstoneExit();
+		} else if(csState != mCornerstoneState &&							//Cornerstone State Change
+				((csState == Cornerstone_State.RUNNING_CLOSED ||
+						csState == Cornerstone_State.RUNNING_OPEN) &&
+						(mCornerstoneState == Cornerstone_State.RUNNING_CLOSED ||
+								mCornerstoneState == Cornerstone_State.RUNNING_OPEN))) {
+			if(DEBUG_CORNERSTONE) {
+				Log.v(TAG, "Action: Cornerstone Open/Close");
+			}
+			handleCornerstoneOpenClose(csState);
+		} else {
+			if(DEBUG_CORNERSTONE) {
+				Log.v(TAG, "Action: None. No state change to manage.");
+			}
+		}
+    }
+
+    /**
+     * Author: Onskreen
+     * Date: 01/01/2012
+     *
+     * Terminate the Cornerstone if currently running.
+     */
+    private void handleCornerstoneExit() {
+        //Safety Checks - Not already terminated
+        if(mCornerstoneState == Cornerstone_State.TERMINATED) {
+            if(DEBUG_CORNERSTONE) Slog.v(TAG, "Cornerstone already terminated.");
+            return;
+        }
+        if(DEBUG_CORNERSTONE) Slog.v(TAG, "Exiting Cornerstone");
+
+        long origId = Binder.clearCallingIdentity();
+        mCornerstoneStateChangeAnimating = false;
+        mCornerstoneState = Cornerstone_State.TERMINATED;
+
+        /**
+         * Author: Onskreen
+         * Date: 21/11/2011
+         *
+         * The method is triggered by the AMS whenever user kills
+         * the Cornesrtone and relaunches again. Earlier, we were only setting the main
+         * panel mFrame i.e layout rect in those set of sequences and that created so many
+         * layout issues like CS Panel apps rendering full screen instead of rendeing in its
+         * panel area. To resolve this issue, we should also set the mFrame rect for all other
+         * apps when user restarts the Cornerstone after killing it. The below solution
+         * resolved all those layout issues caused by the ealrier implementation.
+         */
+        synchronized(mWindowMap) {
+            for(WindowPanel wp: mWindowPanels) {
+                wp.setFrame(computeWindowPanelRect(wp, mCurConfiguration.orientation, mCornerstoneState));
+            }
+            mLayoutNeeded=true;
+            performLayoutAndPlaceSurfacesLocked();
+        }
+
+        /**
+         * Author: Onskreen
+         * Date: 26/12/2011
+         *
+         * Only the main panel config is actually changing. Cornerstone is gone and the main panel
+         * remains.
+         */
+        for(WindowPanel wp: mWindowPanels) {
+            if(wp.isMainPanel()) {
+                wp.updateConfiguration(false);
+                break;
+            }
+        }
+        Binder.restoreCallingIdentity(origId);
+    }
+
+    /**
+     * Author: Onskreen
+     * Date: 01/01/2012
+     *
+     * Launch the Cornerstone if currently terminated.
+     */
+    private void handleCornerstoneLaunch(Cornerstone_State csState) {
+       //Safety Checks - Not already launched
+       if(mCornerstoneState != Cornerstone_State.TERMINATED) {
+            if(DEBUG_CORNERSTONE) {
+                 Slog.v(TAG, "Cornerstone already launched, handle open/close if required.");
+            }
+            handleCornerstoneOpenClose(csState);
+            return;
+       }
+       if(DEBUG_CORNERSTONE) {
+             Slog.v(TAG, "Exiting Cornerstone");
+       }
+       long origId = Binder.clearCallingIdentity();
+       mCornerstoneStateChangeAnimating = false;
+       mCornerstoneState = csState;
+
+       /**
+        * Author: Onskreen
+        * Date: 21/11/2011
+        *
+        * The setCornerstoneLayout method is triggered by the AMS whenever user kills
+        * the Cornesrtone and relaunches again.
+        */
+       synchronized(mWindowMap) {
+           for(WindowPanel wp: mWindowPanels) {
+               wp.setFrame(computeWindowPanelRect(wp, mCurConfiguration.orientation, mCornerstoneState));
+           }
+           mLayoutNeeded=true;
+           performLayoutAndPlaceSurfacesLocked();
+       }
+
+       /**
+        * Author: Onskreen
+        * Date: 26/12/2011
+        *
+        * Only the main panel config is actually changing. Cornerstone is gone and the main panel
+        * remains.
+        */
+       for(WindowPanel wp: mWindowPanels) {
+          if(wp.isMainPanel()) {
+             wp.updateConfiguration(false);
+             break;
+          }
+       }
+       Binder.restoreCallingIdentity(origId);
+    }
+
+    /**
+     * Author: Onskreen
+     * Date: 14/02/2012
+     *
+     * Manage cornerstone panel dialog window.
+     * - Hides the dialog window when cornerstone is closed.
+     * - Shows the dialog window when cornerstone is opened.
+     *
+     */
+    private void handleCSPanelDialogWindows(Cornerstone_State csState) {
+		for(int i=mWindowPanels.size()-1; i>=0; i--) {
+			WindowPanel wp = mWindowPanels.get(i);
+			if(wp.isCornerstonePanel()) {
+				AppWindowToken csPanelToken = wp.getVisibleToken();
+				int N = csPanelToken.allAppWindows.size();
+					for (int k = 0; k < N; k++) {
+						WindowState win = csPanelToken.allAppWindows.get(k);
+						WindowManager.LayoutParams attrs = win.mAttrs;
+						if(attrs.type == WindowManager.LayoutParams.TYPE_APPLICATION) {
+						try {
+							if(csState == Cornerstone_State.RUNNING_CLOSED) {
+								win.mWinAnimator.mSurface.hide();
+							} else if(csState == Cornerstone_State.RUNNING_OPEN) {
+								win.mWinAnimator.mSurface.show();
+								handleFocusChange(win.getToken());
+							}
+						} catch (RuntimeException e) {
+							Slog.w(WindowManagerService.TAG, "Error hiding surface in " + this, e);
+						}
+					}
+				}
+			}
+		}
+	}
+
+    /**
+     * Author: Onskreen
+     * Date: 25/02/2011
+     *
+     * Manage cornerstone state: open or closed. The implementation is functional but not optimal.
+     *
+     * There is complexity in getting the framework to display to the screen in one update the resize
+     * of the main panel and the animation (or move) of the cornerstone to the open/closed state.
+     * Changes are done by starting a Surface.openTransaction(), making the changes desired and then
+     * calling Surface.closeTransaction() at which the changes are displayed on screen. The issue
+     * is that the resize of a ViewRoot (which is what is happening on the main panel) does not actually get
+     * displayed to the screen in the Surface.closeTransation() within WMS.PLAPSL(). The actual
+     * change seems to get output to the screen in the View classes somewhere (not clear where). So
+     * the animation or move changes of the cornerstone is displayed to the screen and the View resize
+     * is actually happening shortly thereafter.
+     *
+     * The ideal scenario is that the main panel is resized in coordination with ever screen update
+     * of the cornerstone in its state change. However, it is actually being called before or after this.
+     *
+    */
+    private void handleCornerstoneOpenClose(Cornerstone_State csState) {
+		if(DEBUG_CORNERSTONE) {
+			Slog.v(TAG, "Start: Cornerstone State Change to: " + csState);
+		}
+
+		//Safety Checks - State is different
+		if(mCornerstoneState == csState) {
+            if(DEBUG_CORNERSTONE) Slog.v(TAG, "Cornerstone already in requested state.");
+            return;
+		}
+
+		WindowPanel cornerstoneWP = null;
+        ArrayList<WindowPanel> csPanelWPs = new ArrayList<WindowPanel>();
+        WindowPanel mainPanelWP = null;
+
+        //Locate all the relevant WP
+        for(int i=0; i<mWindowPanels.size(); i++) {
+            WindowPanel wp = mWindowPanels.get(i);
+            if(wp.isMainPanel()) {
+                mainPanelWP = wp;
+            } else if(wp.isCornerstone()) {
+                cornerstoneWP = wp;
+            } else if(wp.isCornerstonePanel()) {
+                csPanelWPs.add(wp);
+            }
+        }
+
+        WindowManager wm = (WindowManager) mContext.getSystemService(Context.WINDOW_SERVICE);
+        Display display = wm.getDefaultDisplay();
+
+        //Start X Pos of the cornerstone and cornerstone panels
+        int csStartPos = 0; //cornerstoneWP.getPos().left;
+        int csEndPos = 0;
+        //Controls the amount of time the cornerstone state transition animation takes
+        long animDuration;
+
+        if(csState == Cornerstone_State.RUNNING_CLOSED) {             		//Closing
+            //X Pos to stop cornerstone so handler tab is still visible on right edge.
+            /**
+             * Author: Onskreen
+             * Date: 14/04/2011
+             *
+             * Calculates the start and end positions based on the current orientation
+             * while closing the cs panel.
+             */
+            if(mCurConfiguration.orientation == Configuration.ORIENTATION_PORTRAIT) {
+                csEndPos  = display.getHeight() - mCornerstoneHandlerPortraitWidth;
+                csStartPos = cornerstoneWP.getPos().top;
+            } else if(mCurConfiguration.orientation == Configuration.ORIENTATION_LANDSCAPE){
+                csEndPos  = display.getWidth() - mCornerstoneHandlerLandscapeWidth;
+                csStartPos = cornerstoneWP.getPos().left;
+            }
+            animDuration = DEFAULT_FADE_IN_OUT_DURATION;                    //400ms
+        } else {                											//Opening
+            //X Pos to stop cornerstone to be open fully
+            /**
+             * Author: Onskreen
+             * Date: 14/04/2011
+             *
+             * Calculates the start and end positions based on the current orientation
+             * while opening the cs panel.
+             */
+            if(mCurConfiguration.orientation == Configuration.ORIENTATION_PORTRAIT) {
+                csEndPos  = display.getHeight() - (mCornerstoneHandlerPortraitWidth + mCornerstonePanelPortraitHeight + mCornerstoneAppHeaderPortraitHeight);
+                csStartPos = cornerstoneWP.getPos().top;
+            } else if(mCurConfiguration.orientation == Configuration.ORIENTATION_LANDSCAPE){
+                csEndPos  = display.getWidth() - (mCornerstoneHandlerLandscapeWidth + mCornerstonePanelLandscapeWidth);
+                csStartPos = cornerstoneWP.getPos().left;
+            }
+            //Opening duration is longer because this amount of time seems to reduce the chances that
+            //the main panel is rendered on top of the cornerstone before it is resized.
+            animDuration = 900;
+        }
+
+        //Amount to open or close the cornerstone
+        int currLayoutDelta = csEndPos-csStartPos;
+        //Update flag so that animation process knows that the views being animated are
+        //intended to remain in the position of their last animation.
+        mCornerstoneStateChangeAnimating = true;
+        mCornerstoneStateChangeProcessing = true;
+        synchronized(mWindowMap) {
+            //Required to safley call PLAPSL()
+            long origId = Binder.clearCallingIdentity();
+
+            if(csState == Cornerstone_State.RUNNING_CLOSED) { 											//Close Cornerstone
+				/**
+                 * Author: Onskreen
+                 * Date: 14/02/2012
+                 *
+                 * Close any dialog window visible on screen before
+                 * closing animation played on cornerstone and its
+                 * panel applications.
+                 */
+				handleCSPanelDialogWindows(csState);
+
+                //Cornerstone Animation
+                AppWindowToken csToken = cornerstoneWP.getVisibleToken();
+                csToken.willBeHidden = false;
+                csToken.mAppAnimator.animation = null;
+                Animation a = null;
+                /**
+                 * Author: Onskreen
+                 * Date: 14/04/2011
+                 *
+                 * When Cornerstone is in portrait mode, start animation towards 'Y' axis (height)
+                 * and when it's in landscape mode start animation towards 'X' axis (width)
+                 */
+                if(mCurConfiguration.orientation == Configuration.ORIENTATION_PORTRAIT) {
+                    a = new TranslateAnimation(0, 0, 0, currLayoutDelta);
+                } else if(mCurConfiguration.orientation == Configuration.ORIENTATION_LANDSCAPE){
+                    a = new TranslateAnimation(0, currLayoutDelta, 0, 0);
+                }
+                a.setDuration(animDuration);
+                a.setZAdjustment(Animation.ZORDER_TOP);
+                csToken.mAppAnimator.setAnimation(a, false);
+
+                //Cornerstone Panel Animations
+                for(int i=0; i<csPanelWPs.size(); i++) {
+                    AppWindowToken csPanelToken = csPanelWPs.get(i).getVisibleToken();
+                    csPanelToken.willBeHidden = false;
+                    csPanelToken.mAppAnimator.animation = null;
+                    Animation csPanelAnim = null;
+                    /**
+                     * Author: Onskreen
+                     * Date: 14/04/2011
+                     *
+                     * When Cornerstone is in portrait mode, start animation towards 'Y' axis (height)
+                     * and when it's in landscape mode start animation towards 'X' axis (width)
+                     */
+                    if(mCurConfiguration.orientation == Configuration.ORIENTATION_PORTRAIT) {
+                        csPanelAnim = new TranslateAnimation(0, 0, 0, currLayoutDelta);
+                    } else if(mCurConfiguration.orientation == Configuration.ORIENTATION_LANDSCAPE){
+                        csPanelAnim = new TranslateAnimation(0, currLayoutDelta, 0, 0);
+                    }
+                    csPanelAnim.setDuration(animDuration);
+                    csPanelAnim.setZAdjustment(Animation.ZORDER_TOP);
+                    csPanelToken.mAppAnimator.setAnimation(csPanelAnim, false);
+                }
+
+                /**It's not clear if making this resize call is better than just calling PLAPSL().
+                 * Hard to tell but seems to have the screen updated slightly faster so keeping it
+                 * this way.
+                 */
+                    //Resize main panel to take up left over space
+                /**
+                 * Author: Onskreen
+                 * Date: 14/04/2011
+                 *
+                 * When Cornerstone is in portrait mode, resize  the main panel towards 'Y' axis (height)
+                 * and when it's in landscape mode, resize the main panel towards 'X' axis (width)
+                 */
+                if(mCurConfiguration.orientation == Configuration.ORIENTATION_PORTRAIT) {
+                    mainPanelWP.resize(0, currLayoutDelta);
+                } else if(mCurConfiguration.orientation == Configuration.ORIENTATION_LANDSCAPE){
+                    mainPanelWP.resize(currLayoutDelta, 0);
+                }
+                WindowState mainWin = mainPanelWP.getVisibleToken().findMainWindow();
+                /**
+                 * Author: Onskreen
+                 * Date: 07/01/2012
+                 *
+                 * Window is manually resized instead of allowing configuration logic to handle it because
+                 * the Main Panel is no longer being reconfigurated on a CS State change from open to close or
+                 * vice versa
+                 */
+                try {
+                    mainWin.mClient.resized(mainPanelWP.getPos().width(), mainPanelWP.getPos().height(),
+                    mainWin.mContentInsets, mainWin.mVisibleInsets,
+                    mainWin.mWinAnimator.mDrawState == WindowStateAnimator.DRAW_PENDING, mainWin.mConfiguration);
+                } catch (RemoteException e) {
+                    e.printStackTrace();
+               }
+            } else if(csState == Cornerstone_State.RUNNING_OPEN) {    									//Opening Cornerstone
+                /**
+                 * Author: Onskreen
+                 * Date: 14/04/2011
+                 *
+                 * When Cornerstone is in portrait mode, resize  the main panel towards 'Y' axis (height)
+                 * and when it's in landscape mode, resize the main panel towards 'X' axis (width)
+                 */
+                if(mCurConfiguration.orientation == Configuration.ORIENTATION_PORTRAIT) {
+                    mainPanelWP.resize(0, currLayoutDelta);
+                } else if(mCurConfiguration.orientation == Configuration.ORIENTATION_LANDSCAPE){
+                    mainPanelWP.resize(currLayoutDelta, 0);
+                }
+                WindowState mainWin = mainPanelWP.getVisibleToken().findMainWindow();
+                /**
+                 * Author: Onskreen
+                 * Date: 07/01/2012
+                 *
+                 * Window is manually resized instead of allowing configuration logic to handle it because
+                 * the Main Panel is no longer being reconfigurated on a CS State change from open to close or
+                 * vice versa
+                 */
+                try {
+                        mCornerstoneStateChangeAnimating = true;
+                        mainWin.mClient.resized(mainPanelWP.getPos().width(), mainPanelWP.getPos().height(),
+                        mainWin.mContentInsets, mainWin.mVisibleInsets, mainWin.mWinAnimator.mDrawState == WindowStateAnimator.DRAW_PENDING, mainWin.mConfiguration);
+                        /**
+                         * This call to PLAPSL() is functinally useless. The call to resized() above triggers a call
+                         * to PLAPSL(). It is included here as a delay to get the main panel resize to get displayed
+                         * to the screen asap, hopefully so that it does not display on top of the cornerstone at
+                         * any time.
+                         */
+                        mLayoutNeeded=true;
+                        performLayoutAndPlaceSurfacesLocked();
+                } catch (RemoteException e) {
+                    e.printStackTrace();
+                }
+
+                //Cornerstone Animation
+                /**
+                 * When opening the cornerstone the setZAdjustment() is important to ensure that the
+                 * cornerstone is animated on top of the main panel. We shouldn't see the main
+                 * panel window rendered on top, although still happening.
+                 */
+                AppWindowToken csToken = cornerstoneWP.getVisibleToken();
+                csToken.willBeHidden = false;
+                csToken.mAppAnimator.animation = null;
+                Animation a = null;
+                /**
+                 * Author: Onskreen
+                 * Date: 14/04/2011
+                 *
+                 * When Cornerstone is in portrait mode, start animation towards 'Y' axis (height)
+                 * and when it's in landscape mode, start animation towards 'X' axis (width)
+                 */
+                if(mCurConfiguration.orientation == Configuration.ORIENTATION_PORTRAIT) {
+                    a = new TranslateAnimation(0, 0, 0, currLayoutDelta);
+                } else if(mCurConfiguration.orientation == Configuration.ORIENTATION_LANDSCAPE){
+                    a = new TranslateAnimation(0, currLayoutDelta, 0, 0);
+                }
+                a.setDuration(animDuration);
+                a.setZAdjustment(Animation.ZORDER_TOP);
+                csToken.mAppAnimator.setAnimation(a, false);
+
+                    //Cornerstone Panel Animations
+                for(int i=0; i<csPanelWPs.size(); i++) {
+                    AppWindowToken csPanelToken = csPanelWPs.get(i).getVisibleToken();
+                    csPanelToken.willBeHidden = false;
+                    csPanelToken.mAppAnimator.animation = null;
+                    Animation csPanelAnim = null;
+                    /**
+                     * Author: Onskreen
+                     * Date: 14/04/2011
+                     *
+                     * When Cornerstone is in portrait mode, start animation towards 'Y' axis (height)
+                     * and when it's in landscape mode, start animation towards 'X' axis (width)
+                     */
+                    if(mCurConfiguration.orientation == Configuration.ORIENTATION_PORTRAIT) {
+                        csPanelAnim = new TranslateAnimation(0, 0, 0, currLayoutDelta);
+                    } else if(mCurConfiguration.orientation == Configuration.ORIENTATION_LANDSCAPE){
+                        csPanelAnim = new TranslateAnimation(0, currLayoutDelta, 0, 0);
+                    }
+                    csPanelAnim.setDuration(animDuration);
+                    csPanelAnim.setZAdjustment(Animation.ZORDER_TOP);
+                    csPanelToken.mAppAnimator.setAnimation(csPanelAnim, false);
+                }
+
+                //Set layout flag so that frames are set appropriately after animations complete
+                mCornerstoneStateChangeAnimating = true;
+                performLayoutAndPlaceSurfacesLocked();
+
+				/**
+                 * Author: Onskreen
+                 * Date: 14/02/2012
+                 *
+                 * Show any hidden dialog window(s) on screen after
+                 * opening animation played on cornerstone and its
+                 * panel applications.
+                 */
+				mH.removeMessages(H.SHOW_HIDDEN_DIALOG_WINDOWS);
+				mH.sendMessageDelayed(mH.obtainMessage(H.SHOW_HIDDEN_DIALOG_WINDOWS),
+						animDuration + 20);
+
+            }
+            Binder.restoreCallingIdentity(origId);
+        }
+
+        //Update Cornerstone State
+        mCornerstoneState = csState;
+        mCornerstoneStateChangeProcessing = false;
+
+        /**
+         * Author: Onskreen
+         * Date: 26/12/2011
+         *
+         * Only the main panel config is actually changing. The CS Panels didn't have a config change,
+         * they are just now resumed and visible or paused and not visible.
+         */
+		mainPanelWP.updateConfiguration(false);
+
+		if(DEBUG_CORNERSTONE) {
+			Slog.v(TAG, "End: Cornerstone State Change to: " + csState);
+			Slog.v(TAG, "mCornerstoneStateChangeProcessing: " + mCornerstoneStateChangeProcessing);
+			Slog.v(TAG, "mCornerstoneStateChangeAnimating: " + mCornerstoneStateChangeAnimating);
+		}
+
+        /**
+         * Onskreen-Cornerstone
+         */
+        if (DEBUG_WP_POSITIONS) {
+            Log.v(TAG, "Cornerstone State: " + mCornerstoneState);
+            Log.v(TAG, "\tMain Panel" + mainPanelWP.mWPPos);
+            Log.v(TAG, "\tCornerstone" + cornerstoneWP.mWPPos);
+        }
+
+        /**
+         * Author: Onskreen
+         * Date: 04/01/2013
+         *
+         * Modify DimAnimator's Parameters object (width and height)
+         * as per Cornerstone's current state (opened or closed).
+         */
+		WindowState mainWin = mainPanelWP.getVisibleToken().findMainWindow();
+		final WindowStateAnimator winAnimator = mainWin.mWinAnimator;
+		mH.sendMessage(mH.obtainMessage(mH.SET_DIM_PARAMETERS,
+			new DimAnimator.Parameters(winAnimator,
+					mainPanelWP.getPos().width(),
+					mainPanelWP.getPos().height(),
+					mainWin.mExiting ? 0 : mainWin.mAttrs.dimAmount)));
+    }
+
+    /**
+     * Author: Onskreen
+     * Date: 11/03/2011
+     *
+     * Convienence method for debugging.
+     */
+    public AppWindowToken getFocusedApp() {
+        return mFocusedApp;
+    }
+
+    /**
+     * Author: Onskreen
+     * Date: 30/11/2011
+     *
+     * Utility method for getting Window Panel list for classes
+     * such as WindowState, AppWindowToken, Session etc.
+     */
+    public ArrayList<WindowPanel> getWindowPanels() {
+        return mWindowPanels;
+    }
+
+    public void handleFocusChangeLocked(IBinder token) {
+		WindowPanel wp = findWindowPanel(token);
+		if(DEBUG_REORDER) {
+			Log.v(TAG, "Moving token: " + token + " (and all tokens in same window panel) to top of z-order");
+			Log.v(TAG, "Containing Window Panel: " + wp);
+			logWindowList("  ");
+			logQuickWMSState();
+		}
+		if(DEBUG_FOCUS) {
+			Log.v(TAG, "Focus state before moving window panel to the top");
+			Log.v(TAG, "\tmCurrentFocus: " + mCurrentFocus);
+			Log.v(TAG, "\tmLastFocus: " + mLastFocus);
+			Log.v(TAG, "\tmFocusedApp: " + mFocusedApp);
+			Log.v(TAG, "\tmFocusMayChange: " + mFocusMayChange);
+			Log.v(TAG, "\tmLosingFocus: " + mLosingFocus);
+		}
+		//Cases that we don't want to take action:
+		//Null WP's occur when the event is actually being sent to dialogs, IME, etc...
+		if(wp == null) {
+			if(DEBUG_REORDER) {
+				Log.v(TAG, "WP is null. Nothing to move to top");
+			}
+			return;
+		} else if(wp.isCornerstone()) {
+			//Don't bring the cornerstone itself to the top
+			if(DEBUG_REORDER) {
+				Log.v(TAG, "WP is Cornerstone. Do not move to the top.");
+			}
+			return;
+		} else {
+			//Don't act if WP is already at the top. Shouldn't happen ever, as there
+			//is a test for this in ViewRootImpl before this method is triggered.
+
+			//Find topmost appwindow token
+			int topMostGroupId = -1;
+			for(int i=mWindows.size()-1; i>=0; i--) {
+				WindowState win = mWindows.get(i);
+				if(win.mAppToken!=null) {
+					topMostGroupId = win.mAppToken.groupId;
+					break;
+				}
+			}
+            /**
+             * Author: Onskreen
+             * Date: 13/07/2011
+             *
+             * Ensures that topmost appwindow token is the requested token to gain the focus.
+             * Previously the implementation was only considering the topmost window in mWindows
+             * list but it wasn't taking in to account that whether the requested app window token
+             * is equivalent to the topMostGroupId variable and hence was not changing the focus.
+             */
+			AppWindowToken appToken = findAppWindowToken(token);
+			int groupId = topMostGroupId;
+			if(appToken != null){
+				groupId = appToken.groupId;
+			}
+			if((wp.contains(topMostGroupId)) && (groupId == topMostGroupId)) {
+				if(DEBUG_REORDER) {
+					Log.v(TAG, "WP is already at top. Nothing to do.");
+				}
+
+               /**
+                * Author: Onskreen
+                * Date: 10/06/2011
+                *
+                * Notifies the CSPanel to update the app header image if the main
+                * panel activity is already on top without changing its z-order.
+                */
+				if(wp.mCornerstonePanelIndex == -1){
+					try {
+						WindowState win = getFocusedWindow();
+						if(win != null) {
+							String pkg = win.mAttrs.packageName;
+							mActivityManager.broadcastCornerstonePanelFocusChanged(pkg, true, -1);
+						}
+					} catch (android.os.RemoteException e){
+						Log.i(TAG, "Remote Exception while notifying to CSPanel: " + e);
+					}
+				}
+					return;
+			}
+		}
+
+        /**
+         * Author: Onskreen
+         * Date: 25/05/2011
+         *
+         * Before transferring the focus to new activity, close any system dialogs (menu,
+         * virtual keyboard etc.) only when there is no dialog on top.
+         */
+         WindowState w = getFocusedWindow();
+         if(w != null){
+           try{
+               if(w != null) {
+                   w.mClient.closeSystemDialogs("menu");
+               }
+           } catch (android.os.RemoteException e) {
+               Slog.i(WindowManagerService.TAG, "Remote Exception while transferring focus: " + e);
+           }
+
+           //Set up so that there is no transition planned and window is moved immediately
+           final long origId = Binder.clearCallingIdentity();
+           prepareAppTransition(WindowManagerPolicy.TRANSIT_UNSET,false);
+
+           //Get all the tokens in the WP to move
+           ArrayList<IBinder> tokensToMove = new ArrayList<IBinder>();
+           tokensToMove = wp.getAllTokens();
+
+           //Moves to the top and also deals with focus/unfocus processing
+           moveAppTokensToTop(tokensToMove);
+           Binder.restoreCallingIdentity(origId);
+
+           //Manually setting focused application. Not clear how this is used by WMS anymore
+           //besides when sending details to the native side input processing. Not using WMS.setFocusedApp
+           //as that has reprucussions of calling update methods that repeat what was just
+           //by the method calls above.
+           mFocusedApp = findAppWindowToken(token);
+
+           if(DEBUG_FOCUS) {
+               Log.v(TAG, "Focus state after moving window frame to the top");
+               Log.v(TAG, "\tmCurrentFocus: " + mCurrentFocus);
+               Log.v(TAG, "\tmLastFocus: " + mLastFocus);
+               Log.v(TAG, "\tmFocusedApp: " + mFocusedApp);
+               Log.v(TAG, "\tmFocusMayChange: " + mFocusMayChange);
+               Log.v(TAG, "\tmLosingFocus: " + mLosingFocus);
+           }
+
+           try {
+               WindowState win = getFocusedWindow();
+               String pkg = win.mAttrs.packageName;
+               mActivityManager.broadcastCornerstonePanelFocusChanged(pkg, true, wp.mCornerstonePanelIndex);
+           } catch (android.os.RemoteException e){
+               Log.i(TAG, "Remote Exception while notifying to CSPanel: " + e);
+           } catch (NullPointerException e) {
+               Log.i(TAG, "Null Pointer Exception while handling focus: " + e);
+           }
+        }
+    }
+
+    /**
+     * Author: Onskreen
+     * Date: 21/02/2011
+     *
+     * Convienence method for AMS to be able to trigger a focus change.
+     */
+     public void handleFocusChange(IBinder token) {
+        AppWindowToken appToken = findAppWindowToken(token);
+        /**
+         * Author: Onskreen
+         * Date: 30/04/2011
+         *
+         * Safety check for observed failures.
+         */
+        if(appToken == null) {
+             Log.w(TAG, "Attempt to call handleFocusChange with broken token:");
+             Log.w(TAG, "\ttoken: " + token);
+             return;
+        }
+
+        WindowState w = appToken.findMainWindow();
+        /**
+         * Author: Onskreen
+         * Date: 23/04/2011
+         *
+         * Safety check for observed failures.
+         */
+        if(w != null && w.mSession != null) {
+            w.mSession.handleFocusChange(token);
+        } else {
+             Log.w(TAG, "Attempt to call handleFocusChange with broken token:");
+             Log.w(TAG, "\ttoken: " + token);
+             Log.w(TAG, "\tappToken: " + appToken);
+             Log.w(TAG, "\tw: " + w);
+             if(w!=null) {
+                 Log.w(TAG, "\tw.mSession: " + w.mSession);
+             }
+        }
+     }
+
+    /**
+     * Author: Onskreen
+     * Date: 12/01/2011
+     *
+     *	Conveinence method to get the rect for a Window Panel
+     *
+     * @return The default rectangle of the window panel
+     */
+    public Rect computeWindowPanelRect(WindowPanel wp, int orientation, Cornerstone_State csState) {
+		Rect rect = null;
+
+		if(wp.isCornerstonePanel() && wp.mCornerstonePanelIndex == 0) {
+			rect = computeWindowPanelRect(WP_Panel.CS_APP_0, orientation, csState);
+		} else if(wp.isCornerstonePanel() && wp.mCornerstonePanelIndex == 1) {
+			rect = computeWindowPanelRect(WP_Panel.CS_APP_1, orientation, csState);
+		} else if(wp.isMainPanel()) {
+			rect = computeWindowPanelRect(WP_Panel.MAIN_PANEL, orientation, csState);
+		} else if(wp.isCornerstone()) {
+			rect = computeWindowPanelRect(WP_Panel.CORNERSTONE, orientation, csState);
+		} else {
+			//ERROR CONDITION
+			rect = new Rect(0, 0, 0, 0);
+		}
+
+		return rect;
+    }
+
+    /**
+     * Author: Onskreen
+     * Date: 12/01/2011
+     *
+     * Calculates the default rendering rectange of the
+     * window panel. for the given orientation and csState
+     *
+     * Some of this logic belongs in the Policy, not here. The confusion it creates is evident by difficulty of dealing with decor.
+     *
+     * TODO Assumes that no decor possible exists at the top of the screen. This could fail in specific layouts and should really
+     * be determined based on the policy.
+     *
+     * @return The default rectangle of the window panel given the orientation
+     */
+    public Rect computeWindowPanelRect(WP_Panel panel, int orientation, Cornerstone_State csState) {
+        /**Now using to calculate in various rotations other than the current, so be sure
+         * to use the appropriate width/height
+         */
+        int fullWidth, fullHeight;
+        if(orientation == Configuration.ORIENTATION_LANDSCAPE ||
+                orientation == Configuration.ORIENTATION_SQUARE ||
+                orientation == Configuration.ORIENTATION_UNDEFINED) {
+            if(mBaseDisplayWidth > mBaseDisplayHeight) {
+                fullWidth = mBaseDisplayWidth;
+                fullHeight = mBaseDisplayHeight;
+            } else {
+                fullWidth = mBaseDisplayHeight;
+                fullHeight = mBaseDisplayWidth;
+            }
+        } else if(orientation == Configuration.ORIENTATION_PORTRAIT) {
+            if(mBaseDisplayWidth < mBaseDisplayHeight) {
+                fullWidth = mBaseDisplayWidth;
+                fullHeight = mBaseDisplayHeight;
+            } else {
+                fullWidth = mBaseDisplayHeight;
+                fullHeight = mBaseDisplayWidth;
+            }
+        } else {
+			fullWidth = mBaseDisplayWidth;
+			fullHeight = mBaseDisplayHeight;
+        }
+        final int displayWidth = mPolicy.getNonDecorDisplayWidth(fullWidth, fullHeight, orientation);
+        final int displayHeight = mPolicy.getNonDecorDisplayHeight(fullWidth, fullHeight, orientation);
+
+        if(DEBUG_WP_CONFIG) {
+            if(orientation == Configuration.ORIENTATION_LANDSCAPE)
+                Log.w(TAG, "Compute Rect. Panel: " + panel + " for orientation: " + orientation + "[LANDSCAPE]");
+            else if(orientation == Configuration.ORIENTATION_PORTRAIT)
+                Log.w(TAG, "Compute Rect. Panel: " + panel + " for orientation: " + orientation + "[PORTRAIT]");
+            else if(orientation == Configuration.ORIENTATION_UNDEFINED)
+                Log.w(TAG, "Compute Rect. Panel: " + panel + " for orientation: " + orientation + "[UNDEFINED]");
+            else if(orientation == Configuration.ORIENTATION_SQUARE)
+                Log.w(TAG, "Compute Rect. Panel: " + panel + " for orientation: " + orientation + "[SQUARE]");
+            if(mCurConfiguration.orientation == Configuration.ORIENTATION_LANDSCAPE)
+                Log.w(TAG, "\tDevice Actual Orientation: LANDSCAPE");
+            else if(orientation == Configuration.ORIENTATION_PORTRAIT)
+                Log.w(TAG, "\tDevice Actual Orientation: PORTRAIT");
+            else if(orientation == Configuration.ORIENTATION_UNDEFINED)
+                Log.w(TAG, "\tDevice Actual Orientation: UNDEFINED");
+            else if(orientation == Configuration.ORIENTATION_SQUARE)
+                Log.w(TAG, "Device Actual Orientation: SQUARE");
+			Log.w(TAG, "\tActual Cornerstone State: " + mCornerstoneState + " Requested CS State: " + csState);
+        }
+
+		Rect emptyRect = new Rect(0, 0, 0, 0);
+		Rect fullDisplayRect = new Rect(0,0,displayWidth,displayHeight);
+		//during startup the display may not yet be configured
+		if(mDisplay == null) {
+			return emptyRect;
+		}
+
+		//If the state is TERMINATED, return the full display
+		if(mCornerstoneState == Cornerstone_State.TERMINATED) {
+			if(panel == WP_Panel.MAIN_PANEL) {
+				if(DEBUG_WP_CONFIG) Log.w(TAG, "\tCase: TERMINATED\tPanel: Main\tReturning: " + fullDisplayRect);
+				return fullDisplayRect;
+			} else {
+                /**
+                 * Author: Onskreen
+                 * Date: 05/01/2012
+                 *
+                 * Returns the empty rect starting from screen width and height
+                 * when Cornerstone is terminating or exiting. This resolves
+                 * the weird exit animation/visual bug we found when user
+                 * terminates cornerstone.
+                 */
+				if(orientation == Configuration.ORIENTATION_LANDSCAPE ||
+						orientation == Configuration.ORIENTATION_UNDEFINED){
+					emptyRect = new Rect(displayWidth, displayHeight, displayWidth, displayHeight);
+				} else if(orientation == Configuration.ORIENTATION_PORTRAIT) {
+					emptyRect = new Rect(displayHeight, displayWidth, displayHeight, displayWidth);
+				}
+				if(DEBUG_WP_CONFIG) Log.w(TAG, "\tCase: TERMINATED\tPanel:" + panel +"\tReturning: " + emptyRect);
+				return emptyRect;
+			}
+		}
+
+		//While getting initialized just be safe and return an empty rect
+		Rect finalRect = emptyRect;
+		if(panel == WP_Panel.MAIN_PANEL) {
+            int mainPanelWidth = 0;
+            int mainPanelHeight = 0;
+			if(orientation == Configuration.ORIENTATION_LANDSCAPE ||
+						orientation == Configuration.ORIENTATION_UNDEFINED){
+				mainPanelHeight = displayHeight;
+                switch(csState) {
+                    case RUNNING_OPEN:
+                        mainPanelWidth = displayWidth - (mCornerstonePanelLandscapeWidth + mCornerstoneHandlerLandscapeWidth);
+                        break;
+                    case RUNNING_CLOSED:
+                        mainPanelWidth = displayWidth - (mCornerstoneHandlerLandscapeWidth);
+                        break;
+                }
+                finalRect = new Rect(0, 0, mainPanelWidth, mainPanelHeight);
+            } else if(orientation == Configuration.ORIENTATION_PORTRAIT){
+                mainPanelWidth = displayWidth;
+                switch(csState) {
+                    case RUNNING_OPEN:
+                        /**
+                         * Author: Onskreen
+                         * Date: 09/06/2011
+                         *
+                         * Removed the mCornerstonePanelPortraitGutter variable while calculating
+                         * the height of the main panel when activity is in portrait mode to prevent
+                         * showing the visible gap between main panel and cornerstone panel handler.
+                         */
+                        mainPanelHeight = displayHeight - (mCornerstonePanelPortraitHeight + mCornerstoneHandlerPortraitWidth + mCornerstoneAppHeaderPortraitHeight);
+                        break;
+                    case RUNNING_CLOSED:
+                        mainPanelHeight = displayHeight - (mCornerstoneHandlerPortraitWidth);
+                        break;
+                }
+                finalRect = new Rect(0, 0, mainPanelWidth, mainPanelHeight);
+            }
+			if(DEBUG_WP_CONFIG) Log.w(TAG, "\tReturning: " + finalRect);
+			return finalRect;
+		} else if(panel == WP_Panel.CORNERSTONE) {
+            int csStartWidth = 0;
+            int csEndWidth = 0;
+            int csStartHeight  = 0;
+            int csEndHeight = 0;
+			if(orientation == Configuration.ORIENTATION_LANDSCAPE ||
+							orientation == Configuration.ORIENTATION_UNDEFINED){
+				csStartHeight = 0;
+				csEndHeight = displayHeight;
+				switch(csState) {
+					case RUNNING_OPEN:
+						csStartWidth = displayWidth - (mCornerstonePanelLandscapeWidth + mCornerstoneHandlerLandscapeWidth);
+						csEndWidth = displayWidth;
+						break;
+					case RUNNING_CLOSED:
+						csStartWidth = displayWidth - (mCornerstoneHandlerLandscapeWidth);
+						csEndWidth = displayWidth + mCornerstonePanelLandscapeWidth;
+						break;
+				}
+                finalRect = new Rect(csStartWidth, csStartHeight, csEndWidth, csEndHeight);
+			} else if(orientation == Configuration.ORIENTATION_PORTRAIT){
+				csStartWidth = 0;
+				csEndWidth = displayWidth;
+				switch(csState) {
+					case RUNNING_OPEN:
+						csStartHeight = displayHeight - (mCornerstonePanelPortraitHeight + mCornerstoneAppHeaderPortraitHeight + mCornerstoneHandlerPortraitWidth);
+						csEndHeight = displayHeight;
+						break;
+					case RUNNING_CLOSED:
+						csStartHeight = displayHeight - (mCornerstoneHandlerPortraitWidth);
+						csEndHeight = displayHeight + (mCornerstonePanelPortraitHeight + mCornerstoneAppHeaderPortraitHeight);
+						break;
+				}
+                finalRect = new Rect(csStartWidth, csStartHeight, csEndWidth, csEndHeight);
+			}
+			if(DEBUG_WP_CONFIG) Log.w(TAG, "\tReturning: " + finalRect);
+            return finalRect;
+		} else if(panel == WP_Panel.CS_APP_0 || panel == WP_Panel.CS_APP_1) {
+            int index = 0;
+            if(panel == WP_Panel.CS_APP_0) {
+                index = 0;
+            } else if(panel == WP_Panel.CS_APP_1) {
+                index = 1;
+            }
+            int panelStartWidth = 0;
+            int panelEndWidth = 0;
+            int panelStartHeight = 0;
+            int panelEndHeight = 0;
+            if(orientation == Configuration.ORIENTATION_LANDSCAPE ||
+                    orientation == Configuration.ORIENTATION_UNDEFINED){
+                if(DEBUG_WP_CONFIG) {
+                    Log.w(TAG, "\tConfirmed: Orientation: landscape or undefined");
+                }
+                panelStartHeight = (index * (mCornerstonePanelLandscapeHeight)) + ((index + 1) * mCornerstoneAppHeaderLandscapeHeight);
+                panelEndHeight = panelStartHeight + mCornerstonePanelLandscapeHeight;
+                switch(csState) {
+                    case RUNNING_OPEN:
+                        panelStartWidth = displayWidth - (mCornerstonePanelLandscapeWidth);
+                        panelEndWidth = displayWidth;
+                        break;
+                    case RUNNING_CLOSED:
+                        panelStartWidth = displayWidth;
+                        panelEndWidth = displayWidth + mCornerstonePanelLandscapeWidth;
+                        break;
+                }
+                finalRect = new Rect(panelStartWidth, panelStartHeight, panelEndWidth, panelEndHeight);
+            } else if(orientation == Configuration.ORIENTATION_PORTRAIT){
+                panelStartWidth = (index * (displayWidth - mCornerstonePanelPortraitWidth));
+                panelEndWidth = ((index + 1) * mCornerstonePanelPortraitWidth) + (index * mCornerstonePanelPortraitGutter);
+                switch(csState) {
+                    case RUNNING_OPEN:
+                        panelStartHeight = displayHeight - mCornerstonePanelPortraitHeight;
+                        panelEndHeight = displayHeight;
+                        break;
+                    case RUNNING_CLOSED:
+                        panelStartHeight = displayHeight + mCornerstoneAppHeaderPortraitHeight;
+                        panelEndHeight = displayHeight + (mCornerstoneAppHeaderPortraitHeight + mCornerstonePanelPortraitHeight);
+                        break;
+                }
+                finalRect = new Rect(panelStartWidth, panelStartHeight, panelEndWidth, panelEndHeight);
+            }
+            if(DEBUG_WP_CONFIG) Log.w(TAG, "\tReturning: " + finalRect);
+            return finalRect;
+		}
+
+		if(DEBUG_WP_CONFIG) Log.w(TAG, "\tCASE: Unknown\tReturning: " + emptyRect);
+		return emptyRect;
+
+    }
+
+    /**
+     * Author: Onskreen
+     * Date: 12/01/2011
+     *
+     * Sets the frames of the WindowPanel (and associated WindowStates) according to type
+     * of apps (main or side panel).
+     */
+     public void setWindowPanel(int groupId) {
+		WindowPanel  currWP = findWindowPanel(groupId);
+		Rect rect = new Rect();
+		if(currWP != null) {
+			//If the wp hasn't been initialized it is new and must be setup
+			if(!currWP.mPosInitatlized) {
+                /**
+                 * Author: Onskreen
+                 * Date: 14/04/2011
+                 *
+                 * It may happen that user boots the device in portrait mode and
+                 * cornerstone must be laid out to the correct location on screen.
+                 */
+				rect = computeWindowPanelRect(currWP, mCurConfiguration.orientation, mCornerstoneState);
+				//Set the Window Panel
+				currWP.setFrame(rect);
+			}
+		}
+     }
+
+    /**
+     * Author: Onskreen
+     * Date: 04/03/2011
+     *
+     * Swap the specified main panel tokens with the cornerstone panel identified by the panelIndex
+     *
+     * - Move the tokens from the WP they are in and place where they should be. At the same time
+     * reorder the z-order so that all the tokens of the same WP are adjacent and are in the z-order
+     * as we want them before moving them around the screen.
+     * - Move and resize the tokens appropriately.
+     */
+    public void executePanelSwap(int panelIndex,
+            List<IBinder> mainPanelTokensToMove,
+            List<IBinder> csPanelTokensToMove,
+            boolean moveCSPanelTokens) {
+
+        /**
+         * Author: Onskreen
+         * Date: 07/06/2011
+         *
+         * The performLayoutAndPlaceSurfacesLocked method call must be triggered
+         * inside the synchronized block to prevent from any thread synchronization
+         * issue resulting in screen getting not refreshed.
+         */
+        synchronized(mWindowMap) {
+			//Locate the window panels to move from and to.
+			WindowPanel csPanelWP = null;
+			WindowPanel mainPanelWP = null;
+			for(int i=0; i<mWindowPanels.size(); i++) {
+				WindowPanel wp = mWindowPanels.get(i);
+				if(wp.isMainPanel()) {
+					mainPanelWP = wp;
+				} else if(wp.isCornerstonePanel() && wp.mCornerstonePanelIndex == panelIndex) {
+					csPanelWP = wp;
+				}
+			}
+
+			if(mainPanelWP == null) {
+				if(DEBUG_CORNERSTONE) {
+					Log.w(TAG, "Can't find main panel wp when trying to switch panels of cornerstone window panel!");
+				}
+				return;
+			}
+			if(csPanelWP == null) {
+				if(DEBUG_CORNERSTONE) {
+					Log.w(TAG, "Can't find cs panel wp for index: " + panelIndex + " when trying to switch panels of cornerstone window panel!");
+				}
+				return;
+			}
+
+			//Keep track of group ids that are moved for use later
+			ArrayList<Integer> mainPanelGroupsMoved = new ArrayList<Integer>();
+			ArrayList<Integer> csPanelGroupsMoved = new ArrayList<Integer>();
+
+			//Make sure the Window Z-Order is what we want before completing the visual move
+			csPanelWP.moveWindowPanelToFront();
+			if(!mainPanelTokensToMove.isEmpty()) {
+                /**
+                 * The value of this is set explictitly instead of using prepareAppTransition()
+                 * because when this is being used during panel swapping the flag doesn't get
+                 * set the way we want it to, to force the windows to be moved immediately.
+                 */
+				mNextAppTransition = WindowManagerPolicy.TRANSIT_UNSET;
+				moveAppTokensToTop(mainPanelTokensToMove);
+
+				//Combine the window panel containing the tokens to move with the main
+				//panel window panel.
+				for(int i=0; i<mAppTokens.size(); i++) {
+					AppWindowToken appToken = mAppTokens.get(i);
+					for(int k=0; k<mainPanelTokensToMove.size(); k++) {
+						Object o = mainPanelTokensToMove.get(k);
+						if(o == appToken.token) {
+							csPanelWP.addGroupId(appToken.groupId);
+							mainPanelWP.removeGroupId(appToken.groupId);
+							mainPanelGroupsMoved.add(appToken.groupId);
+							break;
+						}
+					}
+				}
+			}
+
+			mainPanelWP.moveWindowPanelToFront();
+			//Ensure Tokens (Z-Order is as expected) This will trigger a PLAPSL() so have to
+			//be sure not to have reset the window's pos that were moved yet
+			if(moveCSPanelTokens) {
+                /**
+                 * The value of this is set explictitly instead of using prepareAppTransition()
+                 * because when this is being used during panel swapping the flag doesn't get
+                 * set the way we want it to, to force the windows to be moved immediately.
+                 */
+				mNextAppTransition = WindowManagerPolicy.TRANSIT_UNSET;
+				moveAppTokensToTop(csPanelTokensToMove);
+
+				//Move the cs panel tokens to the main panel window panel.
+				if(moveCSPanelTokens) {
+					for(int i=0; i<mAppTokens.size(); i++) {
+						AppWindowToken appToken = mAppTokens.get(i);
+						for(int k=0; k<csPanelTokensToMove.size(); k++) {
+							Object o = csPanelTokensToMove.get(k);
+							if(o == appToken.token) {
+								mainPanelWP.addGroupId(appToken.groupId);
+								csPanelWP.removeGroupId(appToken.groupId);
+								csPanelGroupsMoved.add(appToken.groupId);
+								break;
+							}
+						}
+					}
+				} else {
+					if(DEBUG_CORNERSTONE) {
+						Log.w(TAG, "Not moving CS Panel Tokens to main panel.");
+					}
+				}
+			}
+
+			if(DEBUG_CORNERSTONE) {
+				Log.w(TAG, "Window State before swapping panels");
+				logQuickWMSState();
+			}
+
+			WindowState mainWinToBe = null;
+			WindowState csPanelWinToBe = null;
+
+			for(int i=0; i<mWindows.size(); i++) {
+				WindowState win = mWindows.get(i);
+				if(win.mAppToken!=null) {
+					if(mainPanelGroupsMoved.contains(win.mAppToken.groupId))
+						csPanelWinToBe = win;
+					else if(csPanelGroupsMoved.contains(win.mAppToken.groupId))
+						mainWinToBe = win;
+				}
+			}
+
+			int numLayouts = 3;
+
+			int mainWinToBeEndWidth = mainPanelWP.getPos().width();
+			int mainWinToBeEndHeight = mainPanelWP.getPos().height();
+			int mainWinToBeEndPosLeft = mainPanelWP.getPos().left;
+			int mainWinToBeEndPosTop = mainPanelWP.getPos().top;
+
+			int mainWinToBeCurrLeft = csPanelWP.getPos().left;
+			int mainWinToBeCurrTop = csPanelWP.getPos().top;
+			int mainWinToBeCurrWidth = csPanelWP.getPos().width();
+			int mainWinToBeCurrHeight = csPanelWP.getPos().height();
+
+			int mainWinToBeLeftDelta = (mainWinToBeEndPosLeft-mainWinToBeCurrLeft)/numLayouts;
+			int mainWinToBeTopDelta = (mainWinToBeEndPosTop-mainWinToBeCurrTop)/numLayouts;
+			int mainWinToBeWidthDelta =  (mainWinToBeEndWidth-mainWinToBeCurrWidth)/numLayouts;
+			int mainWinToBeHeightDelta = (mainWinToBeEndHeight-mainWinToBeCurrHeight)/numLayouts;
+
+			int csWinToBeEndWidth = csPanelWP.getPos().width();
+			int csWinToBeEndHeight = csPanelWP.getPos().height();
+			int csWinToBeEndPosLeft = csPanelWP.getPos().left;
+			int csWinToBeEndPosTop = csPanelWP.getPos().top;
+
+			int csWinToBeCurrLeft = mainPanelWP.getPos().left;
+			int csWinToBeCurrTop = mainPanelWP.getPos().top;
+			int csWinToBeCurrWidth = mainPanelWP.getPos().width();
+			int csWinToBeCurrHeight = mainPanelWP.getPos().height();
+
+			int csWinToBeLeftDelta = (csWinToBeEndPosLeft-csWinToBeCurrLeft)/numLayouts;
+			int csWinToBeTopDelta = (csWinToBeEndPosTop-csWinToBeCurrTop)/numLayouts;
+			int csWinToBeWidthDelta =  (csWinToBeEndWidth-csWinToBeCurrWidth)/numLayouts;
+			int csWinToBeHeightDelta = (csWinToBeEndHeight-csWinToBeCurrHeight)/numLayouts;
+
+            /**
+             * All the moves minus the very final move. We get the
+             * windows close to their final position and then resize them
+             * so that the resize (which actually lays out after the final move)
+             * happens as quickly as possible.
+             */
+
+            /**
+             * Author: Onskreen
+             * Date: 19/11/2011
+             *
+             * Commented out the below block of code as mainWinToBe and csPanelWinToBe
+             * frames were not updated. So to improve the performance, we're commenting
+             * out the below code.
+             */
+			/*for(int i=0; i<(numLayouts-1); i++) {
+				if(mainWinToBe != null && moveCSPanelTokens) {
+					mainWinToBe.mFrame.set(mainWinToBe.mFrame.left+mainWinToBeLeftDelta,
+						mainWinToBe.mFrame.top+mainWinToBeTopDelta,
+						mainWinToBe.mFrame.right+mainWinToBeLeftDelta,
+						mainWinToBe.mFrame.bottom+mainWinToBeTopDelta);
+				}
+
+				if(csPanelWinToBe != null) {
+					csPanelWinToBe.mFrame.set(csPanelWinToBe.mFrame.left+csWinToBeLeftDelta,
+						csPanelWinToBe.mFrame.top+csWinToBeTopDelta,
+						csPanelWinToBe.mFrame.right+csWinToBeLeftDelta,
+						csPanelWinToBe.mFrame.bottom+csWinToBeTopDelta);
+				}
+
+				mLayoutNeeded=true;
+				performLayoutAndPlaceSurfacesLocked();
+			}*/
+
+            /**
+             * Tried to pause the next call until the previous once completes. Left
+             * in for reference. Issues is that mInLayout is set back to false at
+             * end of PLAPSL(), but there is still processing in the other
+             * WMS.performXXX methods. Perhaps introducing a new flag that doesn't
+             * get flipped until all WMS.performXXX methods are completed?
+             */
+	/*		while(mInLayout) {
+				if(DEBUG_CORNERSTONE){
+					Log.v(TAG, "Waiting for 2nd move before resizing");
+				}
+			}
+	*/
+			//Resize the windows in their intermediate positions
+           /**
+            * Author: Onskreen
+            * Date: 19/11/2011
+            *
+            * Previously we were setting the mFrame size for mainWinToBe and csPanelWinToBe
+            * windows of their own mFrame which was not updating their layout rect size. We
+            * should set the csPanelWinToBe.mFrame to mainWinToBe and mainWinToBe.mFrame to
+            * csPanelWinToBe.
+            */
+			try {
+				if(mainWinToBe != null && moveCSPanelTokens && csPanelWinToBe != null) {
+					mainWinToBe.mClient.resized(csPanelWinToBe.mFrame.width(),
+						csPanelWinToBe.mFrame.height(), csPanelWinToBe.mLastContentInsets,
+						csPanelWinToBe.mLastVisibleInsets, csPanelWinToBe.mWinAnimator.mDrawState == WindowStateAnimator.DRAW_PENDING,
+						csPanelWinToBe.mConfiguration);
+				}
+
+				if(csPanelWinToBe != null && mainWinToBe != null) {
+					csPanelWinToBe.mClient.resized(mainWinToBe.mFrame.width(),
+						mainWinToBe.mFrame.height(), mainWinToBe.mLastContentInsets,
+						mainWinToBe.mLastVisibleInsets, mainWinToBe.mWinAnimator.mDrawState == WindowStateAnimator.DRAW_PENDING,
+						mainWinToBe.mConfiguration);
+				}
+
+				mLayoutNeeded=true;
+				performLayoutAndPlaceSurfacesLocked();
+			} catch (RemoteException e) {
+				e.printStackTrace();
+			}
+
+			//Make the last move to the final position
+			if(mainWinToBe != null && moveCSPanelTokens) {
+				mainWinToBe.mFrame.set(mainWinToBeEndPosLeft,
+					mainWinToBeEndPosTop,
+					mainWinToBeEndPosLeft+mainWinToBeEndWidth,
+					mainWinToBeEndPosTop+mainWinToBeEndHeight);
+			}
+			if(csPanelWinToBe != null) {
+				csPanelWinToBe.mFrame.set(csWinToBeEndPosLeft,
+					csWinToBeEndPosTop,
+					csWinToBeEndPosLeft+csWinToBeEndWidth,
+					csWinToBeEndPosTop+csWinToBeEndHeight);
+			}
+
+			mLayoutNeeded=true;
+			performLayoutAndPlaceSurfacesLocked();
+
+			//Ensure that all windows in the WP have the correct pos
+			mainPanelWP.updateFrames();
+			csPanelWP.updateFrames();
+          }
+		/*
+		//Old way of doing the move that is left for reference.
+		//Update frames of both panels
+		mainPanelWF.updateFrames();
+		csPanelWF.updateFrames();
+
+        /**
+         * For those window panels that were moved, we have to destroy and recreate their
+         * surfaces so that they do not appear as the wrong size when first displayed, and
+         * then have their surface updated by the logic of PLAPSL().
+         *
+		mainPanelWF.resetSurfaces(csPanelGroupsMoved, true);
+		csPanelWF.resetSurfaces(mainPanelGroupsMoved, true);
+		 */
+
+        /**
+         * Leaving this in as reference. The goal was to move and resize
+         * proportinately at each move so that the resize was smooth. Issue is
+         * same as has occurred previously, can't move and resize in one move.
+         * The resizes being called here were not being visually updated
+         * to the screen until all the moves were completed, so didn't
+         * acheive what it was trying to do.
+         */
+/*		for(int i=0; i<numLayouts; i++) {
+
+			if(mInLayout) {
+				if(DEBUG_CORNERSTONE){
+					Log.v(TAG, "Skipping move of panel until last layout is complete");
+				}
+				i--;
+				continue;
+			}
+			mainWinToBe.mFrame.set(mainWinToBe.mFrame.left+mainWinToBeLeftDelta,
+					mainWinToBe.mFrame.top+mainWinToBeTopDelta,
+					mainWinToBe.mFrame.right+mainWinToBeLeftDelta+mainWinToBeWidthDelta,
+					mainWinToBe.mFrame.bottom+mainWinToBeTopDelta+mainWinToBeHeightDelta);
+			mainWinToBe.mSurfaceResized = true;
+
+			csPanelWinToBe.mFrame.set(csPanelWinToBe.mFrame.left+csWinToBeLeftDelta,
+					csPanelWinToBe.mFrame.top+csWinToBeTopDelta,
+					csPanelWinToBe.mFrame.right+csWinToBeLeftDelta+csWinToBeWidthDelta,
+					csPanelWinToBe.mFrame.bottom+csWinToBeTopDelta+csWinToBeHeightDelta);
+			csPanelWinToBe.mSurfaceResized = true;
+
+			mLayoutNeeded=true;
+			performLayoutAndPlaceSurfacesLocked();
+
+/*			try {
+				mainWinToBe.mClient.resized(mainWinToBe.mFrame.width(),
+						mainWinToBe.mFrame.height(), mainWinToBe.mLastContentInsets,
+						mainWinToBe.mLastVisibleInsets, mainWinToBe.mWinAnimator.mDrawState == WindowStateAnimator.DRAW_PENDING,
+						mainWinToBe.mConfiguration);
+
+				csPanelWinToBe.mClient.resized(csPanelWinToBe.mFrame.width(),
+						csPanelWinToBe.mFrame.height(), csPanelWinToBe.mLastContentInsets,
+						csPanelWinToBe.mLastVisibleInsets, csPanelWinToBe.mWinAnimator.mDrawState == WindowStateAnimator.DRAW_PENDING,
+						csPanelWinToBe.mConfiguration);
+
+				mLayoutNeeded=true;
+				performLayoutAndPlaceSurfacesLocked();
+			} catch (RemoteException e) {
+				e.printStackTrace();
+			}
+		}
+*/
+	}
+
+    /**
+     * Author: Onskreen
+     * Date: 24/01/2011
+     *
+     * Utility method to find the WindowPanel which contains the given group id
+     */
+    public WindowPanel findWindowPanel(int groupId) {
+        for (int i = 0; i < mWindowPanels.size(); i++) {
+            WindowPanel wp = mWindowPanels.get(i);
+            // Found the Window Panel containing this token's group
+            if (wp.contains(groupId)) {
+                return wp;
+            }
+        }
+        // whoops, no wp contains this groupid
+        return null;
+    }
+
+    /**
+     * Author: Onskreen
+     * Date: 24/01/2011
+     *
+     * Utility method to find the WindowPanel which contains the given token
+     */
+    public WindowPanel findWindowPanel(IBinder token) {
+        for (int i = 0; i < mWindowPanels.size(); i++) {
+            WindowPanel wp = mWindowPanels.get(i);
+
+            // Found the Window Panel containing this token's group
+            if (wp.contains(token)) {
+                return wp;
+            }
+        }
+        // whoops, no wp contains this groupid
+        return null;
+    }
+
     private WindowState findWindow(int hashCode) {
         if (hashCode == -1) {
             return getFocusedWindow();
@@ -6872,7 +9793,7 @@ public class WindowManagerService extends IWindowManager.Stub
         return false;
     }
 
-    private WindowState getFocusedWindow() {
+    public WindowState getFocusedWindow() {
         synchronized (mWindowMap) {
             return getFocusedWindowLocked();
         }
@@ -6979,6 +9900,596 @@ public class WindowManagerService extends IWindowManager.Stub
         }
     }
 
+    /**
+     * Author: Onskreen
+     * Date: 24/01/2011
+     *
+     * Window Panel Structure
+     */
+    final class WindowPanel {
+        // List of AppWindowTokens that are included in this Window Panel.
+        // Keying off of group id
+        ArrayList<Integer> mGroupIds = new ArrayList<Integer>();
+
+        // Rectangle of the Window Panel
+        Rect mWPPos = new Rect();
+
+        // Has the rectangle position been initalized
+        boolean mPosInitatlized = false;
+
+        //Is the window panel in the main panel.
+        boolean mMainPanel = true;
+
+        //Is the window panel a panel in the cornerstone. THe cornerstone itself is not considered
+        //to be a panel
+        boolean mCornerstonePanel = false;
+
+        //If the window panel is a cornerstone panel, what is it's index. -1 indicates no value
+        int mCornerstonePanelIndex = -1;
+
+        //Short name to easily identify contents of wp
+        String name;
+
+        //Configuration for this specific Window Panel
+		Configuration mWPConfig;
+
+		WindowPanel() {
+		}
+
+		/**Window Panel Queries**/
+		public boolean isInitalized() {
+		    return mPosInitatlized;
+		}
+
+        public boolean isWindowPanelEmpty() {
+            return mGroupIds.isEmpty();
+        }
+
+        public boolean contains(int groupId) {
+            return mGroupIds.contains(new Integer(groupId));
+        }
+
+        public boolean contains(IBinder binder) {
+			AppWindowToken appToken = findAppWindowToken(binder);
+			if(appToken == null) {
+				return false;
+			}
+			return contains(appToken.groupId);
+        }
+
+        public boolean isMainPanel() {
+            return mMainPanel;
+		}
+
+		public boolean isCornerstone() {
+			if(!mMainPanel && !mCornerstonePanel) {
+				return true;
+			} else {
+				return false;
+			}
+		}
+
+		public boolean isCornerstonePanel() {
+			if(!mMainPanel && mCornerstonePanel) {
+				return true;
+			} else {
+				return false;
+			}
+		}
+
+		/**Tokens**/
+        /**
+         * Author: Onskreen
+         * Date: 11/02/2011
+         *
+         * Get all the Tokens (IBinder) included in this Window Panel
+         */
+        public ArrayList<IBinder> getAllTokens() {
+            ArrayList<IBinder> tokenList = new ArrayList<IBinder>();
+            for (int i = 0; i < mAppTokens.size(); i++) {
+                AppWindowToken appToken = mAppTokens.get(i);
+                if (contains(appToken.groupId)) {
+                    tokenList.add(appToken.token);
+                }
+            }
+            return tokenList;
+        }
+
+        /**
+         * Author: Onskreen
+         * Date: 25/02/2011
+         *
+         * Get the visible (topmost) token in this Window Panel. Relies on the proper z-order
+         * of WMS.mAppTokens.
+         */
+        public AppWindowToken getVisibleToken() {
+			ArrayList<IBinder> tokenList = getAllTokens();
+			for(int i=mAppTokens.size()-1; i>=0; i--) {
+				AppWindowToken token = mAppTokens.get(i);
+				if(tokenList.contains(token.token)) {
+					return token;
+				}
+			}
+			return null;
+        }
+
+		/**Frame Manipulation**/
+        public void setFrame(Rect newPos) {
+            if (DEBUG_WP_POSITIONS) {
+                Log.v(TAG, "Setting WP: " + this + " to " + newPos);
+                RuntimeException here = new RuntimeException("here");
+                here.fillInStackTrace();
+                Log.v(TAG, "Setting WP Frame", here);
+            }
+            mWPPos.set(newPos);
+            if (!mPosInitatlized) {
+                mPosInitatlized = true;
+            }
+            //update the frames of all associated windowstates
+            updateFrames();
+        }
+
+        /**
+         * Author: Onskreen
+         * Date: 21/02/2011
+         *
+         * Move the Window Panel on the visible display.
+         *
+         * @param xOffset x Offset to move the Window Panel
+         * @param yOffset y offset to move the Window Panel
+         */
+        public void move(int xOffset, int yOffset) {
+            mWPPos.offset(xOffset, yOffset);
+            //update the frames of all associated windowstates
+            updateFrames();
+        }
+
+        /**
+         * Author: Onskreen
+         * Date: 21/02/2011
+         *
+         * Resize the Window Panel on the visible display. Offsets are
+         * applied from the bottom right corner of the window panel.
+         *
+         * @param xOffset x Offset to resize the Window Panel
+         * @param yOffset y offset to resize the Window Panel
+         * @return Whether the resize was completed or not
+         */
+        public boolean resize(int xOffset, int yOffset) {
+            if (DEBUG_WP_POSITIONS) Log.v(TAG, "Resize - x offset: " + xOffset + " y offset: " + yOffset);
+            mWPPos.right += xOffset;
+            mWPPos.bottom += yOffset;
+
+            //Mark all the surfaces in the wp as resized
+            //resetSurfaces(mGroupIds, false);
+            //Update the rect values of all the frames
+            updateFrames();
+
+            return true;
+        }
+
+        /**
+         * Author: Onskreen
+         * Date: 25/01/2011
+         *
+         * Update all WindowStates that are
+         * associated with this Window Panel.
+         */
+        public void updateFrames() {
+			boolean updateFrame = false;
+            for (int i = 0; i < mAppTokens.size(); i++) {
+                AppWindowToken appToken = mAppTokens.get(i);
+                if (contains(appToken.groupId)) {
+                    int N = appToken.allAppWindows.size();
+                    for (int k = 0; k < N; k++) {
+                        WindowState win = appToken.allAppWindows.get(k);
+						WindowManager.LayoutParams attrs = win.mAttrs;
+						final int fl = attrs.flags;
+                        /**
+                         * Author: Onskreen
+                         * Date: 23/02/2012
+                         *
+                         * Determines when to allow TYPE_APPLICATION window to update
+                         * its mFrame from mWPPos rect.
+                         */
+						if(isMainPanel()) {
+							Cornerstone_State csState;
+							if(mCornerstoneStateChangeProcessing) {
+								if(mCornerstoneState == Cornerstone_State.RUNNING_CLOSED)
+									csState = Cornerstone_State.RUNNING_OPEN;
+								else
+									csState = Cornerstone_State.RUNNING_CLOSED;
+							} else {
+								csState = mCornerstoneState;
+							}
+
+							if(mCurConfiguration.orientation == Configuration.ORIENTATION_LANDSCAPE) {
+								if(csState == Cornerstone_State.RUNNING_CLOSED) {
+									updateFrame = ((win.mFrame.width() + mCornerstonePanelLandscapeWidth) == mWPPos.width()) || win.mOrientationChanging;
+								} else if(csState == Cornerstone_State.RUNNING_OPEN) {
+									updateFrame = ((win.mFrame.width() - mCornerstonePanelLandscapeWidth) == mWPPos.width()) || win.mOrientationChanging;
+								}
+							} else if(mCurConfiguration.orientation == Configuration.ORIENTATION_PORTRAIT) {
+								if(csState == Cornerstone_State.RUNNING_CLOSED) {
+									updateFrame = ((win.mFrame.height() + mCornerstonePanelPortraitHeight + mCornerstoneAppHeaderPortraitHeight) == mWPPos.height()) || win.mOrientationChanging;
+								} else if(csState == Cornerstone_State.RUNNING_OPEN) {
+									updateFrame = ((win.mFrame.height() - mCornerstonePanelPortraitHeight - mCornerstoneAppHeaderPortraitHeight) == mWPPos.height()) || win.mOrientationChanging;
+								}
+							}
+						} else if (isCornerstonePanel()) {
+							updateFrame = false;
+						}
+
+                        /**
+                         * Author: Onskreen
+                         * Date: 20/01/2012
+                         *
+                         * The PWM.layoutWindowLw method considers the window of type
+                         * WindowManager.LayoutParams.TYPE_APPLICATION as a normal window
+                         * and sets the rect as the full screen or app's display. If we reset
+                         * the layout rect or mFrame of such window via WindowPanel.updateFrames,
+                         * then we have observed the jumping effect of such window moving from
+                         * cs panel to main panel and finally centrally aligned. Hence, we should
+                         * skip resetting WindowState.mFrame of such windows.
+                         */
+						if((attrs.type == WindowManager.LayoutParams.TYPE_APPLICATION) && !updateFrame) {
+							if (DEBUG_WP_POSITIONS)
+								Log.v(TAG, "Skip resetting mFrame for:" + win + " of type: WindowManager.LayoutParams.TYPE_APPLICATION");
+							continue;
+                        /**
+                         * Author: Onskreen
+                         * Date: 21/02/2012
+                         *
+                         * The below condition is written to identify the window
+                         * of type TYPE_BASE_APPLICATION and which looks like a
+                         * dialog window despite having valid AppWindowToken,
+                         * WindowState and the entry in to WIndowPanel class.
+                         * ResolverActivity is such kind of window. This is a
+                         * special case where we don't want to update its mFrame
+                         * as other windows. If we update its mFrame with Window
+                         * Panel's rect, then user's input area becomes larger
+                         * than such window's rendering area resulting in producing
+                         * incorrect user input. To prevent this bad user experience,
+                         * we just skip updating mFrame of such windows.
+                         */
+						} else if(attrs.type == TYPE_BASE_APPLICATION &&
+								((fl & (FLAG_LAYOUT_IN_SCREEN | FLAG_FULLSCREEN | FLAG_LAYOUT_INSET_DECOR))
+								!= (FLAG_LAYOUT_IN_SCREEN | FLAG_LAYOUT_INSET_DECOR))
+							&& ((fl & FLAG_LAYOUT_IN_SCREEN) == 0)
+							&& (win.mAttachedWindow == null)
+							&& ((fl & FLAG_LAYOUT_NO_LIMITS) == 0)) {
+							  //normal window and returns the original mFrame value.
+							if (DEBUG_WP_POSITIONS)
+								Log.v(TAG, "Skip resetting mFrame for:" + win + " of type: WindowManager.LayoutParams.TYPE_BASE_APPLICATION");
+							continue;
+
+                        /**
+                         * Author: Onskreen
+                         * Date: 04/01/2013
+                         *
+                         * If Window is visible, focused and obstructed by keyboard, then
+                         * PhoneWindowManager class has already shifted the Window to appropriate
+                         * visible location on screen above the keyboard. Don't reset its layout
+                         * rect with the generic layout rect of overall WindowPanel.
+                         */
+						} else if(win.isObstructedByKeyboard() && win.isFocused() && win.isVisibleLw()) {
+							if (DEBUG_WP_POSITIONS)
+								Log.v(TAG, "Skip resetting mFrame for:" + win + " which is currently focused, visible and obstructed by keyboard.");
+							continue;
+
+                        /**
+                         * Author: Onskreen
+                         * Date: 01/02/2013
+                         *
+                         * If Window is of type LayoutParams.TYPE_APPLICATION_PANEL, then
+                         * framework sets the mFrame of such window which looks like dropdown
+                         * window in case of Browser app (when user types something in
+                         * search/address bar). Don't reset its layout rect with the generic
+                         * layout rect of overall WindowPanel.
+						 */
+						} else if(attrs.type == TYPE_APPLICATION_PANEL && !updateFrame) {
+							if (DEBUG_WP_POSITIONS)
+								Log.v(TAG, "Skip resetting mFrame for:" + win + " of type: WindowManager.LayoutParams.TYPE_APPLICATION_PANEL");
+							continue;
+						}
+
+                        if (DEBUG_WP_POSITIONS) {
+							if(attrs.type == WindowManager.LayoutParams.TYPE_APPLICATION_ATTACHED_DIALOG) {
+								Log.v(TAG, "Window Type: " + "WindowManager.LayoutParams.TYPE_APPLICATION_ATTACHED_DIALOG");
+							} else if(attrs.type == WindowManager.LayoutParams.TYPE_APPLICATION_MEDIA) {
+								Log.v(TAG, "Window Type: " + "WindowManager.LayoutParams.TYPE_APPLICATION_MEDIA");
+							} else if(attrs.type == WindowManager.LayoutParams.TYPE_APPLICATION_MEDIA_OVERLAY) {
+								Log.v(TAG, "Window Type: " + "WindowManager.LayoutParams.TYPE_APPLICATION_MEDIA_OVERLAY");
+							} else if(attrs.type == WindowManager.LayoutParams.TYPE_APPLICATION_PANEL) {
+								Log.v(TAG, "Window Type: " + "WindowManager.LayoutParams.TYPE_APPLICATION_PANEL");
+							} else if(attrs.type == WindowManager.LayoutParams.TYPE_APPLICATION_STARTING) {
+								Log.v(TAG, "Window Type: " + "WindowManager.LayoutParams.TYPE_APPLICATION_STARTING");
+							} else if(attrs.type == WindowManager.LayoutParams.TYPE_APPLICATION_SUB_PANEL) {
+								Log.v(TAG, "Window Type: " + "WindowManager.LayoutParams.TYPE_APPLICATION_SUB_PANEL");
+							} else if(attrs.type == WindowManager.LayoutParams.TYPE_BASE_APPLICATION) {
+								Log.v(TAG, "Window Type: " + "WindowManager.LayoutParams.TYPE_BASE_APPLICATION");
+							} else if(attrs.type == WindowManager.LayoutParams.TYPE_BOOT_PROGRESS) {
+								Log.v(TAG, "Window Type: " + "WindowManager.LayoutParams.TYPE_BOOT_PROGRESS");
+							} else if(attrs.type == WindowManager.LayoutParams.TYPE_CHANGED) {
+								Log.v(TAG, "Window Type: " + "WindowManager.LayoutParams.TYPE_CHANGED");
+							} else if(attrs.type == WindowManager.LayoutParams.TYPE_DRAG) {
+								Log.v(TAG, "Window Type: " + "WindowManager.LayoutParams.TYPE_DRAG");
+							} else if(attrs.type == WindowManager.LayoutParams.TYPE_HIDDEN_NAV_CONSUMER) {
+								Log.v(TAG, "Window Type: " + "WindowManager.LayoutParams.TYPE_HIDDEN_NAV_CONSUMER");
+							} else if(attrs.type == WindowManager.LayoutParams.TYPE_INPUT_METHOD) {
+								Log.v(TAG, "Window Type: " + "WindowManager.LayoutParams.TYPE_INPUT_METHOD");
+							} else if(attrs.type == WindowManager.LayoutParams.TYPE_INPUT_METHOD_DIALOG) {
+								Log.v(TAG, "Window Type: " + "WindowManager.LayoutParams.TYPE_INPUT_METHOD_DIALOG");
+							} else if(attrs.type == WindowManager.LayoutParams.TYPE_KEYGUARD) {
+								Log.v(TAG, "Window Type: " + "WindowManager.LayoutParams.TYPE_KEYGUARD_DIALOG");
+							} else if(attrs.type == WindowManager.LayoutParams.TYPE_KEYGUARD_DIALOG) {
+								Log.v(TAG, "Window Type: " + "WindowManager.LayoutParams.TYPE_KEYGUARD_DIALOG");
+							} else if(attrs.type == WindowManager.LayoutParams.TYPE_NAVIGATION_BAR) {
+								Log.v(TAG, "Window Type: " + "WindowManager.LayoutParams.TYPE_NAVIGATION_BAR");
+							} else if(attrs.type == WindowManager.LayoutParams.TYPE_PHONE) {
+								Log.v(TAG, "Window Type: " + "WindowManager.LayoutParams.TYPE_PHONE");
+							} else if(attrs.type == WindowManager.LayoutParams.TYPE_POINTER) {
+								Log.v(TAG, "Window Type: " + "WindowManager.LayoutParams.TYPE_POINTER");
+							} else if(attrs.type == WindowManager.LayoutParams.TYPE_PRIORITY_PHONE) {
+								Log.v(TAG, "Window Type: " + "WindowManager.LayoutParams.TYPE_PRIORITY_PHONE");
+							} else if(attrs.type == WindowManager.LayoutParams.TYPE_SEARCH_BAR) {
+								Log.v(TAG, "Window Type: " + "WindowManager.LayoutParams.TYPE_SEARCH_BAR");
+							} else if(attrs.type == WindowManager.LayoutParams.TYPE_SECURE_SYSTEM_OVERLAY) {
+								Log.v(TAG, "Window Type: " + "WindowManager.LayoutParams.TYPE_SECURE_SYSTEM_OVERLAY");
+							} else if(attrs.type == WindowManager.LayoutParams.TYPE_STATUS_BAR) {
+								Log.v(TAG, "Window Type: " + "WindowManager.LayoutParams.TYPE_STATUS_BAR");
+							} else if(attrs.type == WindowManager.LayoutParams.TYPE_STATUS_BAR_PANEL) {
+								Log.v(TAG, "Window Type: " + "WindowManager.LayoutParams.TYPE_STATUS_BAR_PANEL");
+							} else if(attrs.type == WindowManager.LayoutParams.TYPE_STATUS_BAR_SUB_PANEL) {
+								Log.v(TAG, "Window Type: " + "WindowManager.LayoutParams.TYPE_STATUS_BAR_SUB_PANEL");
+							} else if(attrs.type == WindowManager.LayoutParams.TYPE_SYSTEM_ALERT) {
+								Log.v(TAG, "Window Type: " + "WindowManager.LayoutParams.TYPE_SYSTEM_ALERT");
+							} else if(attrs.type == WindowManager.LayoutParams.TYPE_SYSTEM_DIALOG) {
+								Log.v(TAG, "Window Type: " + "WindowManager.LayoutParams.TYPE_SYSTEM_DIALOG");
+							} else if(attrs.type == WindowManager.LayoutParams.TYPE_SYSTEM_ERROR) {
+								Log.v(TAG, "Window Type: " + "WindowManager.LayoutParams.TYPE_SYSTEM_ERROR");
+							} else if(attrs.type == WindowManager.LayoutParams.TYPE_SYSTEM_OVERLAY) {
+								Log.v(TAG, "Window Type: " + "WindowManager.LayoutParams.TYPE_SYSTEM_OVERLAY");
+							} else if(attrs.type == WindowManager.LayoutParams.TYPE_TOAST) {
+								Log.v(TAG, "Window Type: " + "WindowManager.LayoutParams.TYPE_TOAST");
+							} else if(attrs.type == WindowManager.LayoutParams.TYPE_VOLUME_OVERLAY) {
+								Log.v(TAG, "Window Type: " + "WindowManager.LayoutParams.TYPE_VOLUME_OVERLAY");
+							} else if(attrs.type == WindowManager.LayoutParams.TYPE_WALLPAPER) {
+								Log.v(TAG, "Window Type: " + "WindowManager.LayoutParams.TYPE_WALLPAPER");
+							}
+                            Log.v(TAG, "Setting window: " + win + " to rect: " + mWPPos);
+						}
+                        win.mFrame.set(mWPPos);
+                    }
+                }
+            }
+            /**
+             * Author: Onskreen
+             * Date : 26/12/2011
+             */
+            //setConfiguration(true);
+        }
+
+        /**
+         * Author: Onskreen
+         * Date: 09/02/2011
+         *
+         * Ensure that all surfaces with the given group id in this window panel are marked as
+         * resized.
+         */
+        private void resetSurfaces(List<Integer> groupIds, boolean destroy) {
+			for(int i=0; i<groupIds.size(); i++) {
+				int currGroupId = groupIds.get(i);
+				for (int n = 0; n < mAppTokens.size(); n++) {
+					AppWindowToken appToken = mAppTokens.get(n);
+					//Only updating surface of groups that were moved.
+					if (appToken.groupId == currGroupId) {
+						int N = appToken.allAppWindows.size();
+						for (int k = 0; k < N; k++) {
+							WindowState win = appToken.allAppWindows.get(k);
+							win.mWinAnimator.mSurfaceResized = true;
+							if(destroy) {
+								win.mWinAnimator.destroySurfaceLocked();
+								win.mWinAnimator.createSurfaceLocked();
+							}
+						}
+						break;
+					}
+				}
+			}
+        }
+
+
+        /**Configuration Methods**/
+        /**
+         * Author: Onskreen
+         * Date : 26/12/2011
+         *
+         * Computes the appropriate Configuration for this WindowPanel. If updateWinConfigs is true
+         * it also ensures that all WindowStates in this Panel have the appropriate configuration set.
+         *
+         * Uses the existing WMS.mCurConfiguration and mCornerstoneState.
+         *
+         * Returns true if the WP config was acutally out of sync and was updated. False otherwise
+         */
+		public boolean updateConfiguration(boolean updateWinConfigs) {
+			Configuration newConfig;
+			if(isCornerstonePanel() && mCornerstonePanelIndex == 0) {
+				newConfig = computeWindowPanelConfiguration(WP_Panel.CS_APP_0);
+			} else if(isCornerstonePanel() && mCornerstonePanelIndex == 1) {
+				newConfig = computeWindowPanelConfiguration(WP_Panel.CS_APP_1);
+			} else if(isMainPanel()) {
+				newConfig = computeWindowPanelConfiguration(WP_Panel.MAIN_PANEL);
+			} else if(isCornerstone()) {
+				newConfig = computeWindowPanelConfiguration(WP_Panel.CORNERSTONE);
+			} else {
+				if(DEBUG_WP_CONFIG) {
+					Slog.e(TAG, "ERROR: Unable to determine panel of WindowPanel" );
+				}
+				newConfig = computeWindowPanelConfiguration(WP_Panel.DISPLAY);
+			}
+
+			//No Changes in Config
+			if(mWPConfig != null && mWPConfig.diff(newConfig) == 0
+					&& !updateWinConfigs) {									//When updating configs of WindowStates do regardless if this config is new tothe WindowPanel
+				return false;
+			} else {
+				mWPConfig = newConfig;
+			}
+
+			if(updateWinConfigs) {
+				for (int i = 0; i < mAppTokens.size(); i++) {
+					AppWindowToken appToken = mAppTokens.get(i);
+					if(contains(appToken.groupId)) {
+						int N = appToken.allAppWindows.size();
+						for (int k = 0; k < N; k++) {
+							WindowState win = appToken.allAppWindows.get(k);
+							win.mConfiguration = new Configuration(mWPConfig);
+						}
+					}
+				}
+			}
+			return true;
+		}
+
+        /**
+         * Author: Onskreen
+         * Date : 26/12/2011
+         *
+         */
+		public Configuration getConfiguration() {
+			return mWPConfig;
+		}
+
+	    /**Utility Methods**/
+		public String getName() {
+			return name;
+		}
+
+		public void setName(String name) {
+			this.name = name;
+		}
+
+        public void addGroupId(int id) {
+            if(!mGroupIds.contains(id)) {
+                mGroupIds.add(new Integer(id));
+                if (DEBUG_WP_GROUPING)
+                    Log.v(TAG, "Adding Group: " + id + " to " + this);
+            }
+        }
+
+        public void removeGroupId(int id) {
+            if (DEBUG_WP_GROUPING)
+                Log.v(TAG, "Removing Group: " + id + " from " + this);
+            mGroupIds.remove(new Integer(id));
+        }
+
+        public Rect getPos() {
+            return mWPPos;
+        }
+
+		public void setInMainPanel(boolean mMainPanel) {
+			this.mMainPanel = mMainPanel;
+		}
+
+		/**Z-Order**/
+        /**
+         * Author: Onskreen
+         * Date: 11/03/2011
+         *
+         * Bring all the tokens of the WindowPanel to the front of the Z-Order. This does not
+         * manage the Focus, that is the caller's responsibility to manage.
+         */
+		public boolean moveWindowPanelToFront() {
+			if(DEBUG_REORDER || DEBUG_CORNERSTONE) {
+				Log.v(TAG, "Moving Window Panel: " + this + " to top of z-order");
+			}
+
+			//Cases that we don't want to take action:
+			if(isCornerstone()) {
+				//Don't bring the cornerstone itself to the top
+				if(DEBUG_REORDER || DEBUG_CORNERSTONE) {
+					Log.v(TAG, "WP is Cornerstone. Do not move to the top.");
+				}
+				return false;
+			}
+
+			//Don't act if WP is already at the top. Shouldn't happen ever, as there
+			//is a test for this in ViewRoot before this method is triggered.
+
+			//Find topmost appwindow token
+			int topMostGroupId = -1;
+			for(int i=mWindows.size()-1; i>=0; i--) {
+				WindowState win = mWindows.get(i);
+				if(win.mAppToken!=null) {
+					topMostGroupId = win.mAppToken.groupId;
+					break;
+				}
+			}
+			if(contains(topMostGroupId)) {
+				if(DEBUG_REORDER || DEBUG_CORNERSTONE) {
+					Log.v(TAG, "WP is already at top. Nothing to do.");
+				}
+				return false;
+			}
+
+            /**
+             * Manually making the transition from within the WMS instead of calling an
+             * AMS method because:
+             * - There is WP specific logic that has be managed (getting all the tokens
+             * in a WP, not just one task/group). So would require a new IActivityManager
+             * method.
+             * - ActivityStack containing this WindowPanel already has the tokens positioned
+             * at the top so triggering the ActivityStack.moveTasktoFrontLocked() wouldn't
+             * actually do anything. So would require additional changes there. So keeping
+             * changes localized here.
+             */
+			//Set up so that there is no transition planned and window is moved immediately
+			final long origId = Binder.clearCallingIdentity();
+
+			//Get all the tokens in the WP to move
+			ArrayList<IBinder> tokensToMove = new ArrayList<IBinder>();
+			tokensToMove = getAllTokens();
+
+            /**
+             * The value of this is set explictitly instead of using prepareAppTransition()
+             * because when this is being used during panel swapping the flag doesn't get
+             * set the way we want it to, to force the windows to be moved immediately.
+             */
+			mNextAppTransition = WindowManagerPolicy.TRANSIT_UNSET;
+			moveAppTokensToTop(tokensToMove);
+			Binder.restoreCallingIdentity(origId);
+			return true;
+		}
+
+		public void setIsCornerstonePanel(boolean isCornerstonePanel) {
+			this.mCornerstonePanel = isCornerstonePanel;
+		}
+
+		public String toString() {
+			StringBuilder sb = new StringBuilder();
+			if(isMainPanel()) {
+				sb.append("Main - ");
+			} else if(isCornerstone()) {
+				sb.append("Cornerstone - ");
+			} else if(isCornerstonePanel()) {
+				sb.append("Cornerstone Panel [Index: " + mCornerstonePanelIndex + "]) - ");
+			}
+			sb.append("Window Panel (" + name + ") [");
+			sb.append(Integer.toHexString(System.identityHashCode(this)));
+			sb.append("] Groups: [");
+			for (int i = 0; i < mGroupIds.size(); i++) {
+				if (i > 0)
+					sb.append(", ");
+				sb.append(mGroupIds.get(i));
+			}
+			sb.append("] at Pos: ");
+			sb.append(mWPPos);
+			sb.append(" Configuration[" + mWPConfig + "]");
+			return sb.toString();
+		}
+	}
+
     // -------------------------------------------------------------
     // Async Handler
     // -------------------------------------------------------------
@@ -7009,6 +10520,14 @@ public class WindowManagerService extends IWindowManager.Stub
         public static final int BULK_UPDATE_PARAMETERS = 25;
         public static final int SHOW_STRICT_MODE_VIOLATION = 26;
         public static final int DO_ANIMATION_CALLBACK = 27;
+        /**
+         * Author: Onskreen
+         * Date: 14/02/2012
+         *
+         * Async handler message for showing hidden dialog windows
+         * when cornerstone is opened by the user.
+         */
+	public static final int SHOW_HIDDEN_DIALOG_WINDOWS = 28;
 
         public static final int ANIMATOR_WHAT_OFFSET = 100000;
         public static final int SET_TRANSPARENT_REGION = ANIMATOR_WHAT_OFFSET + 1;
@@ -7519,6 +11038,18 @@ public class WindowManagerService extends IWindowManager.Stub
                     }
                     break;
                 }
+
+                /**
+                 * Author: Onskreen
+                 * Date: 14/02/2012
+                 *
+                 * Shows hidden dialog window(s) when user opens
+                 * cornerstone after closing it.
+                 */
+				case SHOW_HIDDEN_DIALOG_WINDOWS: {
+					handleCSPanelDialogWindows(mCornerstoneState);
+					break;
+				}
             }
             if (DEBUG_WINDOW_TRACE) {
                 Slog.v(TAG, "handleMessage: exit");
@@ -7860,6 +11391,14 @@ public class WindowManagerService extends IWindowManager.Stub
             Slog.w(TAG, "Final window list:");
             dumpWindowsLocked();
         }
+        /**
+         * Author: Onskreen
+         * Date: 27/01/2011
+         *
+         * Added to inspect window state after rebuild.
+         *
+         */
+        if (DEBUG_WINDOW_MOVEMENT) logWMSState(true, true);
     }
 
     private final void assignLayersLocked() {
@@ -8504,6 +12039,39 @@ public class WindowManagerService extends IWindowManager.Stub
                 w.mConfiguration != mCurConfiguration
                 && (w.mConfiguration == null
                         || mCurConfiguration.diff(w.mConfiguration) != 0);
+
+                        /**
+                         * Author: Onskreen
+                         * Date: 26/12/2011
+                         *
+                         * Do not consider the config changed if the Win is in a window panel unless the orientation is different.
+                         * TODO this could backfire when other non orientation values change. we might need a config compare method
+                         * that compares a WP config and mCurConfiguration exluding the WP specific values?
+                         */
+                        if(w.mAppToken != null &&
+                                (w.mAppToken.isCornerstone ||
+                                w.mAppToken.isInCornerstonePanelWindowPanel() ||
+                                w.mAppToken.isInMainPanelWindowPanel())) {
+                            WindowPanel wp = findWindowPanel(w.mAppToken.token);
+                            //Re-evaluate resetting the config
+                            if(w.mConfiguration == null) {
+                                //Got this far with the WindowPanel not assigning its config.
+                                if(wp!=null) wp.updateConfiguration(false);
+                            }
+
+                            if(w.mConfiguration != null && wp.getConfiguration() != null &&
+                                  w.mConfiguration.orientation==wp.getConfiguration().orientation) {
+                                configChanged = false;
+                                if(DEBUG_WP_CONFIG) {
+                                    //Slog.v(TAG, "Not taking mCurConfiguration because has same orientation " + w);
+                                }
+                            } else {
+                                if(DEBUG_WP_CONFIG) {
+                                    Slog.v(TAG, "Resetting mCurConfiguration because orientation changed " + w);
+                                }
+                            }
+                        }
+
             if (DEBUG_CONFIGURATION && configChanged) {
                 Slog.v(TAG, "Win " + w + " config changed: "
                         + mCurConfiguration);
@@ -8781,6 +12349,16 @@ public class WindowManagerService extends IWindowManager.Stub
 
                 final WindowStateAnimator winAnimator = w.mWinAnimator;
 
+                /**
+                 * Author: Onskreen
+                 * Date: 13/12/2011
+                 *
+                 * Instead of running animation on full screen, animation
+                 * should be played as per the Window's layout rect.
+                 */
+                int animDw = w.mFrame.width();//innerDw;
+                int animDh = w.mFrame.height();//innerDh;
+
                 // If the window has moved due to its containing
                 // content frame changing, then we'd like to animate
                 // it.
@@ -8873,9 +12451,7 @@ public class WindowManagerService extends IWindowManager.Stub
             }
 
             if (updateAllDrawn) {
-            	Trace.traceBegin(Trace.TRACE_TAG_WINDOW_MANAGER, "updateAllDrawn");
                 updateAllDrawnLocked();
-                Trace.traceEnd(Trace.TRACE_TAG_WINDOW_MANAGER);
             }
 
             if (focusDisplayed) {
@@ -8967,6 +12543,101 @@ public class WindowManagerService extends IWindowManager.Stub
                     if (DEBUG_RESIZE || DEBUG_ORIENTATION) Slog.v(TAG,
                             "Reporting new frame to " + win + ": " + win.mCompatFrame);
                     int diff = 0;
+                    /**
+                     * Author: Onskreen
+                     * Date: 26/12/2011
+                     *
+                     * If this config was determined changed above, then it was added to mResizingWindows and is dealt with here.
+                     * It could also have been added if insets changed or surface resized. so the setting of the WindowState.mConfiguration
+                     * has to be safe here and be sure that WindowPanels get the config that is meant for them and not the system
+                     * config.
+                     */
+                    if(mCornerstoneState != Cornerstone_State.TERMINATED	&&										//Only do special layout when Cornerstone is on
+                            win.mAppToken != null &&
+                            (win.mAppToken.isCornerstone ||
+                            win.mAppToken.isInCornerstonePanelWindowPanel() ||
+                            win.mAppToken.isInMainPanelWindowPanel())) {
+                        /**
+                         * Make sure that window had its configuration set by its WindowPanel. It's possible that
+                         * it didn't when added if this is the first Window in the Panel
+                         */
+                        WindowPanel wp = findWindowPanel(win.mAppToken.groupId);
+                        wp.updateConfiguration(false);
+                        boolean configChanged =
+                            win.mConfiguration != wp.getConfiguration()
+                            && (win.mConfiguration == null
+                            || (diff=wp.getConfiguration().diff(win.mConfiguration)) != 0);
+                        /**
+                         * Author: Onskreen
+                         * Date: 26/12/2011
+                         *
+                         * WindowStates within WindowPanels need to be sure their configs as well as frames are updated.
+                         */
+                        //win.mConfiguration = wp.getConfiguration();
+                        if ((DEBUG_RESIZE || DEBUG_ORIENTATION || DEBUG_CONFIGURATION) &&
+                               configChanged) {
+                            Slog.i(TAG, "Sending new config to window panel " + win + ": "
+                                + win.mWinAnimator.mSurfaceW + "x" + win.mWinAnimator.mSurfaceH
+                                //+ wp.getPos().width() + "x" + wp.getPos().height()
+                                + " / " + wp.getConfiguration() + " / 0x"
+                                + Integer.toHexString(diff));
+                        }
+
+                        wp.updateConfiguration(true);
+                        /**
+                         * The cs state change animation might be complete, but if we are still in the process
+                         * of a state change be sure to set the rect to the desired state
+                         */
+                        Cornerstone_State csState;
+						if(mCornerstoneStateChangeProcessing) {
+							if(mCornerstoneState == Cornerstone_State.RUNNING_CLOSED)
+								csState = Cornerstone_State.RUNNING_OPEN;
+							else
+								csState = Cornerstone_State.RUNNING_CLOSED;
+						} else {
+							csState = mCornerstoneState;
+						}
+
+						Rect rect = computeWindowPanelRect(wp, wp.getConfiguration().orientation, csState);
+						if(DEBUG_CORNERSTONE) {
+							Slog.v(TAG, "WP: " + wp);
+							Slog.v(TAG, "mCornerstoneStateChangeAnimating: " + mCornerstoneStateChangeAnimating);
+							Slog.v(TAG, "mCornerstoneStateChangeProcessing: " + mCornerstoneStateChangeProcessing);
+							Slog.v(TAG, "Using CSState: " + csState);
+							Slog.v(TAG, "win.mFrame " + win.mFrame);
+							Slog.v(TAG, "win.mShownFrame " + win.mShownFrame);
+						}
+
+                        /**
+                         * Author: Onskreen
+                         * Date: 26/12/2011
+                         *
+                         * When the Cornerstone Panel has an app containing a SurfaceView it considers it's surface to
+                         * to be resized during Cornerstone state change animations. To avoid any layout inconsistencies
+                         * we don't reposition the Window Panel mFrame when we are in the midst of a Cornerstone
+                         * state change. An example of this is the Google Maps Application.
+                         */
+						if(!mCornerstoneStateChangeAnimating || !wp.isCornerstonePanel()) {
+							if(DEBUG_CORNERSTONE) {
+								Slog.v(TAG, "Cornerstone not animating or non-Cornerstone WP - Reposition Window Panel Frame");
+							}
+							wp.setFrame(rect);
+						} else {
+							if(DEBUG_CORNERSTONE) {
+								Slog.v(TAG, "Cornerstone animating - Do not reposition Window Panel Frame");
+							}
+						}
+
+						if (DEBUG_ORIENTATION && win.mWinAnimator.mDrawState == WindowStateAnimator.DRAW_PENDING) Slog.i(
+								TAG, "Resizing " + win + " WITH DRAW PENDING");
+						win.mClient.resized((int)win.mWinAnimator.mSurfaceW, (int)win.mWinAnimator.mSurfaceH,
+								win.mLastContentInsets, win.mLastVisibleInsets,
+								win.mWinAnimator.mDrawState == WindowStateAnimator.DRAW_PENDING,
+								configChanged ? wp.getConfiguration() : null);
+						win.mContentInsetsChanged = false;
+						win.mVisibleInsetsChanged = false;
+						win.mWinAnimator.mSurfaceResized = false;
+                    } else {
                     boolean configChanged =
                         win.mConfiguration != mCurConfiguration
                         && (win.mConfiguration == null
@@ -8979,6 +12650,22 @@ public class WindowManagerService extends IWindowManager.Stub
                                 + Integer.toHexString(diff));
                     }
                     win.mConfiguration = mCurConfiguration;
+                    /**
+                     * Author: Onskreen
+                     * Date: 26/12/2011
+                     *
+                     * The main Window Panel is still grouped as must be updated when
+                     * the Cornerstone is terminated. Make sure it is updated in cases
+                     * when we encounter a config change.
+                     */
+                    if(win.mAppToken!=null && win.mAppToken.isInMainPanelWindowPanel()) {
+							WindowPanel wp = findWindowPanel(win.mAppToken.groupId);
+							if(wp!=null) {
+								wp.updateConfiguration(true);
+								Rect rect = computeWindowPanelRect(wp, wp.getConfiguration().orientation, Cornerstone_State.TERMINATED);
+								wp.setFrame(rect);
+							}
+                    }
                     if (DEBUG_ORIENTATION &&
                             winAnimator.mDrawState == WindowStateAnimator.DRAW_PENDING) Slog.i(
                             TAG, "Resizing " + win + " WITH DRAW PENDING");
@@ -8990,6 +12677,34 @@ public class WindowManagerService extends IWindowManager.Stub
                     win.mContentInsetsChanged = false;
                     win.mVisibleInsetsChanged = false;
                     winAnimator.mSurfaceResized = false;
+
+                    /**
+                     * Original Implementation
+                     */
+                    /*boolean configChanged =
+                        win.mConfiguration != mCurConfiguration
+                        && (win.mConfiguration == null
+                                || (diff=mCurConfiguration.diff(win.mConfiguration)) != 0);
+                    if ((DEBUG_RESIZE || DEBUG_ORIENTATION || DEBUG_CONFIGURATION)
+                            && configChanged) {
+                        Slog.i(TAG, "Sending new config to window " + win + ": "
+                                + winAnimator.mSurfaceW + "x" + winAnimator.mSurfaceH
+                                + " / " + mCurConfiguration + " / 0x"
+                                + Integer.toHexString(diff));
+                    }
+                    win.mConfiguration = mCurConfiguration;
+                    if (DEBUG_ORIENTATION &&
+                            winAnimator.mDrawState == WindowStateAnimator.DRAW_PENDING) Slog.i(
+                            TAG, "Resizing " + win + " WITH DRAW PENDING");
+                    win.mClient.resized((int)winAnimator.mSurfaceW,
+                            (int)winAnimator.mSurfaceH,
+                            win.mLastContentInsets, win.mLastVisibleInsets,
+                            winAnimator.mDrawState == WindowStateAnimator.DRAW_PENDING,
+                            configChanged ? win.mConfiguration : null);
+                    win.mContentInsetsChanged = false;
+                    win.mVisibleInsetsChanged = false;
+                    winAnimator.mSurfaceResized = false;*/
+                    }
                 } catch (RemoteException e) {
                     win.mOrientationChanging = false;
                 }
@@ -9051,6 +12766,46 @@ public class WindowManagerService extends IWindowManager.Stub
                         "performLayout: App token exiting now removed" + token);
                 mAppTokens.remove(token);
                 mAnimatingAppTokens.remove(token);
+
+                /**
+                 * Author: Onskreen
+                 * Date: 24/01/2011
+                 *
+                 * When the AppWindowToken is removed,
+                 * it's reference from it's WindowPanel must be wiped
+                 * also if there are no remaining AppWindowTokens with the same
+                 * group. At this point the Windows associated with this
+                 * AppWindowTOken should have already been removed.
+                 */
+                boolean doTokensWithIdStillExist = false;
+                if (DEBUG_WP_GROUPING)
+                    Log.v(TAG, "Evaluating if Token with Group ID:" + token.groupId
+                            + " has remaining");
+                for (int i1 = 0; i1 < mAppTokens.size(); i1++) {
+                    AppWindowToken currAppWindowToken = mAppTokens.get(i1);
+                    if (token != currAppWindowToken && token.groupId == currAppWindowToken.groupId) {
+                        if (DEBUG_WP_GROUPING)
+                            Log.v(TAG, "Other Token with Group ID:" + token.groupId + " found");
+                        doTokensWithIdStillExist = true;
+                        break;
+                    }
+                }
+                // No other tokens with this groupid exist, remove it from it's
+                // window frame
+                if (!doTokensWithIdStillExist) {
+                    for (int i1 = 0; i1 < mWindowPanels.size(); i1++) {
+                        WindowPanel wp = mWindowPanels.get(i1);
+                        // Found the Window Panel containing this token's group
+                        if (wp.contains(token.groupId)) {
+                            wp.removeGroupId(token.groupId);
+                            if (wp.isWindowPanelEmpty()) {
+                                if (DEBUG_WP_GROUPING)
+                                    Log.v(TAG, "WP: " + wp + " now empty, removing...");
+                                mWindowPanels.remove(wp);
+                            }
+                        }
+                    }
+                }
                 mExitingAppTokens.remove(i);
             }
         }
@@ -9200,7 +12955,6 @@ public class WindowManagerService extends IWindowManager.Stub
 
     void scheduleAnimationLocked() {
         if (!mAnimationScheduled) {
-        	//Slog.i(TAG,"scheduleAnimationLocked: "+Debug.getCallers(5));
             mChoreographer.postCallback(Choreographer.CALLBACK_ANIMATION, mAnimationRunnable, null);
             mAnimationScheduled = true;
         }
@@ -9700,10 +13454,6 @@ public class WindowManagerService extends IWindowManager.Stub
         mPolicy.lockNow();
     }
 
-	public void resetInputCalibration(){
-		mInputManager.resetTouchCalibration();
-	}
-	
     void dumpPolicyLocked(PrintWriter pw, String[] args, boolean dumpAll) {
         pw.println("WINDOW MANAGER POLICY STATE (dumpsys window policy)");
         mPolicy.dump("    ", pw, args);
diff --git a/frameworks/base/services/java/com/android/server/wm/WindowState.java b/frameworks/base/services/java/com/android/server/wm/WindowState.java
index a00e8a5..8ac0f4e 100644
--- a/frameworks/base/services/java/com/android/server/wm/WindowState.java
+++ b/frameworks/base/services/java/com/android/server/wm/WindowState.java
@@ -25,6 +25,10 @@ import static android.view.WindowManager.LayoutParams.TYPE_WALLPAPER;
 
 import com.android.server.input.InputWindowHandle;
 
+import com.android.server.wm.WindowManagerService.Cornerstone_State;
+import com.android.server.wm.WindowManagerService.H;
+import com.android.server.wm.WindowManagerService.WindowPanel;
+
 import android.content.Context;
 import android.content.res.Configuration;
 import android.graphics.Matrix;
@@ -363,6 +367,25 @@ final class WindowState implements WindowManagerPolicy.WindowState {
         final Rect display = mDisplayFrame;
         display.set(df);
 
+        /**
+         * Author: Onskreen
+         * Date: 08/04/2011
+         *
+         * This block commented out.
+         * Compatibility mode is not yet fully supported. It causes issues on the
+         * Viewsonic. Until we fully evaluate this feature, we are
+         * laying out the same regardless of compatibility mode being set or not
+         * by the WindowState. Assumedly, This will have to be reverted when we fully
+         * support compatibility mode.
+         *
+         */
+		/*if ((mAttrs.flags & FLAG_COMPATIBLE_WINDOW) != 0) {
+			container.intersect(mCompatibleScreenFrame);
+			if ((mAttrs.flags & FLAG_LAYOUT_NO_LIMITS) == 0) {
+			    display.intersect(mCompatibleScreenFrame);
+			}
+		}*/
+
         final int pw = container.right - container.left;
         final int ph = container.bottom - container.top;
 
@@ -399,6 +422,28 @@ final class WindowState implements WindowManagerPolicy.WindowState {
             }
         }
 
+        /**
+         * Author: Onskreen
+         * Date: 03/08/2011
+         *
+         * When width(w) and height(h) of the window frame exceeds the container rect's
+         * width(pw) and height(ph), we should set the width(w) and height(h) of the window
+         * frame to the actual container rect. It's been exprienced that when apps like YouTube
+         * runs in to portrait mode in either cs panels, it renders outside of its layout
+         * rect and to overcome that issue, we're setting the width of frame to its container
+         * rect's width. This solution renders the Youtube app within its layout rect but for
+         * some unknown reason when video is playing, it doesn't render by covering the width
+         * of the cs panel window.
+         */
+		if(w > pw && h > ph){
+			w = pw;
+			//h = ph;
+			if(mAttrs.x < 0){
+				mAttrs.x = 0;
+			}
+			mRequestedWidth = w;
+		}
+
         if (!mParentFrame.equals(pf)) {
             //Slog.i(TAG, "Window " + this + " content frame from " + mParentFrame
             //        + " to " + pf);
@@ -442,6 +487,62 @@ final class WindowState implements WindowManagerPolicy.WindowState {
         // Now make sure the window fits in the overall display.
         Gravity.applyDisplay(mAttrs.gravity, df, frame);
 
+        /**
+         * Author: Onskreen
+         * Date: 16/12/2011
+         *
+         * When user launches actionbar menu or types in search/address
+         * bar in browser app in either cs panels, then such Windows
+         * mFrame was set or calculated outside the total screen area
+         * after the Gravity applied by the above code. This can be
+         * resolved by setting the frame rect to fit into its container
+         * rect.
+         */
+        if(this.mAppToken != null) {
+			WindowPanel wp = mService.findWindowPanel(this.mAppToken.token);
+			if(wp!=null) {
+				if(wp.isCornerstonePanel() &&
+					mAttrs.type == WindowManager.LayoutParams.TYPE_APPLICATION_PANEL
+					&& (frame.left > container.left ||
+						frame.bottom < container.bottom)) {
+					frame.left = container.right - w;
+					frame.right = container.right;
+
+                   /**
+                    * Author: Onskreen
+                    * Date: 04/01/2013
+                    *
+                    * Resetting frame's top and bottom positions
+                    * of Action bar window.
+                    */
+					if(frame.bottom > container.bottom) {
+						frame.top = container.top + 44;
+						int diff = 0;
+						if(mRequestedHeight > ph) {
+							diff = mRequestedHeight - ph;
+						} else {
+							diff = ph - mRequestedHeight;
+						}
+						frame.bottom = container.bottom + diff + 44;
+					}
+                   /**
+                    * Author: Onskreen
+                    * Date: 04/01/2013
+                    *
+                    * Resetting frame's top and bottom positions
+                    * of attached windows such as Browser app's
+                    * auto-complete PopupWindow.
+                    */
+					if(frame.top < container.top) {
+						frame.top = container.top + 50;
+						frame.bottom = mRequestedHeight + container.top + 50;
+					}
+					//mRequestedHeight = frame.bottom - frame.top;
+					//h = mRequestedHeight;
+				}
+			}
+		}
+
         // Make sure the system, content and visible frames are inside of the
         // final window frame.
         if (content.left < frame.left) content.left = frame.left;
@@ -847,6 +948,142 @@ final class WindowState implements WindowManagerPolicy.WindowState {
         mInputWindowHandle.inputChannel = null;
     }
 
+    /**
+     * Author: Onskreen
+     * Date: 14/04/2011
+     *
+     * Newly added method to WindowManagerPolicy.WindowState.
+     * Returns true if this WindowState is currently focused.
+     */
+    public boolean isFocused() {
+		if(mService.getFocusedWindow() == this) {
+			return true;
+		} else {
+			return false;
+		}
+    }
+
+    /**
+     * Author: Onskreen
+     * Date: 15/04/2011
+     *
+     * Newly added method to WindowManagerPolicy.WindowState.
+     * Returns true if the WindowState will be obstructed by the soft keyboard
+     * due to it's position on the screen.
+     *
+     * Perhaps this should be named wouldBeObstructedByKeyboard, because
+     * doesn't check if IME is present. That is responsibility of the caller.
+     *
+     */
+    public boolean isObstructedByKeyboard() {
+		if(this.mAppToken == null) return false;
+		WindowPanel wp = mService.findWindowPanel(mAppToken.groupId);
+
+		if(mConfiguration == null) {
+			return false;
+		}
+
+		//Landscape logic - Only lower Cornerstone Panel is obstructed
+		if(mConfiguration.orientation == Configuration.ORIENTATION_LANDSCAPE) {
+			if(wp.isCornerstonePanel()&& wp.mCornerstonePanelIndex==1)
+				return true;
+			else
+				return false;
+
+		} else if(mConfiguration.orientation == Configuration.ORIENTATION_PORTRAIT) {
+			//Portrait Logic - Both Cornerstone Panels are obstructed
+			if(wp.isCornerstonePanel())
+				return true;
+			else
+				return false;
+		} else {
+			//Unknown configuration
+			return false;
+		}
+    }
+
+    /**
+     * Author: Onskreen
+     * Date: 26/05/2011
+     *
+     * Newly added method to WindowManagerPolicy.WindowState.
+     * Returns true if the WindowState is of type dialog
+     *
+     */
+    public boolean isDialog(){
+		boolean dialog = false;
+		WindowManager.LayoutParams params = mAttrs;
+		int type = params.type;
+		int flags = params.flags;
+		if (params != null) {
+            /**
+             * Author: Onskreen
+             * Date: 20/12/2011
+             *
+             * None of these TYPEs exist anymore in 4.0.3. For now returning false. Have to figure out how to detect dialogs now?
+             *
+             * Commented out entire if block for now.
+             */
+			dialog = false;
+			/**dialog = ((type == TYPE_APPLICATION_ATTACHED_DIALOG)
+                 || (type == TYPE_KEYGUARD_DIALOG)
+                 || (type == TYPE_TOAST)
+                 || (type == TYPE_SYSTEM_ERROR)
+                 || (type == TYPE_SYSTEM_ALERT)
+               //|| (type == TYPE_SEARCH_BAR)
+               //|| (type == TYPE_STATUS_BAR)
+                 || (type == TYPE_SYSTEM_DIALOG)
+                 || (type == TYPE_CHANGED)
+                 || (((flags == (FLAG_ALT_FOCUSABLE_IM | FLAG_DIM_BEHIND))) && (type == TYPE_BASE_APPLICATION))) ? true : false; **/
+		}
+		return dialog;
+    }
+
+    /**
+     * Author: Onskreen
+     * Date: 26/05/2011
+     *
+     * Newly added method to WindowManagerPolicy.WindowState.
+     * Returns IBinder token value
+     *
+     */
+    public IBinder getToken(){
+        return mToken != null ? mToken.token : null;
+    }
+
+    /**
+     * Author: Onskreen
+     * Date: 31/05/2011
+     *
+     * Newly added method to WindowManagerPolicy.WindowState.
+     * Removes the Window from the window list.
+     */
+    public void removeWindowState(){
+        if(mClient != null && mSession != null){
+            mSession.remove(mClient);
+        }
+    }
+
+    /**
+     * Author: Onskreen
+     * Date: 16/06/2011
+     *
+     * Newly added method to WindowManagerPolicy.WindowState.
+     * Returns true if window panel is in cornerstone panel else false.
+     */
+    public boolean isInCornerstonePanelWindowPanel(IBinder token){
+        IBinder appToken = getToken();
+        if(appToken != null){
+            WindowPanel wp = mService.findWindowPanel(appToken);
+            if(wp != null){
+                return wp.contains(token);
+            }
+        }
+        return false;
+    }
+
+
+
     private class DeathRecipient implements IBinder.DeathRecipient {
         public void binderDied() {
             try {
diff --git a/frameworks/base/services/java/com/android/server/wm/WindowStateAnimator.java b/frameworks/base/services/java/com/android/server/wm/WindowStateAnimator.java
index e399042..56b4ced 100644
--- a/frameworks/base/services/java/com/android/server/wm/WindowStateAnimator.java
+++ b/frameworks/base/services/java/com/android/server/wm/WindowStateAnimator.java
@@ -16,7 +16,6 @@ import android.graphics.PointF;
 import android.graphics.Rect;
 import android.graphics.Region;
 import android.os.Debug;
-import android.os.Trace;
 import android.util.Slog;
 import android.view.Surface;
 import android.view.SurfaceSession;
@@ -28,6 +27,8 @@ import android.view.animation.AnimationUtils;
 import android.view.animation.Transformation;
 
 import com.android.server.wm.WindowManagerService.H;
+import com.android.server.wm.WindowManagerService.WindowPanel;
+import com.android.server.wm.WindowManagerService.Cornerstone_State;
 
 import java.io.PrintWriter;
 import java.util.ArrayList;
@@ -944,6 +940,59 @@ class WindowStateAnimator {
         if (WindowManagerService.localLOGV) Slog.v(
                 TAG, "computeShownFrameLocked: " + this +
                 " not attached, mAlpha=" + mAlpha);
+
+        /**
+         * Author: Onskreen
+         * Date: 25/02/2011
+         *
+         * When the cornerstone is in a state change we know there is an animation. At the end
+         * of which we want the cornerstone and cornerstone panels to remain in there final
+         * animated positions, not the original position they started in (which is what
+         * happens with no changes to the logic here).
+         *
+         * We are relying on the fact that the cornerstone is always at the bottom of the
+         * mWindows, so not unsetting mCornerstoneStateChange flag until we encounter it
+         * after the animation is complete.
+         */
+        if(mService.mCornerstoneState != Cornerstone_State.TERMINATED &&			//Cornerstone is active
+             mService.mCornerstoneStateChangeAnimating &&//In the midst of a cornerstone state change
+             mWin.mAppToken!=null) {			//Ignore non app tokens
+
+			WindowPanel wp = mService.findWindowPanel(mWin.mAppToken.token);
+			if(wp!=null) {					//just in case...
+				if(WindowManagerService.DEBUG_CORNERSTONE) {
+					Slog.v(WindowManagerService.TAG, "WindowState.computeShownFrameLocked for: " + this);
+					Slog.v(WindowManagerService.TAG, "mCornerstoneStateChangeProcessing: " + mService.mCornerstoneStateChangeProcessing);
+					Slog.v(WindowManagerService.TAG, "mCornerstoneStateChangeAnimating: " + mService.mCornerstoneStateChangeAnimating);
+					Slog.v(WindowManagerService.TAG, "WP: " + wp);
+					Slog.v(WindowManagerService.TAG, "mFrame: " + mWin.mFrame);
+					Slog.v(WindowManagerService.TAG, "mShownFrame: " + mWin.mShownFrame);
+				}
+
+				/**
+				 * Cornerstone and panels should be locked to their final
+				 * animated position.
+				 */
+				if(wp.isCornerstone() || wp.isCornerstonePanel() &&
+						mAnimating == false) {						//Only lock the frame at the end of the animation
+					if(WindowManagerService.DEBUG_CORNERSTONE) {
+						Slog.v(WindowManagerService.TAG, "Animation complete, locking frames");
+					}
+
+					Rect rect = mService.computeWindowPanelRect(wp, mService.mCurConfiguration.orientation, mService.mCornerstoneState);
+					if(WindowManagerService.DEBUG_CORNERSTONE) {
+						Slog.v(WindowManagerService.TAG, "Updating " + wp + " to: " + rect);
+					}
+					wp.setFrame(rect);
+
+					if(wp.isCornerstone()) {
+						if(WindowManagerService.DEBUG_CORNERSTONE) Slog.v(WindowManagerService.TAG, "Setting mCornerstoneStateChangeAnimating to False");
+						mService.mCornerstoneStateChangeAnimating = false;
+					}
+				}
+			}
+        }
+
         mWin.mShownFrame.set(mWin.mFrame);
         if (mWin.mXOffset != 0 || mWin.mYOffset != 0) {
             mWin.mShownFrame.offset(mWin.mXOffset, mWin.mYOffset);
diff --git a/frameworks/base/tools/layoutlib/bridge/src/com/android/layoutlib/bridge/android/BridgeWindowSession.java b/frameworks/base/tools/layoutlib/bridge/src/com/android/layoutlib/bridge/android/BridgeWindowSession.java
index 7694f88..7bf1aa9 100644
--- a/frameworks/base/tools/layoutlib/bridge/src/com/android/layoutlib/bridge/android/BridgeWindowSession.java
+++ b/frameworks/base/tools/layoutlib/bridge/src/com/android/layoutlib/bridge/android/BridgeWindowSession.java
@@ -176,4 +172,15 @@ public final class BridgeWindowSession implements IWindowSession {
         // pass for now.
         return null;
     }
-}
+
+    /**
+     * Author: Onskreen
+     * Date: 17/02/2011
+     *
+     * Notifies the WindowManagerService to reshuffle its z-order to dispatch
+     * the user input event to the newly focused window.
+     */
+    public void handleFocusChange(IBinder token){
+        // pass for now.
+    }
+}
\ No newline at end of file
